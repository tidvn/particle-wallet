import{u as Xo,w as sn,x as on,v as Qo,y as ei,S as ti,z as G,A as ri,B as ni,C as lt,D as Rr,E as Gn,F as si,G as oi,H as Yn,I as rt,J as ii,K as ai,L as ci,M as ui,N as li,O as di,P as Ve,j as Jt,c as Ye,b as fi,Q as we,d as M,R as hi,T as pi,U as yi,V as Ps,k as Ts,W as Jn,X as Zn,Y as an,Z as Xn}from"./index.fbf0f355.js";var Qn,Br,Pr=0,Tr=0;function gi(s,e,t){var r=e&&t||0,n=e||new Array(16);s=s||{};var o=s.node||Qn,i=s.clockseq!==void 0?s.clockseq:Br;if(o==null||i==null){var a=s.random||(s.rng||Xo)();o==null&&(o=Qn=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=Br=(a[6]<<8|a[7])&16383)}var c=s.msecs!==void 0?s.msecs:Date.now(),l=s.nsecs!==void 0?s.nsecs:Tr+1,u=c-Pr+(l-Tr)/1e4;if(u<0&&s.clockseq===void 0&&(i=i+1&16383),(u<0||c>Pr)&&s.nsecs===void 0&&(l=0),l>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");Pr=c,Tr=l,Br=i,c+=122192928e5;var y=((c&268435455)*1e4+l)%4294967296;n[r++]=y>>>24&255,n[r++]=y>>>16&255,n[r++]=y>>>8&255,n[r++]=y&255;var m=c/4294967296*1e4&268435455;n[r++]=m>>>8&255,n[r++]=m&255,n[r++]=m>>>24&15|16,n[r++]=m>>>16&255,n[r++]=i>>>8|128,n[r++]=i&255;for(var g=0;g<6;++g)n[r+g]=o[g];return e||sn(n)}function Ls(s){if(!on(s))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(s.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(s.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(s.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(s.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(s.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function bi(s){s=unescape(encodeURIComponent(s));for(var e=[],t=0;t<s.length;++t)e.push(s.charCodeAt(t));return e}var mi="6ba7b810-9dad-11d1-80b4-00c04fd430c8",wi="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function Cs(s,e,t){function r(n,o,i,a){if(typeof n=="string"&&(n=bi(n)),typeof o=="string"&&(o=Ls(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+n.length);if(c.set(o),c.set(n,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var l=0;l<16;++l)i[a+l]=c[l];return i}return sn(c)}try{r.name=s}catch{}return r.DNS=mi,r.URL=wi,r}function ki(s){if(typeof s=="string"){var e=unescape(encodeURIComponent(s));s=new Uint8Array(e.length);for(var t=0;t<e.length;++t)s[t]=e.charCodeAt(t)}return Si(Ii(_i(s),s.length*8))}function Si(s){for(var e=[],t=s.length*32,r="0123456789abcdef",n=0;n<t;n+=8){var o=s[n>>5]>>>n%32&255,i=parseInt(r.charAt(o>>>4&15)+r.charAt(o&15),16);e.push(i)}return e}function Os(s){return(s+64>>>9<<4)+14+1}function Ii(s,e){s[e>>5]|=128<<e%32,s[Os(e)-1]=e;for(var t=1732584193,r=-271733879,n=-1732584194,o=271733878,i=0;i<s.length;i+=16){var a=t,c=r,l=n,u=o;t=ve(t,r,n,o,s[i],7,-680876936),o=ve(o,t,r,n,s[i+1],12,-389564586),n=ve(n,o,t,r,s[i+2],17,606105819),r=ve(r,n,o,t,s[i+3],22,-1044525330),t=ve(t,r,n,o,s[i+4],7,-176418897),o=ve(o,t,r,n,s[i+5],12,1200080426),n=ve(n,o,t,r,s[i+6],17,-1473231341),r=ve(r,n,o,t,s[i+7],22,-45705983),t=ve(t,r,n,o,s[i+8],7,1770035416),o=ve(o,t,r,n,s[i+9],12,-1958414417),n=ve(n,o,t,r,s[i+10],17,-42063),r=ve(r,n,o,t,s[i+11],22,-1990404162),t=ve(t,r,n,o,s[i+12],7,1804603682),o=ve(o,t,r,n,s[i+13],12,-40341101),n=ve(n,o,t,r,s[i+14],17,-1502002290),r=ve(r,n,o,t,s[i+15],22,1236535329),t=Ae(t,r,n,o,s[i+1],5,-165796510),o=Ae(o,t,r,n,s[i+6],9,-1069501632),n=Ae(n,o,t,r,s[i+11],14,643717713),r=Ae(r,n,o,t,s[i],20,-373897302),t=Ae(t,r,n,o,s[i+5],5,-701558691),o=Ae(o,t,r,n,s[i+10],9,38016083),n=Ae(n,o,t,r,s[i+15],14,-660478335),r=Ae(r,n,o,t,s[i+4],20,-405537848),t=Ae(t,r,n,o,s[i+9],5,568446438),o=Ae(o,t,r,n,s[i+14],9,-1019803690),n=Ae(n,o,t,r,s[i+3],14,-187363961),r=Ae(r,n,o,t,s[i+8],20,1163531501),t=Ae(t,r,n,o,s[i+13],5,-1444681467),o=Ae(o,t,r,n,s[i+2],9,-51403784),n=Ae(n,o,t,r,s[i+7],14,1735328473),r=Ae(r,n,o,t,s[i+12],20,-1926607734),t=Ee(t,r,n,o,s[i+5],4,-378558),o=Ee(o,t,r,n,s[i+8],11,-2022574463),n=Ee(n,o,t,r,s[i+11],16,1839030562),r=Ee(r,n,o,t,s[i+14],23,-35309556),t=Ee(t,r,n,o,s[i+1],4,-1530992060),o=Ee(o,t,r,n,s[i+4],11,1272893353),n=Ee(n,o,t,r,s[i+7],16,-155497632),r=Ee(r,n,o,t,s[i+10],23,-1094730640),t=Ee(t,r,n,o,s[i+13],4,681279174),o=Ee(o,t,r,n,s[i],11,-358537222),n=Ee(n,o,t,r,s[i+3],16,-722521979),r=Ee(r,n,o,t,s[i+6],23,76029189),t=Ee(t,r,n,o,s[i+9],4,-640364487),o=Ee(o,t,r,n,s[i+12],11,-421815835),n=Ee(n,o,t,r,s[i+15],16,530742520),r=Ee(r,n,o,t,s[i+2],23,-995338651),t=xe(t,r,n,o,s[i],6,-198630844),o=xe(o,t,r,n,s[i+7],10,1126891415),n=xe(n,o,t,r,s[i+14],15,-1416354905),r=xe(r,n,o,t,s[i+5],21,-57434055),t=xe(t,r,n,o,s[i+12],6,1700485571),o=xe(o,t,r,n,s[i+3],10,-1894986606),n=xe(n,o,t,r,s[i+10],15,-1051523),r=xe(r,n,o,t,s[i+1],21,-2054922799),t=xe(t,r,n,o,s[i+8],6,1873313359),o=xe(o,t,r,n,s[i+15],10,-30611744),n=xe(n,o,t,r,s[i+6],15,-1560198380),r=xe(r,n,o,t,s[i+13],21,1309151649),t=xe(t,r,n,o,s[i+4],6,-145523070),o=xe(o,t,r,n,s[i+11],10,-1120210379),n=xe(n,o,t,r,s[i+2],15,718787259),r=xe(r,n,o,t,s[i+9],21,-343485551),t=ht(t,a),r=ht(r,c),n=ht(n,l),o=ht(o,u)}return[t,r,n,o]}function _i(s){if(s.length===0)return[];for(var e=s.length*8,t=new Uint32Array(Os(e)),r=0;r<e;r+=8)t[r>>5]|=(s[r/8]&255)<<r%32;return t}function ht(s,e){var t=(s&65535)+(e&65535),r=(s>>16)+(e>>16)+(t>>16);return r<<16|t&65535}function vi(s,e){return s<<e|s>>>32-e}function yr(s,e,t,r,n,o){return ht(vi(ht(ht(e,s),ht(r,o)),n),t)}function ve(s,e,t,r,n,o,i){return yr(e&t|~e&r,s,e,n,o,i)}function Ae(s,e,t,r,n,o,i){return yr(e&r|t&~r,s,e,n,o,i)}function Ee(s,e,t,r,n,o,i){return yr(e^t^r,s,e,n,o,i)}function xe(s,e,t,r,n,o,i){return yr(t^(e|~r),s,e,n,o,i)}var Ai=Cs("v3",48,ki);const Ei=Ai;function xi(s,e,t,r){switch(s){case 0:return e&t^~e&r;case 1:return e^t^r;case 2:return e&t^e&r^t&r;case 3:return e^t^r}}function Lr(s,e){return s<<e|s>>>32-e}function Ri(s){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof s=="string"){var r=unescape(encodeURIComponent(s));s=[];for(var n=0;n<r.length;++n)s.push(r.charCodeAt(n))}else Array.isArray(s)||(s=Array.prototype.slice.call(s));s.push(128);for(var o=s.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var l=new Uint32Array(16),u=0;u<16;++u)l[u]=s[c*64+u*4]<<24|s[c*64+u*4+1]<<16|s[c*64+u*4+2]<<8|s[c*64+u*4+3];a[c]=l}a[i-1][14]=(s.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(s.length-1)*8&4294967295;for(var y=0;y<i;++y){for(var m=new Uint32Array(80),g=0;g<16;++g)m[g]=a[y][g];for(var S=16;S<80;++S)m[S]=Lr(m[S-3]^m[S-8]^m[S-14]^m[S-16],1);for(var w=t[0],k=t[1],B=t[2],U=t[3],_=t[4],v=0;v<80;++v){var N=Math.floor(v/20),A=Lr(w,5)+xi(N,k,B,U)+_+e[N]+m[v]>>>0;_=U,U=B,B=Lr(k,30)>>>0,k=w,w=A}t[0]=t[0]+w>>>0,t[1]=t[1]+k>>>0,t[2]=t[2]+B>>>0,t[3]=t[3]+U>>>0,t[4]=t[4]+_>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var Bi=Cs("v5",80,Ri);const Pi=Bi,Ti="00000000-0000-0000-0000-000000000000";function Li(s){if(!on(s))throw TypeError("Invalid UUID");return parseInt(s.substr(14,1),16)}const Ci=Object.freeze(Object.defineProperty({__proto__:null,v1:gi,v3:Ei,v4:Qo,v5:Pi,NIL:Ti,version:Li,validate:on,stringify:sn,parse:Ls},Symbol.toStringTag,{value:"Module"})),[Oi,zi]=(()=>G.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(s=>BigInt(s))))(),dt=new Uint32Array(80),ft=new Uint32Array(80);class Ni extends ti{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:o,Cl:i,Dh:a,Dl:c,Eh:l,El:u,Fh:y,Fl:m,Gh:g,Gl:S,Hh:w,Hl:k}=this;return[e,t,r,n,o,i,a,c,l,u,y,m,g,S,w,k]}set(e,t,r,n,o,i,a,c,l,u,y,m,g,S,w,k){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=n|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=y|0,this.Fl=m|0,this.Gh=g|0,this.Gl=S|0,this.Hh=w|0,this.Hl=k|0}process(e,t){for(let _=0;_<16;_++,t+=4)dt[_]=e.getUint32(t),ft[_]=e.getUint32(t+=4);for(let _=16;_<80;_++){const v=dt[_-15]|0,N=ft[_-15]|0,A=G.rotrSH(v,N,1)^G.rotrSH(v,N,8)^G.shrSH(v,N,7),H=G.rotrSL(v,N,1)^G.rotrSL(v,N,8)^G.shrSL(v,N,7),z=dt[_-2]|0,q=ft[_-2]|0,ie=G.rotrSH(z,q,19)^G.rotrBH(z,q,61)^G.shrSH(z,q,6),ye=G.rotrSL(z,q,19)^G.rotrBL(z,q,61)^G.shrSL(z,q,6),Re=G.add4L(H,ye,ft[_-7],ft[_-16]),Be=G.add4H(Re,A,ie,dt[_-7],dt[_-16]);dt[_]=Be|0,ft[_]=Re|0}let{Ah:r,Al:n,Bh:o,Bl:i,Ch:a,Cl:c,Dh:l,Dl:u,Eh:y,El:m,Fh:g,Fl:S,Gh:w,Gl:k,Hh:B,Hl:U}=this;for(let _=0;_<80;_++){const v=G.rotrSH(y,m,14)^G.rotrSH(y,m,18)^G.rotrBH(y,m,41),N=G.rotrSL(y,m,14)^G.rotrSL(y,m,18)^G.rotrBL(y,m,41),A=y&g^~y&w,H=m&S^~m&k,z=G.add5L(U,N,H,zi[_],ft[_]),q=G.add5H(z,B,v,A,Oi[_],dt[_]),ie=z|0,ye=G.rotrSH(r,n,28)^G.rotrBH(r,n,34)^G.rotrBH(r,n,39),Re=G.rotrSL(r,n,28)^G.rotrBL(r,n,34)^G.rotrBL(r,n,39),Be=r&o^r&a^o&a,ct=n&i^n&c^i&c;B=w|0,U=k|0,w=g|0,k=S|0,g=y|0,S=m|0,{h:y,l:m}=G.add(l|0,u|0,q|0,ie|0),l=a|0,u=c|0,a=o|0,c=i|0,o=r|0,i=n|0;const et=G.add3L(ie,Re,ct);r=G.add3H(et,q,ye,Be),n=et|0}({h:r,l:n}=G.add(this.Ah|0,this.Al|0,r|0,n|0)),{h:o,l:i}=G.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=G.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=G.add(this.Dh|0,this.Dl|0,l|0,u|0),{h:y,l:m}=G.add(this.Eh|0,this.El|0,y|0,m|0),{h:g,l:S}=G.add(this.Fh|0,this.Fl|0,g|0,S|0),{h:w,l:k}=G.add(this.Gh|0,this.Gl|0,w|0,k|0),{h:B,l:U}=G.add(this.Hh|0,this.Hl|0,B|0,U|0),this.set(r,n,o,i,a,c,l,u,y,m,g,S,w,k,B,U)}roundClean(){dt.fill(0),ft.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const zs=ei(()=>new Ni);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qe=BigInt(0),ze=BigInt(1),sr=BigInt(2),Ui=BigInt(8),Ki={zip215:!0};function Wi(s){const e=ri(s);return ni(s,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function cn(s){const e=Wi(s),{Fp:t,n:r,prehash:n,hash:o,randomBytes:i,nByteLength:a,h:c}=e,l=sr<<BigInt(a*8)-ze,u=t.create,y=e.uvRatio||((D,h)=>{try{return{isValid:!0,value:t.sqrt(D*t.inv(h))}}catch{return{isValid:!1,value:qe}}}),m=e.adjustScalarBytes||(D=>D),g=e.domain||((D,h,p)=>{if(h.length||p)throw new Error("Contexts/pre-hash are not supported");return D}),S=D=>typeof D=="bigint"&&qe<D,w=(D,h)=>S(D)&&S(h)&&D<h,k=D=>D===qe||w(D,l);function B(D,h){if(w(D,h))return D;throw new Error(`Expected valid scalar < ${h}, got ${typeof D} ${D}`)}function U(D){return D===qe?D:B(D,r)}const _=new Map;function v(D){if(!(D instanceof N))throw new Error("ExtendedPoint expected")}class N{constructor(h,p,b,P){if(this.ex=h,this.ey=p,this.ez=b,this.et=P,!k(h))throw new Error("x required");if(!k(p))throw new Error("y required");if(!k(b))throw new Error("z required");if(!k(P))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(h){if(h instanceof N)throw new Error("extended point not allowed");const{x:p,y:b}=h||{};if(!k(p)||!k(b))throw new Error("invalid affine point");return new N(p,b,ze,u(p*b))}static normalizeZ(h){const p=t.invertBatch(h.map(b=>b.ez));return h.map((b,P)=>b.toAffine(p[P])).map(N.fromAffine)}_setWindowSize(h){this._WINDOW_SIZE=h,_.delete(this)}assertValidity(){const{a:h,d:p}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:b,ey:P,ez:C,et:T}=this,V=u(b*b),j=u(P*P),Z=u(C*C),le=u(Z*Z),fe=u(V*h),be=u(Z*u(fe+j)),Te=u(le+u(p*u(V*j)));if(be!==Te)throw new Error("bad point: equation left != right (1)");const ut=u(b*P),tt=u(C*T);if(ut!==tt)throw new Error("bad point: equation left != right (2)")}equals(h){v(h);const{ex:p,ey:b,ez:P}=this,{ex:C,ey:T,ez:V}=h,j=u(p*V),Z=u(C*P),le=u(b*V),fe=u(T*P);return j===Z&&le===fe}is0(){return this.equals(N.ZERO)}negate(){return new N(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:h}=e,{ex:p,ey:b,ez:P}=this,C=u(p*p),T=u(b*b),V=u(sr*u(P*P)),j=u(h*C),Z=p+b,le=u(u(Z*Z)-C-T),fe=j+T,be=fe-V,Te=j-T,ut=u(le*be),tt=u(fe*Te),rr=u(le*Te),nr=u(be*fe);return new N(ut,tt,nr,rr)}add(h){v(h);const{a:p,d:b}=e,{ex:P,ey:C,ez:T,et:V}=this,{ex:j,ey:Z,ez:le,et:fe}=h;if(p===BigInt(-1)){const Dn=u((C-P)*(Z+j)),qn=u((C+P)*(Z-j)),xr=u(qn-Dn);if(xr===qe)return this.double();const Mn=u(T*sr*fe),$n=u(V*sr*le),Hn=$n+Mn,Vn=qn+Dn,jn=$n-Mn,Go=u(Hn*xr),Yo=u(Vn*jn),Jo=u(Hn*jn),Zo=u(xr*Vn);return new N(Go,Yo,Zo,Jo)}const be=u(P*j),Te=u(C*Z),ut=u(V*b*fe),tt=u(T*le),rr=u((P+C)*(j+Z)-be-Te),nr=tt-ut,Wn=tt+ut,Fn=u(Te-p*be),$o=u(rr*nr),Ho=u(Wn*Fn),Vo=u(rr*Fn),jo=u(nr*Wn);return new N($o,Ho,jo,Vo)}subtract(h){return this.add(h.negate())}wNAF(h){return z.wNAFCached(this,_,h,N.normalizeZ)}multiply(h){const{p,f:b}=this.wNAF(B(h,r));return N.normalizeZ([p,b])[0]}multiplyUnsafe(h){let p=U(h);return p===qe?H:this.equals(H)||p===ze?this:this.equals(A)?this.wNAF(p).p:z.unsafeLadder(this,p)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return z.unsafeLadder(this,r).is0()}toAffine(h){const{ex:p,ey:b,ez:P}=this,C=this.is0();h==null&&(h=C?Ui:t.inv(P));const T=u(p*h),V=u(b*h),j=u(P*h);if(C)return{x:qe,y:ze};if(j!==ze)throw new Error("invZ was invalid");return{x:T,y:V}}clearCofactor(){const{h}=e;return h===ze?this:this.multiplyUnsafe(h)}static fromHex(h,p=!1){const{d:b,a:P}=e,C=t.BYTES;h=lt("pointHex",h,C);const T=h.slice(),V=h[C-1];T[C-1]=V&-129;const j=Rr(T);j===qe||(p?B(j,l):B(j,t.ORDER));const Z=u(j*j),le=u(Z-ze),fe=u(b*Z-P);let{isValid:be,value:Te}=y(le,fe);if(!be)throw new Error("Point.fromHex: invalid y coordinate");const ut=(Te&ze)===ze,tt=(V&128)!==0;if(!p&&Te===qe&&tt)throw new Error("Point.fromHex: x=0 and x_0=1");return tt!==ut&&(Te=u(-Te)),N.fromAffine({x:Te,y:j})}static fromPrivateKey(h){return ye(h).point}toRawBytes(){const{x:h,y:p}=this.toAffine(),b=Gn(p,t.BYTES);return b[b.length-1]|=h&ze?128:0,b}toHex(){return si(this.toRawBytes())}}N.BASE=new N(e.Gx,e.Gy,ze,u(e.Gx*e.Gy)),N.ZERO=new N(qe,ze,ze,qe);const{BASE:A,ZERO:H}=N,z=oi(N,a*8);function q(D){return rt(D,r)}function ie(D){return q(Rr(D))}function ye(D){const h=a;D=lt("private key",D,h);const p=lt("hashed private key",o(D),2*h),b=m(p.slice(0,h)),P=p.slice(h,2*h),C=ie(b),T=A.multiply(C),V=T.toRawBytes();return{head:b,prefix:P,scalar:C,point:T,pointBytes:V}}function Re(D){return ye(D).pointBytes}function Be(D=new Uint8Array,...h){const p=Yn(...h);return ie(o(g(p,lt("context",D),!!n)))}function ct(D,h,p={}){D=lt("message",D),n&&(D=n(D));const{prefix:b,scalar:P,pointBytes:C}=ye(h),T=Be(p.context,b,D),V=A.multiply(T).toRawBytes(),j=Be(p.context,V,C,D),Z=q(T+j*P);U(Z);const le=Yn(V,Gn(Z,t.BYTES));return lt("result",le,a*2)}const et=Ki;function mt(D,h,p,b=et){const{context:P,zip215:C}=b,T=t.BYTES;D=lt("signature",D,2*T),h=lt("message",h),n&&(h=n(h));const V=Rr(D.slice(T,2*T));let j,Z,le;try{j=N.fromHex(p,C),Z=N.fromHex(D.slice(0,T),C),le=A.multiplyUnsafe(V)}catch{return!1}if(!C&&j.isSmallOrder())return!1;const fe=Be(P,Z.toRawBytes(),j.toRawBytes(),h);return Z.add(j.multiplyUnsafe(fe)).subtract(le).clearCofactor().equals(N.ZERO)}return A._setWindowSize(8),{CURVE:e,getPublicKey:Re,sign:ct,verify:mt,ExtendedPoint:N,utils:{getExtendedPublicKey:ye,randomPrivateKey:()=>i(t.BYTES),precompute(D=8,h=N.BASE){return h._setWindowSize(D),h.multiply(BigInt(3)),h}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const un=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),es=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Fi=BigInt(1),Yr=BigInt(2),Di=BigInt(5),ts=BigInt(10),qi=BigInt(20),Mi=BigInt(40),rs=BigInt(80);function $i(s){const e=un,r=s*s%e*s%e,n=Ve(r,Yr,e)*r%e,o=Ve(n,Fi,e)*s%e,i=Ve(o,Di,e)*o%e,a=Ve(i,ts,e)*i%e,c=Ve(a,qi,e)*a%e,l=Ve(c,Mi,e)*c%e,u=Ve(l,rs,e)*l%e,y=Ve(u,rs,e)*l%e,m=Ve(y,ts,e)*i%e;return{pow_p_5_8:Ve(m,Yr,e)*s%e,b2:r}}function Hi(s){return s[0]&=248,s[31]&=127,s[31]|=64,s}function Vi(s,e){const t=un,r=rt(e*e*e,t),n=rt(r*r*e,t),o=$i(s*n).pow_p_5_8;let i=rt(s*r*o,t);const a=rt(e*i*i,t),c=i,l=rt(i*es,t),u=a===s,y=a===rt(-s,t),m=a===rt(-s*es,t);return u&&(i=c),(y||m)&&(i=l),ui(i,t)&&(i=rt(-i,t)),{isValid:u||y,value:i}}const at=ii(un,void 0,!0),ln={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:at,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:zs,randomBytes:ai,adjustScalarBytes:Hi,uvRatio:Vi},Wt=cn(ln);function Ns(s,e,t){if(e.length>255)throw new Error("Context is too big");return li(di("SigEd25519 no Ed25519 collisions"),new Uint8Array([t?1:0,e.length]),e,s)}({...ln});({...ln});const ji=(at.ORDER+BigInt(3))/BigInt(8);at.pow(Yr,ji);at.sqrt(at.neg(at.ONE));(at.ORDER-BigInt(5))/BigInt(8);BigInt(486662);ci(at,at.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var Se={};function st(s,e,t){return e<=s&&s<=t}function gr(s){if(s===void 0)return{};if(s===Object(s))return s;throw TypeError("Could not convert argument to dictionary")}function Gi(s){for(var e=String(s),t=e.length,r=0,n=[];r<t;){var o=e.charCodeAt(r);if(o<55296||o>57343)n.push(o);else if(56320<=o&&o<=57343)n.push(65533);else if(55296<=o&&o<=56319)if(r===t-1)n.push(65533);else{var i=s.charCodeAt(r+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;n.push(65536+(a<<10)+c),r+=1}else n.push(65533)}r+=1}return n}function Yi(s){for(var e="",t=0;t<s.length;++t){var r=s[t];r<=65535?e+=String.fromCharCode(r):(r-=65536,e+=String.fromCharCode((r>>10)+55296,(r&1023)+56320))}return e}var cr=-1;function dn(s){this.tokens=[].slice.call(s)}dn.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():cr},prepend:function(s){if(Array.isArray(s))for(var e=s;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(s)},push:function(s){if(Array.isArray(s))for(var e=s;e.length;)this.tokens.push(e.shift());else this.tokens.push(s)}};var zt=-1;function Cr(s,e){if(s)throw TypeError("Decoder error");return e||65533}var ur="utf-8";function lr(s,e){if(!(this instanceof lr))return new lr(s,e);if(s=s!==void 0?String(s).toLowerCase():ur,s!==ur)throw new Error("Encoding not supported. Only utf-8 is supported");e=gr(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=Boolean(e.fatal),this._ignoreBOM=Boolean(e.ignoreBOM),Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}lr.prototype={decode:function(e,t){var r;typeof e=="object"&&e instanceof ArrayBuffer?r=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):r=new Uint8Array(0),t=gr(t),this._streaming||(this._decoder=new Ji({fatal:this._fatal}),this._BOMseen=!1),this._streaming=Boolean(t.stream);for(var n=new dn(r),o=[],i;!n.endOfStream()&&(i=this._decoder.handler(n,n.read()),i!==zt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(n,n.read()),i===zt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!n.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),Yi(o)}};function dr(s,e){if(!(this instanceof dr))return new dr(s,e);if(s=s!==void 0?String(s).toLowerCase():ur,s!==ur)throw new Error("Encoding not supported. Only utf-8 is supported");e=gr(e),this._streaming=!1,this._encoder=null,this._options={fatal:Boolean(e.fatal)},Object.defineProperty(this,"encoding",{value:"utf-8"})}dr.prototype={encode:function(e,t){e=e?String(e):"",t=gr(t),this._streaming||(this._encoder=new Zi(this._options)),this._streaming=Boolean(t.stream);for(var r=[],n=new dn(Gi(e)),o;!n.endOfStream()&&(o=this._encoder.handler(n,n.read()),o!==zt);)Array.isArray(o)?r.push.apply(r,o):r.push(o);if(!this._streaming){for(;o=this._encoder.handler(n,n.read()),o!==zt;)Array.isArray(o)?r.push.apply(r,o):r.push(o);this._encoder=null}return new Uint8Array(r)}};function Ji(s){var e=s.fatal,t=0,r=0,n=0,o=128,i=191;this.handler=function(a,c){if(c===cr&&n!==0)return n=0,Cr(e);if(c===cr)return zt;if(n===0){if(st(c,0,127))return c;if(st(c,194,223))n=1,t=c-192;else if(st(c,224,239))c===224&&(o=160),c===237&&(i=159),n=2,t=c-224;else if(st(c,240,244))c===240&&(o=144),c===244&&(i=143),n=3,t=c-240;else return Cr(e);return t=t<<6*n,null}if(!st(c,o,i))return t=n=r=0,o=128,i=191,a.prepend(c),Cr(e);if(o=128,i=191,r+=1,t+=c-128<<6*(n-r),r!==n)return null;var l=t;return t=n=r=0,l}}function Zi(s){s.fatal,this.handler=function(e,t){if(t===cr)return zt;if(st(t,0,127))return t;var r,n;st(t,128,2047)?(r=1,n=192):st(t,2048,65535)?(r=2,n=224):st(t,65536,1114111)&&(r=3,n=240);for(var o=[(t>>6*r)+n];r>0;){var i=t>>6*(r-1);o.push(128|i&63),r-=1}return o}}const Xi=Object.freeze(Object.defineProperty({__proto__:null,TextEncoder:dr,TextDecoder:lr},Symbol.toStringTag,{value:"Module"})),Qi=Jt(Xi);var ea=Ye&&Ye.__createBinding||(Object.create?function(s,e,t,r){r===void 0&&(r=t),Object.defineProperty(s,r,{enumerable:!0,get:function(){return e[t]}})}:function(s,e,t,r){r===void 0&&(r=t),s[r]=e[t]}),ta=Ye&&Ye.__setModuleDefault||(Object.create?function(s,e){Object.defineProperty(s,"default",{enumerable:!0,value:e})}:function(s,e){s.default=e}),Ze=Ye&&Ye.__decorate||function(s,e,t,r){var n=arguments.length,o=n<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,t):r,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(s,e,t,r);else for(var a=s.length-1;a>=0;a--)(i=s[a])&&(o=(n<3?i(o):n>3?i(e,t,o):i(e,t))||o);return n>3&&o&&Object.defineProperty(e,t,o),o},ra=Ye&&Ye.__importStar||function(s){if(s&&s.__esModule)return s;var e={};if(s!=null)for(var t in s)t!=="default"&&Object.hasOwnProperty.call(s,t)&&ea(e,s,t);return ta(e,s),e},Us=Ye&&Ye.__importDefault||function(s){return s&&s.__esModule?s:{default:s}};Object.defineProperty(Se,"__esModule",{value:!0});var Ks=Se.deserializeUnchecked=$s=Se.deserialize=Ms=Se.serialize=Se.BinaryReader=Se.BinaryWriter=Se.BorshError=Se.baseDecode=Se.baseEncode=void 0;const pt=Us(fi.exports),Ws=Us(we),na=ra(Qi),sa=typeof TextDecoder!="function"?na.TextDecoder:TextDecoder,oa=new sa("utf-8",{fatal:!0});function ia(s){return typeof s=="string"&&(s=Buffer.from(s,"utf8")),Ws.default.encode(Buffer.from(s))}Se.baseEncode=ia;function aa(s){return Buffer.from(Ws.default.decode(s))}Se.baseDecode=aa;const Or=1024;class Pe extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}Se.BorshError=Pe;class Fs{constructor(){this.buf=Buffer.alloc(Or),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(Or)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(Buffer.from(new pt.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(Buffer.from(new pt.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(Buffer.from(new pt.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(Buffer.from(new pt.default(e).toArray("le",64)))}writeBuffer(e){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),e,Buffer.alloc(Or)]),this.length+=e.length}writeString(e){this.maybeResize();const t=Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const r of e)this.maybeResize(),t(r)}toArray(){return this.buf.subarray(0,this.length)}}Se.BinaryWriter=Fs;function Xe(s,e,t){const r=t.value;t.value=function(...n){try{return r.apply(this,n)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new Pe("Reached the end of buffer when deserializing")}throw o}}}class We{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new pt.default(e,"le")}readU128(){const e=this.readBuffer(16);return new pt.default(e,"le")}readU256(){const e=this.readBuffer(32);return new pt.default(e,"le")}readU512(){const e=this.readBuffer(64);return new pt.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new Pe(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return oa.decode(t)}catch(r){throw new Pe(`Error decoding UTF-8 string: ${r}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),r=Array();for(let n=0;n<t;++n)r.push(e());return r}}Ze([Xe],We.prototype,"readU8",null);Ze([Xe],We.prototype,"readU16",null);Ze([Xe],We.prototype,"readU32",null);Ze([Xe],We.prototype,"readU64",null);Ze([Xe],We.prototype,"readU128",null);Ze([Xe],We.prototype,"readU256",null);Ze([Xe],We.prototype,"readU512",null);Ze([Xe],We.prototype,"readString",null);Ze([Xe],We.prototype,"readFixedArray",null);Ze([Xe],We.prototype,"readArray",null);Se.BinaryReader=We;function Ds(s){return s.charAt(0).toUpperCase()+s.slice(1)}function wt(s,e,t,r,n){try{if(typeof r=="string")n[`write${Ds(r)}`](t);else if(r instanceof Array)if(typeof r[0]=="number"){if(t.length!==r[0])throw new Pe(`Expecting byte array of length ${r[0]}, but got ${t.length} bytes`);n.writeFixedArray(t)}else if(r.length===2&&typeof r[1]=="number"){if(t.length!==r[1])throw new Pe(`Expecting byte array of length ${r[1]}, but got ${t.length} bytes`);for(let o=0;o<r[1];o++)wt(s,null,t[o],r[0],n)}else n.writeArray(t,o=>{wt(s,e,o,r[0],n)});else if(r.kind!==void 0)switch(r.kind){case"option":{t==null?n.writeU8(0):(n.writeU8(1),wt(s,e,t,r.type,n));break}case"map":{n.writeU32(t.size),t.forEach((o,i)=>{wt(s,e,i,r.key,n),wt(s,e,o,r.value,n)});break}default:throw new Pe(`FieldType ${r} unrecognized`)}else qs(s,t,n)}catch(o){throw o instanceof Pe&&o.addToFieldPath(e),o}}function qs(s,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const r=s.get(e.constructor);if(!r)throw new Pe(`Class ${e.constructor.name} is missing in schema`);if(r.kind==="struct")r.fields.map(([n,o])=>{wt(s,n,e[n],o,t)});else if(r.kind==="enum"){const n=e[r.field];for(let o=0;o<r.values.length;++o){const[i,a]=r.values[o];if(i===n){t.writeU8(o),wt(s,i,e[i],a,t);break}}}else throw new Pe(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)}function ca(s,e,t=Fs){const r=new t;return qs(s,e,r),r.toArray()}var Ms=Se.serialize=ca;function kt(s,e,t,r){try{if(typeof t=="string")return r[`read${Ds(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return r.readFixedArray(t[0]);if(typeof t[1]=="number"){const n=[];for(let o=0;o<t[1];o++)n.push(kt(s,null,t[0],r));return n}else return r.readArray(()=>kt(s,e,t[0],r))}if(t.kind==="option")return r.readU8()?kt(s,e,t.type,r):void 0;if(t.kind==="map"){let n=new Map;const o=r.readU32();for(let i=0;i<o;i++){const a=kt(s,e,t.key,r),c=kt(s,e,t.value,r);n.set(a,c)}return n}return fn(s,t,r)}catch(n){throw n instanceof Pe&&n.addToFieldPath(e),n}}function fn(s,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const r=s.get(e);if(!r)throw new Pe(`Class ${e.name} is missing in schema`);if(r.kind==="struct"){const n={};for(const[o,i]of s.get(e).fields)n[o]=kt(s,o,i,t);return new e(n)}if(r.kind==="enum"){const n=t.readU8();if(n>=r.values.length)throw new Pe(`Enum index: ${n} is out of range`);const[o,i]=r.values[n],a=kt(s,o,i,t);return new e({[o]:a})}throw new Pe(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)}function ua(s,e,t,r=We){const n=new r(t),o=fn(s,e,n);if(n.offset<t.length)throw new Pe(`Unexpected ${t.length-n.offset} bytes after deserialized data`);return o}var $s=Se.deserialize=ua;function la(s,e,t,r=We){const n=new r(t);return fn(s,e,n)}Ks=Se.deserializeUnchecked=la;var f={};Object.defineProperty(f,"__esModule",{value:!0});f.s16=f.s8=f.nu64be=f.u48be=f.u40be=f.u32be=f.u24be=f.u16be=ke=f.nu64=f.u48=f.u40=K=f.u32=f.u24=Fe=f.u16=ee=f.u8=yt=f.offset=f.greedy=f.Constant=f.UTF8=f.CString=f.Blob=f.Boolean=f.BitField=f.BitStructure=f.VariantLayout=f.Union=f.UnionLayoutDiscriminator=f.UnionDiscriminator=f.Structure=f.Sequence=f.DoubleBE=f.Double=f.FloatBE=f.Float=f.NearInt64BE=f.NearInt64=f.NearUInt64BE=f.NearUInt64=f.IntBE=f.Int=f.UIntBE=f.UInt=f.OffsetLayout=f.GreedyCount=f.ExternalLayout=f.bindConstructorLayout=f.nameWithProperty=f.Layout=f.uint8ArrayToBuffer=f.checkUint8Array=void 0;f.constant=f.utf8=f.cstr=ue=f.blob=f.unionLayoutDiscriminator=f.union=Ie=f.seq=f.bits=W=f.struct=f.f64be=f.f64=f.f32be=f.f32=f.ns64be=f.s48be=f.s40be=f.s32be=f.s24be=f.s16be=Ne=f.ns64=f.s48=f.s40=f.s32=f.s24=void 0;const hn=M;function Ft(s){if(!(s instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}f.checkUint8Array=Ft;function re(s){return Ft(s),hn.Buffer.from(s.buffer,s.byteOffset,s.length)}f.uint8ArrayToBuffer=re;class oe{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}f.Layout=oe;function pn(s,e){return e.property?s+"["+e.property+"]":s}f.nameWithProperty=pn;function da(s,e){if(typeof s!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(s,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof oe))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");s.layout_=e,e.boundConstructor_=s,e.makeDestinationObject=()=>new s,Object.defineProperty(s.prototype,"encode",{value(t,r){return e.encode(this,t,r)},writable:!0}),Object.defineProperty(s,"decode",{value(t,r){return e.decode(t,r)},writable:!0})}f.bindConstructorLayout=da;class Ce extends oe{isCount(){throw new Error("ExternalLayout is abstract")}}f.ExternalLayout=Ce;class Hs extends Ce{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Ft(e);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}f.GreedyCount=Hs;class yn extends Ce{constructor(e,t=0,r){if(!(e instanceof oe))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof De||this.layout instanceof Me}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,r=0){return this.layout.encode(e,t,r+this.offset)}}f.OffsetLayout=yn;class De extends oe{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readUIntLE(t,this.span)}encode(e,t,r=0){return re(t).writeUIntLE(e,r,this.span),this.span}}f.UInt=De;class Me extends oe{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readUIntBE(t,this.span)}encode(e,t,r=0){return re(t).writeUIntBE(e,r,this.span),this.span}}f.UIntBE=Me;class At extends oe{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readIntLE(t,this.span)}encode(e,t,r=0){return re(t).writeIntLE(e,r,this.span),this.span}}f.Int=At;class Dt extends oe{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readIntBE(t,this.span)}encode(e,t,r=0){return re(t).writeIntBE(e,r,this.span),this.span}}f.IntBE=Dt;const Jr=Math.pow(2,32);function br(s){const e=Math.floor(s/Jr),t=s-e*Jr;return{hi32:e,lo32:t}}function mr(s,e){return s*Jr+e}class Vs extends oe{constructor(e){super(8,e)}decode(e,t=0){const r=re(e),n=r.readUInt32LE(t),o=r.readUInt32LE(t+4);return mr(o,n)}encode(e,t,r=0){const n=br(e),o=re(t);return o.writeUInt32LE(n.lo32,r),o.writeUInt32LE(n.hi32,r+4),8}}f.NearUInt64=Vs;class js extends oe{constructor(e){super(8,e)}decode(e,t=0){const r=re(e),n=r.readUInt32BE(t),o=r.readUInt32BE(t+4);return mr(n,o)}encode(e,t,r=0){const n=br(e),o=re(t);return o.writeUInt32BE(n.hi32,r),o.writeUInt32BE(n.lo32,r+4),8}}f.NearUInt64BE=js;class Gs extends oe{constructor(e){super(8,e)}decode(e,t=0){const r=re(e),n=r.readUInt32LE(t),o=r.readInt32LE(t+4);return mr(o,n)}encode(e,t,r=0){const n=br(e),o=re(t);return o.writeUInt32LE(n.lo32,r),o.writeInt32LE(n.hi32,r+4),8}}f.NearInt64=Gs;class Ys extends oe{constructor(e){super(8,e)}decode(e,t=0){const r=re(e),n=r.readInt32BE(t),o=r.readUInt32BE(t+4);return mr(n,o)}encode(e,t,r=0){const n=br(e),o=re(t);return o.writeInt32BE(n.hi32,r),o.writeUInt32BE(n.lo32,r+4),8}}f.NearInt64BE=Ys;class Js extends oe{constructor(e){super(4,e)}decode(e,t=0){return re(e).readFloatLE(t)}encode(e,t,r=0){return re(t).writeFloatLE(e,r),4}}f.Float=Js;class Zs extends oe{constructor(e){super(4,e)}decode(e,t=0){return re(e).readFloatBE(t)}encode(e,t,r=0){return re(t).writeFloatBE(e,r),4}}f.FloatBE=Zs;class Xs extends oe{constructor(e){super(8,e)}decode(e,t=0){return re(e).readDoubleLE(t)}encode(e,t,r=0){return re(t).writeDoubleLE(e,r),8}}f.Double=Xs;class Qs extends oe{constructor(e){super(8,e)}decode(e,t=0){return re(e).readDoubleBE(t)}encode(e,t,r=0){return re(t).writeDoubleBE(e,r),8}}f.DoubleBE=Qs;class eo extends oe{constructor(e,t,r){if(!(e instanceof oe))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof Ce&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let n=-1;!(t instanceof Ce)&&0<e.span&&(n=t*e.span),super(n,r),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0,n=this.count;if(n instanceof Ce&&(n=n.decode(e,t)),0<this.elementLayout.span)r=n*this.elementLayout.span;else{let o=0;for(;o<n;)r+=this.elementLayout.getSpan(e,t+r),++o}return r}decode(e,t=0){const r=[];let n=0,o=this.count;for(o instanceof Ce&&(o=o.decode(e,t));n<o;)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),n+=1;return r}encode(e,t,r=0){const n=this.elementLayout,o=e.reduce((i,a)=>i+n.encode(a,t,r+i),0);return this.count instanceof Ce&&this.count.encode(e.length,t,r),o}}f.Sequence=eo;class to extends oe{constructor(e,t,r){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof oe,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&r===void 0&&(r=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let n=-1;try{n=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(n,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;try{r=this.fields.reduce((n,o)=>{const i=o.getSpan(e,t);return t+=i,n+i},0)}catch{throw new RangeError("indeterminate span")}return r}decode(e,t=0){Ft(e);const r=this.makeDestinationObject();for(const n of this.fields)if(n.property!==void 0&&(r[n.property]=n.decode(e,t)),t+=n.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r=0){const n=r;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const l=e[a.property];l!==void 0&&(i=a.encode(l,t,r),0>c&&(c=a.getSpan(t,r)))}o=r,r+=c}return o+i-n}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)r.property!==void 0&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}f.Structure=to;class gn{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,r){throw new Error("UnionDiscriminator is abstract")}}f.UnionDiscriminator=gn;class fr extends gn{constructor(e,t){if(!(e instanceof Ce&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}f.UnionLayoutDiscriminator=fr;class bn extends oe{constructor(e,t,r){let n;if(e instanceof De||e instanceof Me)n=new fr(new yn(e));else if(e instanceof Ce&&e.isCount())n=new fr(e);else if(e instanceof gn)n=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof oe))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof De||e instanceof Me)&&(o+=n.layout.span)),super(o,r),this.discriminator=n,this.usesPrefixDiscriminator=e instanceof De||e instanceof Me,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(r.property&&Object.prototype.hasOwnProperty.call(e,r.property))return r}throw new Error("unable to infer src variant")}decode(e,t=0){let r;const n=this.discriminator,o=n.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=n.layout.span),r=this.makeDestinationObject(),r[n.property]=o,r[a.property]=a.decode(e,t+c)}else r=i.decode(e,t);return r}encode(e,t,r=0){const n=this.getSourceVariant(e);if(n===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,r),a+i.encode(e[i.property],t,r+a)}return n.encode(e,t,r)}addVariant(e,t,r){const n=new ro(this,e,t,r);return this.registry[e]=n,n}getVariant(e,t=0){let r;return e instanceof Uint8Array?r=this.discriminator.decode(e,t):r=e,this.registry[r]}}f.Union=bn;class ro extends oe{constructor(e,t,r,n){if(!(e instanceof bn))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof r=="string"&&n===void 0&&(n=r,r=null),r){if(!(r instanceof oe))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof n!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=r?r.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,n),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span);let n=0;return this.layout&&(n=this.layout.getSpan(e,t+r)),r+n}decode(e,t=0){const r=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+n):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r=0){let n=0;if(this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let o=n;if(this.layout&&(this.layout.encode(e[this.property],t,r+n),o+=this.layout.getSpan(t,r+n),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}f.VariantLayout=ro;function Tt(s){return 0>s&&(s+=4294967296),s}class mn extends oe{constructor(e,t,r){if(!(e instanceof De||e instanceof Me))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&r===void 0&&(r=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let n=0;this._packedSetValue=function(o){return n=Tt(o),this},this._packedGetValue=function(){return n}}decode(e,t=0){const r=this.makeDestinationObject(),n=this.word.decode(e,t);this._packedSetValue(n);for(const o of this.fields)o.property!==void 0&&(r[o.property]=o.decode(e));return r}encode(e,t,r=0){const n=this.word.decode(t,r);this._packedSetValue(n);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new wn(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new no(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}f.BitStructure=mn;class wn{constructor(e,t,r){if(!(e instanceof mn))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const n=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>n)throw new Error("bits too long for span remainder ("+(n-o)+" of "+n+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=n-o-t),this.wordMask=Tt(this.valueMask<<this.start),this.property=r}decode(e,t){const r=this.container._packedGetValue();return Tt(r&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Tt(e&this.valueMask))throw new TypeError(pn("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=Tt(e<<this.start);this.container._packedSetValue(Tt(t&~this.wordMask)|r)}}f.BitField=wn;class no extends wn{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}}f.Boolean=no;class so extends oe{constructor(e,t){if(!(e instanceof Ce&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof Ce||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t=0){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),re(e).slice(t,t+r)}encode(e,t,r){let n=this.length;if(this.length instanceof Ce&&(n=e.length),!(e instanceof Uint8Array&&n===e.length))throw new TypeError(pn("Blob.encode",this)+" requires (length "+n+") Uint8Array as src");if(r+n>t.length)throw new RangeError("encoding overruns Uint8Array");const o=re(e);return re(t).write(o.toString("hex"),r,n,"hex"),this.length instanceof Ce&&this.length.encode(n,t,r),n}}f.Blob=so;class oo extends oe{constructor(e){super(-1,e)}getSpan(e,t=0){Ft(e);let r=t;for(;r<e.length&&e[r]!==0;)r+=1;return 1+r-t}decode(e,t=0){const r=this.getSpan(e,t);return re(e).slice(t,t+r-1).toString("utf-8")}encode(e,t,r=0){typeof e!="string"&&(e=String(e));const n=hn.Buffer.from(e,"utf8"),o=n.length;if(r+o>t.length)throw new RangeError("encoding overruns Buffer");const i=re(t);return n.copy(i,r),i[r+o]=0,o+1}}f.CString=oo;class io extends oe{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Ft(e),e.length-t}decode(e,t=0){const r=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");return re(e).slice(t,t+r).toString("utf-8")}encode(e,t,r=0){typeof e!="string"&&(e=String(e));const n=hn.Buffer.from(e,"utf8"),o=n.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(r+o>t.length)throw new RangeError("encoding overruns Buffer");return n.copy(re(t),r),o}}f.UTF8=io;class ao extends oe{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,r){return 0}}f.Constant=ao;f.greedy=(s,e)=>new Hs(s,e);var yt=f.offset=(s,e,t)=>new yn(s,e,t),ee=f.u8=s=>new De(1,s),Fe=f.u16=s=>new De(2,s);f.u24=s=>new De(3,s);var K=f.u32=s=>new De(4,s);f.u40=s=>new De(5,s);f.u48=s=>new De(6,s);var ke=f.nu64=s=>new Vs(s);f.u16be=s=>new Me(2,s);f.u24be=s=>new Me(3,s);f.u32be=s=>new Me(4,s);f.u40be=s=>new Me(5,s);f.u48be=s=>new Me(6,s);f.nu64be=s=>new js(s);f.s8=s=>new At(1,s);f.s16=s=>new At(2,s);f.s24=s=>new At(3,s);f.s32=s=>new At(4,s);f.s40=s=>new At(5,s);f.s48=s=>new At(6,s);var Ne=f.ns64=s=>new Gs(s);f.s16be=s=>new Dt(2,s);f.s24be=s=>new Dt(3,s);f.s32be=s=>new Dt(4,s);f.s40be=s=>new Dt(5,s);f.s48be=s=>new Dt(6,s);f.ns64be=s=>new Ys(s);f.f32=s=>new Js(s);f.f32be=s=>new Zs(s);f.f64=s=>new Xs(s);f.f64be=s=>new Qs(s);var W=f.struct=(s,e,t)=>new to(s,e,t);f.bits=(s,e,t)=>new mn(s,e,t);var Ie=f.seq=(s,e,t)=>new eo(s,e,t);f.union=(s,e,t)=>new bn(s,e,t);f.unionLayoutDiscriminator=(s,e)=>new fr(s,e);var ue=f.blob=(s,e)=>new so(s,e);f.cstr=s=>new oo(s);f.utf8=(s,e)=>new io(s,e);f.constant=(s,e)=>new ao(s,e);var Zt={};Object.defineProperty(Zt,"__esModule",{value:!0});function fa(s){{const e=Buffer.from(s);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var ha=Zt.toBigIntLE=fa;function pa(s){{const e=s.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}Zt.toBigIntBE=pa;function ya(s,e){{const t=s.toString(16),r=Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return r.reverse(),r}}var co=Zt.toBufferLE=ya;function ga(s,e){{const t=s.toString(16);return Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}Zt.toBufferBE=ga;class ba extends TypeError{constructor(e,t){let r;const{message:n,...o}=e,{path:i}=e,a=i.length===0?n:"At path: "+i.join(".")+" -- "+n;super(a),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var c;return(c=r)!=null?c:r=[e,...t()]}}}function ma(s){return gt(s)&&typeof s[Symbol.iterator]=="function"}function gt(s){return typeof s=="object"&&s!=null}function $e(s){return typeof s=="string"?JSON.stringify(s):""+s}function wa(s){const{done:e,value:t}=s.next();return e?void 0:t}function ka(s,e,t,r){if(s===!0)return;s===!1?s={}:typeof s=="string"&&(s={message:s});const{path:n,branch:o}=e,{type:i}=t,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+$e(r)+"`"}=s;return{value:r,type:i,refinement:a,key:n[n.length-1],path:n,branch:o,...s,message:c}}function*ns(s,e,t,r){ma(s)||(s=[s]);for(const n of s){const o=ka(n,e,t,r);o&&(yield o)}}function*kn(s,e,t={}){const{path:r=[],branch:n=[s],coerce:o=!1,mask:i=!1}=t,a={path:r,branch:n};if(o&&(s=e.coercer(s,a),i&&e.type!=="type"&&gt(e.schema)&&gt(s)&&!Array.isArray(s)))for(const l in s)e.schema[l]===void 0&&delete s[l];let c=!0;for(const l of e.validator(s,a))c=!1,yield[l,void 0];for(let[l,u,y]of e.entries(s,a)){const m=kn(u,y,{path:l===void 0?r:[...r,l],branch:l===void 0?n:[...n,u],coerce:o,mask:i});for(const g of m)g[0]?(c=!1,yield[g[0],void 0]):o&&(u=g[1],l===void 0?s=u:s instanceof Map?s.set(l,u):s instanceof Set?s.add(u):gt(s)&&(s[l]=u))}if(c)for(const l of e.refiner(s,a))c=!1,yield[l,void 0];c&&(yield[void 0,s])}class Qe{constructor(e){const{type:t,schema:r,validator:n,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=i,n?this.validator=(c,l)=>{const u=n(c,l);return ns(u,l,this,c)}:this.validator=()=>[],o?this.refiner=(c,l)=>{const u=o(c,l);return ns(u,l,this,c)}:this.refiner=()=>[]}assert(e){return uo(e,this)}create(e){return R(e,this)}is(e){return lo(e,this)}mask(e){return Sa(e,this)}validate(e,t={}){return Xt(e,this,t)}}function uo(s,e){const t=Xt(s,e);if(t[0])throw t[0]}function R(s,e){const t=Xt(s,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function Sa(s,e){const t=Xt(s,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function lo(s,e){return!Xt(s,e)[0]}function Xt(s,e,t={}){const r=kn(s,e,t),n=wa(r);return n[0]?[new ba(n[0],function*(){for(const i of r)i[0]&&(yield i[0])}),void 0]:[void 0,n[1]]}function Et(s,e){return new Qe({type:s,schema:null,validator:e})}function Ia(){return Et("any",()=>!0)}function O(s){return new Qe({type:"array",schema:s,*entries(e){if(s&&Array.isArray(e))for(const[t,r]of e.entries())yield[t,r,s]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+$e(e)}})}function Je(){return Et("boolean",s=>typeof s=="boolean")}function Sn(s){return Et("instance",e=>e instanceof s||"Expected a `"+s.name+"` instance, but received: "+$e(e))}function he(s){const e=$e(s),t=typeof s;return new Qe({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?s:null,validator(r){return r===s||"Expected the literal `"+e+"`, but received: "+$e(r)}})}function _a(){return Et("never",()=>!1)}function L(s){return new Qe({...s,validator:(e,t)=>e===null||s.validator(e,t),refiner:(e,t)=>e===null||s.refiner(e,t)})}function d(){return Et("number",s=>typeof s=="number"&&!isNaN(s)||"Expected a number, but received: "+$e(s))}function $(s){return new Qe({...s,validator:(e,t)=>e===void 0||s.validator(e,t),refiner:(e,t)=>e===void 0||s.refiner(e,t)})}function fo(s,e){return new Qe({type:"record",schema:null,*entries(t){if(gt(t))for(const r in t){const n=t[r];yield[r,r,s],yield[r,n,e]}},validator(t){return gt(t)||"Expected an object, but received: "+$e(t)}})}function E(){return Et("string",s=>typeof s=="string"||"Expected a string, but received: "+$e(s))}function In(s){const e=_a();return new Qe({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const r=Math.max(s.length,t.length);for(let n=0;n<r;n++)yield[n,t[n],s[n]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+$e(t)}})}function I(s){const e=Object.keys(s);return new Qe({type:"type",schema:s,*entries(t){if(gt(t))for(const r of e)yield[r,t[r],s[r]]},validator(t){return gt(t)||"Expected an object, but received: "+$e(t)}})}function Oe(s){const e=s.map(t=>t.type).join(" | ");return new Qe({type:"union",schema:null,validator(t,r){const n=[];for(const o of s){const[...i]=kn(t,o,r),[a]=i;if(a[0])for(const[c]of i)c&&n.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+$e(t),...n]}})}function Qt(){return Et("unknown",()=>!0)}function er(s,e,t){return new Qe({...s,coercer:(r,n)=>lo(r,e)?s.coercer(t(r,n),n):s.coercer(r,n)})}const ho=Jt(Ci),va=ho.v4,Aa=function(s,e,t,r){if(typeof s!="string")throw new TypeError(s+" must be a string");r=r||{};const n=typeof r.version=="number"?r.version:2;if(n!==1&&n!==2)throw new TypeError(n+" must be 1 or 2");const o={method:s};if(n===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof r.generator=="function"?r.generator:function(){return va()};o.id=i(o,r)}else n===2&&t===null?r.notificationIdNull&&(o.id=null):o.id=t;return o};var Ea=Aa;const xa=ho.v4,Ra=Ea,jt=function(s,e){if(!(this instanceof jt))return new jt(s,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return xa()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=s};var Ba=jt;jt.prototype.request=function(s,e,t,r){const n=this;let o=null;const i=Array.isArray(s)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&s&&typeof s=="object"&&typeof e=="function")r=e,o=s;else{typeof t=="function"&&(r=t,t=void 0);const l=typeof r=="function";try{o=Ra(s,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(u){if(l)return r(u);throw u}if(!l)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(l){return r(l)}return this.callServer(c,function(l,u){n._parseResponse(l,u,r)}),o};jt.prototype._parseResponse=function(s,e,t){if(s){t(s);return}if(!e)return t();let r;try{r=JSON.parse(e,this.options.reviver)}catch(n){return t(n)}if(t.length===3)if(Array.isArray(r)){const n=function(i){return typeof i.error<"u"},o=function(i){return!n(i)};return t(null,r.filter(n),r.filter(o))}else return t(null,r.error,r.result);t(null,r)};var po={},wr={exports:{}};(function(s){function e(t){return t&&t.__esModule?t:{default:t}}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports})(wr);var zr={exports:{}},Nr={exports:{}},ss;function yo(){return ss||(ss=1,function(s){function e(t){return s.exports=e=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(r){return typeof r}:function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},s.exports.__esModule=!0,s.exports.default=s.exports,e(t)}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports}(Nr)),Nr.exports}var os;function Pa(){return os||(os=1,function(s){var e=yo().default;function t(){s.exports=t=function(){return n},s.exports.__esModule=!0,s.exports.default=s.exports;var r,n={},o=Object.prototype,i=o.hasOwnProperty,a=Object.defineProperty||function(h,p,b){h[p]=b.value},c=typeof Symbol=="function"?Symbol:{},l=c.iterator||"@@iterator",u=c.asyncIterator||"@@asyncIterator",y=c.toStringTag||"@@toStringTag";function m(h,p,b){return Object.defineProperty(h,p,{value:b,enumerable:!0,configurable:!0,writable:!0}),h[p]}try{m({},"")}catch{m=function(b,P,C){return b[P]=C}}function g(h,p,b,P){var C=p&&p.prototype instanceof v?p:v,T=Object.create(C.prototype),V=new Bt(P||[]);return a(T,"_invoke",{value:Be(h,b,V)}),T}function S(h,p,b){try{return{type:"normal",arg:h.call(p,b)}}catch(P){return{type:"throw",arg:P}}}n.wrap=g;var w="suspendedStart",k="suspendedYield",B="executing",U="completed",_={};function v(){}function N(){}function A(){}var H={};m(H,l,function(){return this});var z=Object.getPrototypeOf,q=z&&z(z(D([])));q&&q!==o&&i.call(q,l)&&(H=q);var ie=A.prototype=v.prototype=Object.create(H);function ye(h){["next","throw","return"].forEach(function(p){m(h,p,function(b){return this._invoke(p,b)})})}function Re(h,p){function b(C,T,V,j){var Z=S(h[C],h,T);if(Z.type!=="throw"){var le=Z.arg,fe=le.value;return fe&&e(fe)=="object"&&i.call(fe,"__await")?p.resolve(fe.__await).then(function(be){b("next",be,V,j)},function(be){b("throw",be,V,j)}):p.resolve(fe).then(function(be){le.value=be,V(le)},function(be){return b("throw",be,V,j)})}j(Z.arg)}var P;a(this,"_invoke",{value:function(T,V){function j(){return new p(function(Z,le){b(T,V,Z,le)})}return P=P?P.then(j,j):j()}})}function Be(h,p,b){var P=w;return function(C,T){if(P===B)throw new Error("Generator is already running");if(P===U){if(C==="throw")throw T;return{value:r,done:!0}}for(b.method=C,b.arg=T;;){var V=b.delegate;if(V){var j=ct(V,b);if(j){if(j===_)continue;return j}}if(b.method==="next")b.sent=b._sent=b.arg;else if(b.method==="throw"){if(P===w)throw P=U,b.arg;b.dispatchException(b.arg)}else b.method==="return"&&b.abrupt("return",b.arg);P=B;var Z=S(h,p,b);if(Z.type==="normal"){if(P=b.done?U:k,Z.arg===_)continue;return{value:Z.arg,done:b.done}}Z.type==="throw"&&(P=U,b.method="throw",b.arg=Z.arg)}}}function ct(h,p){var b=p.method,P=h.iterator[b];if(P===r)return p.delegate=null,b==="throw"&&h.iterator.return&&(p.method="return",p.arg=r,ct(h,p),p.method==="throw")||b!=="return"&&(p.method="throw",p.arg=new TypeError("The iterator does not provide a '"+b+"' method")),_;var C=S(P,h.iterator,p.arg);if(C.type==="throw")return p.method="throw",p.arg=C.arg,p.delegate=null,_;var T=C.arg;return T?T.done?(p[h.resultName]=T.value,p.next=h.nextLoc,p.method!=="return"&&(p.method="next",p.arg=r),p.delegate=null,_):T:(p.method="throw",p.arg=new TypeError("iterator result is not an object"),p.delegate=null,_)}function et(h){var p={tryLoc:h[0]};1 in h&&(p.catchLoc=h[1]),2 in h&&(p.finallyLoc=h[2],p.afterLoc=h[3]),this.tryEntries.push(p)}function mt(h){var p=h.completion||{};p.type="normal",delete p.arg,h.completion=p}function Bt(h){this.tryEntries=[{tryLoc:"root"}],h.forEach(et,this),this.reset(!0)}function D(h){if(h||h===""){var p=h[l];if(p)return p.call(h);if(typeof h.next=="function")return h;if(!isNaN(h.length)){var b=-1,P=function C(){for(;++b<h.length;)if(i.call(h,b))return C.value=h[b],C.done=!1,C;return C.value=r,C.done=!0,C};return P.next=P}}throw new TypeError(e(h)+" is not iterable")}return N.prototype=A,a(ie,"constructor",{value:A,configurable:!0}),a(A,"constructor",{value:N,configurable:!0}),N.displayName=m(A,y,"GeneratorFunction"),n.isGeneratorFunction=function(h){var p=typeof h=="function"&&h.constructor;return!!p&&(p===N||(p.displayName||p.name)==="GeneratorFunction")},n.mark=function(h){return Object.setPrototypeOf?Object.setPrototypeOf(h,A):(h.__proto__=A,m(h,y,"GeneratorFunction")),h.prototype=Object.create(ie),h},n.awrap=function(h){return{__await:h}},ye(Re.prototype),m(Re.prototype,u,function(){return this}),n.AsyncIterator=Re,n.async=function(h,p,b,P,C){C===void 0&&(C=Promise);var T=new Re(g(h,p,b,P),C);return n.isGeneratorFunction(p)?T:T.next().then(function(V){return V.done?V.value:T.next()})},ye(ie),m(ie,y,"Generator"),m(ie,l,function(){return this}),m(ie,"toString",function(){return"[object Generator]"}),n.keys=function(h){var p=Object(h),b=[];for(var P in p)b.push(P);return b.reverse(),function C(){for(;b.length;){var T=b.pop();if(T in p)return C.value=T,C.done=!1,C}return C.done=!0,C}},n.values=D,Bt.prototype={constructor:Bt,reset:function(p){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method="next",this.arg=r,this.tryEntries.forEach(mt),!p)for(var b in this)b.charAt(0)==="t"&&i.call(this,b)&&!isNaN(+b.slice(1))&&(this[b]=r)},stop:function(){this.done=!0;var p=this.tryEntries[0].completion;if(p.type==="throw")throw p.arg;return this.rval},dispatchException:function(p){if(this.done)throw p;var b=this;function P(le,fe){return V.type="throw",V.arg=p,b.next=le,fe&&(b.method="next",b.arg=r),!!fe}for(var C=this.tryEntries.length-1;C>=0;--C){var T=this.tryEntries[C],V=T.completion;if(T.tryLoc==="root")return P("end");if(T.tryLoc<=this.prev){var j=i.call(T,"catchLoc"),Z=i.call(T,"finallyLoc");if(j&&Z){if(this.prev<T.catchLoc)return P(T.catchLoc,!0);if(this.prev<T.finallyLoc)return P(T.finallyLoc)}else if(j){if(this.prev<T.catchLoc)return P(T.catchLoc,!0)}else{if(!Z)throw new Error("try statement without catch or finally");if(this.prev<T.finallyLoc)return P(T.finallyLoc)}}}},abrupt:function(p,b){for(var P=this.tryEntries.length-1;P>=0;--P){var C=this.tryEntries[P];if(C.tryLoc<=this.prev&&i.call(C,"finallyLoc")&&this.prev<C.finallyLoc){var T=C;break}}T&&(p==="break"||p==="continue")&&T.tryLoc<=b&&b<=T.finallyLoc&&(T=null);var V=T?T.completion:{};return V.type=p,V.arg=b,T?(this.method="next",this.next=T.finallyLoc,_):this.complete(V)},complete:function(p,b){if(p.type==="throw")throw p.arg;return p.type==="break"||p.type==="continue"?this.next=p.arg:p.type==="return"?(this.rval=this.arg=p.arg,this.method="return",this.next="end"):p.type==="normal"&&b&&(this.next=b),_},finish:function(p){for(var b=this.tryEntries.length-1;b>=0;--b){var P=this.tryEntries[b];if(P.finallyLoc===p)return this.complete(P.completion,P.afterLoc),mt(P),_}},catch:function(p){for(var b=this.tryEntries.length-1;b>=0;--b){var P=this.tryEntries[b];if(P.tryLoc===p){var C=P.completion;if(C.type==="throw"){var T=C.arg;mt(P)}return T}}throw new Error("illegal catch attempt")},delegateYield:function(p,b,P){return this.delegate={iterator:D(p),resultName:b,nextLoc:P},this.method==="next"&&(this.arg=r),_}},n}s.exports=t,s.exports.__esModule=!0,s.exports.default=s.exports}(zr)),zr.exports}var Ur,is;function Ta(){if(is)return Ur;is=1;var s=Pa()();Ur=s;try{regeneratorRuntime=s}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=s:Function("r","regeneratorRuntime = r")(s)}return Ur}var Kr={exports:{}},as;function La(){return as||(as=1,function(s){function e(r,n,o,i,a,c,l){try{var u=r[c](l),y=u.value}catch(m){o(m);return}u.done?n(y):Promise.resolve(y).then(i,a)}function t(r){return function(){var n=this,o=arguments;return new Promise(function(i,a){var c=r.apply(n,o);function l(y){e(c,i,a,l,u,"next",y)}function u(y){e(c,i,a,l,u,"throw",y)}l(void 0)})}}s.exports=t,s.exports.__esModule=!0,s.exports.default=s.exports}(Kr)),Kr.exports}const Ca=Jt(hi),_n=Jt(pi),vn=Jt(yi);var Wr={exports:{}},Fr={exports:{}},cs;function Oa(){return cs||(cs=1,function(s){function e(t,r){return s.exports=e=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(o,i){return o.__proto__=i,o},s.exports.__esModule=!0,s.exports.default=s.exports,e(t,r)}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports}(Fr)),Fr.exports}var us;function go(){return us||(us=1,function(s){var e=Oa();function t(r,n){if(typeof n!="function"&&n!==null)throw new TypeError("Super expression must either be null or a function");r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,writable:!0,configurable:!0}}),Object.defineProperty(r,"prototype",{writable:!1}),n&&e(r,n)}s.exports=t,s.exports.__esModule=!0,s.exports.default=s.exports}(Wr)),Wr.exports}var Dr={exports:{}},qr={exports:{}},ls;function za(){return ls||(ls=1,function(s){function e(t){if(t===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports}(qr)),qr.exports}var ds;function bo(){return ds||(ds=1,function(s){var e=yo().default,t=za();function r(n,o){if(o&&(e(o)==="object"||typeof o=="function"))return o;if(o!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return t(n)}s.exports=r,s.exports.__esModule=!0,s.exports.default=s.exports}(Dr)),Dr.exports}var Mr={exports:{}},fs;function mo(){return fs||(fs=1,function(s){function e(t){return s.exports=e=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},s.exports.__esModule=!0,s.exports.default=s.exports,e(t)}s.exports=e,s.exports.__esModule=!0,s.exports.default=s.exports}(Mr)),Mr.exports}var Pt={},hs;function Na(){if(hs)return Pt;hs=1;var s=wr.exports;Object.defineProperty(Pt,"__esModule",{value:!0}),Pt.DefaultDataPack=void 0,Pt.createError=o;var e=s(_n),t=s(vn),r=new Map([[-32e3,"Event not provided"],[-32600,"Invalid Request"],[-32601,"Method not found"],[-32602,"Invalid params"],[-32603,"Internal error"],[-32604,"Params not found"],[-32605,"Method forbidden"],[-32606,"Event forbidden"],[-32700,"Parse error"]]),n=function(){function i(){(0,e.default)(this,i)}return(0,t.default)(i,[{key:"encode",value:function(c){return JSON.stringify(c)}},{key:"decode",value:function(c){return JSON.parse(c)}}]),i}();Pt.DefaultDataPack=n;function o(i,a){var c={code:i,message:r.get(i)||"Internal Server Error"};return a&&(c.data=a),c}return Pt}(function(s){var e=wr.exports;Object.defineProperty(s,"__esModule",{value:!0}),s.default=void 0;var t=e(Ta()),r=e(La()),n=e(Ca),o=e(_n),i=e(vn),a=e(go()),c=e(bo()),l=e(mo()),u=Ps.exports,y=Na();function m(k){var B=g();return function(){var _=(0,l.default)(k),v;if(B){var N=(0,l.default)(this).constructor;v=Reflect.construct(_,arguments,N)}else v=_.apply(this,arguments);return(0,c.default)(this,v)}}function g(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var S=function(k,B){var U={};for(var _ in k)Object.prototype.hasOwnProperty.call(k,_)&&B.indexOf(_)<0&&(U[_]=k[_]);if(k!=null&&typeof Object.getOwnPropertySymbols=="function")for(var v=0,_=Object.getOwnPropertySymbols(k);v<_.length;v++)B.indexOf(_[v])<0&&Object.prototype.propertyIsEnumerable.call(k,_[v])&&(U[_[v]]=k[_[v]]);return U},w=function(k){(0,a.default)(U,k);var B=m(U);function U(_){var v,N=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",A=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},H=arguments.length>3?arguments[3]:void 0,z=arguments.length>4?arguments[4]:void 0;(0,o.default)(this,U);var q=A.autoconnect,ie=q===void 0?!0:q,ye=A.reconnect,Re=ye===void 0?!0:ye,Be=A.reconnect_interval,ct=Be===void 0?1e3:Be,et=A.max_reconnects,mt=et===void 0?5:et,Bt=S(A,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return v=B.call(this),v.webSocketFactory=_,v.queue={},v.rpc_id=0,v.address=N,v.autoconnect=ie,v.ready=!1,v.reconnect=Re,v.reconnect_timer_id=void 0,v.reconnect_interval=ct,v.max_reconnects=mt,v.rest_options=Bt,v.current_reconnects=0,v.generate_request_id=H||function(){return++v.rpc_id},z?v.dataPack=z:v.dataPack=new y.DefaultDataPack,v.autoconnect&&v._connect(v.address,Object.assign({autoconnect:v.autoconnect,reconnect:v.reconnect,reconnect_interval:v.reconnect_interval,max_reconnects:v.max_reconnects},v.rest_options)),v}return(0,i.default)(U,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(v,N,A,H){var z=this;return!H&&(0,n.default)(A)==="object"&&(H=A,A=null),new Promise(function(q,ie){if(!z.ready)return ie(new Error("socket not ready"));var ye=z.generate_request_id(v,N),Re={jsonrpc:"2.0",method:v,params:N||void 0,id:ye};z.socket.send(z.dataPack.encode(Re),H,function(Be){if(Be)return ie(Be);z.queue[ye]={promise:[q,ie]},A&&(z.queue[ye].timeout=setTimeout(function(){delete z.queue[ye],ie(new Error("reply timeout"))},A))})})}},{key:"login",value:function(){var _=(0,r.default)(t.default.mark(function N(A){var H;return t.default.wrap(function(q){for(;;)switch(q.prev=q.next){case 0:return q.next=2,this.call("rpc.login",A);case 2:if(H=q.sent,H){q.next=5;break}throw new Error("authentication failed");case 5:return q.abrupt("return",H);case 6:case"end":return q.stop()}},N,this)}));function v(N){return _.apply(this,arguments)}return v}()},{key:"listMethods",value:function(){var _=(0,r.default)(t.default.mark(function N(){return t.default.wrap(function(H){for(;;)switch(H.prev=H.next){case 0:return H.next=2,this.call("__listMethods");case 2:return H.abrupt("return",H.sent);case 3:case"end":return H.stop()}},N,this)}));function v(){return _.apply(this,arguments)}return v}()},{key:"notify",value:function(v,N){var A=this;return new Promise(function(H,z){if(!A.ready)return z(new Error("socket not ready"));var q={jsonrpc:"2.0",method:v,params:N};A.socket.send(A.dataPack.encode(q),function(ie){if(ie)return z(ie);H()})})}},{key:"subscribe",value:function(){var _=(0,r.default)(t.default.mark(function N(A){var H;return t.default.wrap(function(q){for(;;)switch(q.prev=q.next){case 0:return typeof A=="string"&&(A=[A]),q.next=3,this.call("rpc.on",A);case 3:if(H=q.sent,!(typeof A=="string"&&H[A]!=="ok")){q.next=6;break}throw new Error("Failed subscribing to an event '"+A+"' with: "+H[A]);case 6:return q.abrupt("return",H);case 7:case"end":return q.stop()}},N,this)}));function v(N){return _.apply(this,arguments)}return v}()},{key:"unsubscribe",value:function(){var _=(0,r.default)(t.default.mark(function N(A){var H;return t.default.wrap(function(q){for(;;)switch(q.prev=q.next){case 0:return typeof A=="string"&&(A=[A]),q.next=3,this.call("rpc.off",A);case 3:if(H=q.sent,!(typeof A=="string"&&H[A]!=="ok")){q.next=6;break}throw new Error("Failed unsubscribing from an event with: "+H);case 6:return q.abrupt("return",H);case 7:case"end":return q.stop()}},N,this)}));function v(N){return _.apply(this,arguments)}return v}()},{key:"close",value:function(v,N){this.socket.close(v||1e3,N)}},{key:"_connect",value:function(v,N){var A=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(v,N),this.socket.addEventListener("open",function(){A.ready=!0,A.emit("open"),A.current_reconnects=0}),this.socket.addEventListener("message",function(H){var z=H.data;z instanceof ArrayBuffer&&(z=Buffer.from(z).toString());try{z=A.dataPack.decode(z)}catch{return}if(z.notification&&A.listeners(z.notification).length){if(!Object.keys(z.params).length)return A.emit(z.notification);var q=[z.notification];if(z.params.constructor===Object)q.push(z.params);else for(var ie=0;ie<z.params.length;ie++)q.push(z.params[ie]);return Promise.resolve().then(function(){A.emit.apply(A,q)})}if(!A.queue[z.id])return z.method?Promise.resolve().then(function(){A.emit(z.method,z?.params)}):void 0;"error"in z=="result"in z&&A.queue[z.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),A.queue[z.id].timeout&&clearTimeout(A.queue[z.id].timeout),z.error?A.queue[z.id].promise[1](z.error):A.queue[z.id].promise[0](z.result),delete A.queue[z.id]}),this.socket.addEventListener("error",function(H){return A.emit("error",H)}),this.socket.addEventListener("close",function(H){var z=H.code,q=H.reason;A.ready&&setTimeout(function(){return A.emit("close",z,q)},0),A.ready=!1,A.socket=void 0,z!==1e3&&(A.current_reconnects++,A.reconnect&&(A.max_reconnects>A.current_reconnects||A.max_reconnects===0)&&(A.reconnect_timer_id=setTimeout(function(){return A._connect(v,N)},A.reconnect_interval)))})}}]),U}(u.EventEmitter);s.default=w})(po);const Ua=Ts(po);var wo={};(function(s){var e=wr.exports;Object.defineProperty(s,"__esModule",{value:!0}),s.default=y;var t=e(_n),r=e(vn),n=e(go()),o=e(bo()),i=e(mo()),a=Ps.exports;function c(m){var g=l();return function(){var w=(0,i.default)(m),k;if(g){var B=(0,i.default)(this).constructor;k=Reflect.construct(w,arguments,B)}else k=w.apply(this,arguments);return(0,o.default)(this,k)}}function l(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var u=function(m){(0,n.default)(S,m);var g=c(S);function S(w,k,B){var U;return(0,t.default)(this,S),U=g.call(this),U.socket=new window.WebSocket(w,B),U.socket.onopen=function(){return U.emit("open")},U.socket.onmessage=function(_){return U.emit("message",_.data)},U.socket.onerror=function(_){return U.emit("error",_)},U.socket.onclose=function(_){U.emit("close",_.code,_.reason)},U}return(0,r.default)(S,[{key:"send",value:function(k,B,U){var _=U||B;try{this.socket.send(k),_()}catch(v){_(v)}}},{key:"close",value:function(k,B){this.socket.close(k,B)}},{key:"addEventListener",value:function(k,B,U){this.socket.addEventListener(k,B,U)}}]),S}(a.EventEmitter);function y(m,g){return new u(m,g)}})(wo);const Ka=Ts(wo),Wa=Wt.utils.randomPrivateKey,ps=()=>{const s=Wt.utils.randomPrivateKey(),e=hr(s),t=new Uint8Array(64);return t.set(s),t.set(e,32),{publicKey:e,secretKey:t}},hr=Wt.getPublicKey;function ys(s){try{return Wt.ExtendedPoint.fromHex(s),!0}catch{return!1}}const An=(s,e)=>Wt.sign(s,e.slice(0,32)),Fa=Wt.verify,J=s=>M.Buffer.isBuffer(s)?s:s instanceof Uint8Array?M.Buffer.from(s.buffer,s.byteOffset,s.byteLength):M.Buffer.from(s);class En{constructor(e){Object.assign(this,e)}encode(){return M.Buffer.from(Ms(Vt,this))}static decode(e){return $s(Vt,this,e)}static decodeUnchecked(e){return Ks(Vt,this,e)}}class Da extends En{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}}const Vt=new Map;var ko;let So;const Io=32,Ke=32;function qa(s){return s._bn!==void 0}let gs=1;So=Symbol.toStringTag;class x extends En{constructor(e){if(super({}),this._bn=void 0,qa(e))this._bn=e._bn;else{if(typeof e=="string"){const t=we.decode(e);if(t.length!=Ke)throw new Error("Invalid public key input");this._bn=new Jn(t)}else this._bn=new Jn(e);if(this._bn.byteLength()>Ke)throw new Error("Invalid public key input")}}static unique(){const e=new x(gs);return gs+=1,new x(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return we.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(M.Buffer);if(e.length===Ke)return e;const t=M.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[So](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const n=M.Buffer.concat([e.toBuffer(),M.Buffer.from(t),r.toBuffer()]),o=Zn(n);return new x(o)}static createProgramAddressSync(e,t){let r=M.Buffer.alloc(0);e.forEach(function(o){if(o.length>Io)throw new TypeError("Max seed length exceeded");r=M.Buffer.concat([r,J(o)])}),r=M.Buffer.concat([r,t.toBuffer(),M.Buffer.from("ProgramDerivedAddress")]);const n=Zn(r);if(ys(n))throw new Error("Invalid seeds, address must fall off the curve");return new x(n)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r=255,n;for(;r!=0;){try{const o=e.concat(M.Buffer.from([r]));n=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;r--;continue}return[n,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new x(e);return ys(t.toBytes())}}ko=x;x.default=new ko("11111111111111111111111111111111");Vt.set(x,{kind:"struct",fields:[["_bn","u256"]]});class Ma{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=J(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=J(Wa()),this._publicKey=J(hr(this._secretKey))}get publicKey(){return new x(this._publicKey)}get secretKey(){return M.Buffer.concat([this._secretKey,this._publicKey],64)}}const $a=new x("BPFLoader1111111111111111111111111111111111"),bt=1280-40-8,kr=127,Nt=64;class xn extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(xn.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Rn extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Rn.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Lt extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Lt.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Gt{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((o,i)=>{r.set(o.toBase58(),i)});const n=o=>{const i=r.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:n(o.programId),accountKeyIndexes:o.keys.map(i=>n(i.pubkey)),data:o.data}))}}const X=(s="publicKey")=>ue(32,s),Ha=(s="signature")=>ue(64,s),It=(s="string")=>{const e=W([K("length"),K("lengthPadding"),ue(yt(K(),-8),"chars")],s),t=e.decode.bind(e),r=e.encode.bind(e),n=e;return n.decode=(o,i)=>t(o,i).chars.toString(),n.encode=(o,i,a)=>{const c={chars:M.Buffer.from(o,"utf8")};return r(c,i,a)},n.alloc=o=>K().span+K().span+M.Buffer.from(o,"utf8").length,n},Va=(s="authorized")=>W([X("staker"),X("withdrawer")],s),ja=(s="lockup")=>W([Ne("unixTimestamp"),Ne("epoch"),X("custodian")],s),Ga=(s="voteInit")=>W([X("nodePubkey"),X("authorizedVoter"),X("authorizedWithdrawer"),ee("commission")],s),Ya=(s="voteAuthorizeWithSeedArgs")=>W([K("voteAuthorizationType"),X("currentAuthorityDerivedKeyOwnerPubkey"),It("currentAuthorityDerivedKeySeed"),X("newAuthorized")],s);function _o(s,e){const t=n=>{if(n.span>=0)return n.span;if(typeof n.alloc=="function")return n.alloc(e[n.property]);if("count"in n&&"elementLayout"in n){const o=e[n.property];if(Array.isArray(o))return o.length*t(n.elementLayout)}else if("fields"in n)return _o({layout:n},e[n.property]);return 0};let r=0;return s.layout.fields.forEach(n=>{r+=t(n)}),r}function Le(s){let e=0,t=0;for(;;){let r=s.shift();if(e|=(r&127)<<t*7,t+=1,(r&128)===0)break}return e}function Ue(s,e){let t=e;for(;;){let r=t&127;if(t>>=7,t==0){s.push(r);break}else r|=128,s.push(r)}}function te(s,e){if(!s)throw new Error(e||"Assertion failed")}class Sr{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,n=i=>{const a=i.toBase58();let c=r.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(a,c)),c},o=n(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){n(i.programId).isInvoked=!0;for(const a of i.keys){const c=n(a.pubkey);c.isSigner||=a.isSigner,c.isWritable||=a.isWritable}}return new Sr(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];te(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),r=e.filter(([,c])=>c.isSigner&&!c.isWritable),n=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{te(t.length>0,"Expected at least one writable signer key");const[c]=t[0];te(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new x(c)),...r.map(([c])=>new x(c)),...n.map(([c])=>new x(c)),...o.map(([c])=>new x(c))];return[i,a]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[n,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&n.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new x(o),c=e.findIndex(l=>l.equals(a));c>=0&&(te(c<256,"Max lookup table index exceeded"),r.push(c),n.push(a),this.keyMetaMap.delete(o))}return[r,n]}}class He{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new x(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:we.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Gt(this.staticAccountKeys)}static compile(e){const t=Sr.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),i=new Gt(n).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:we.encode(a.data)}));return new He({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Ue(t,e);const r=this.instructions.map(y=>{const{accounts:m,programIdIndex:g}=y,S=Array.from(we.decode(y.data));let w=[];Ue(w,m.length);let k=[];return Ue(k,S.length),{programIdIndex:g,keyIndicesCount:M.Buffer.from(w),keyIndices:m,dataLength:M.Buffer.from(k),data:S}});let n=[];Ue(n,r.length);let o=M.Buffer.alloc(bt);M.Buffer.from(n).copy(o);let i=n.length;r.forEach(y=>{const g=W([ee("programIdIndex"),ue(y.keyIndicesCount.length,"keyIndicesCount"),Ie(ee("keyIndex"),y.keyIndices.length,"keyIndices"),ue(y.dataLength.length,"dataLength"),Ie(ee("userdatum"),y.data.length,"data")]).encode(y,o,i);i+=g}),o=o.slice(0,i);const a=W([ue(1,"numRequiredSignatures"),ue(1,"numReadonlySignedAccounts"),ue(1,"numReadonlyUnsignedAccounts"),ue(t.length,"keyCount"),Ie(X("key"),e,"keys"),X("recentBlockhash")]),c={numRequiredSignatures:M.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:M.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:M.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:M.Buffer.from(t),keys:this.accountKeys.map(y=>J(y.toBytes())),recentBlockhash:we.decode(this.recentBlockhash)};let l=M.Buffer.alloc(2048);const u=a.encode(c,l);return o.copy(l,u),l.slice(0,u+o.length)}static from(e){let t=[...e];const r=t.shift();if(r!==(r&kr))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const n=t.shift(),o=t.shift(),i=Le(t);let a=[];for(let m=0;m<i;m++){const g=t.slice(0,Ke);t=t.slice(Ke),a.push(new x(M.Buffer.from(g)))}const c=t.slice(0,Ke);t=t.slice(Ke);const l=Le(t);let u=[];for(let m=0;m<l;m++){const g=t.shift(),S=Le(t),w=t.slice(0,S);t=t.slice(S);const k=Le(t),B=t.slice(0,k),U=we.encode(M.Buffer.from(B));t=t.slice(k),u.push({programIdIndex:g,accounts:w,data:U})}const y={header:{numRequiredSignatures:r,numReadonlySignedAccounts:n,numReadonlyUnsignedAccounts:o},recentBlockhash:we.encode(M.Buffer.from(c)),accountKeys:a,instructions:u};return new He(y)}}class _t{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Gt(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const n=e-r,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return n<o}else if(e>=this.header.numRequiredSignatures){const n=e-t,i=r-t-this.header.numReadonlyUnsignedAccounts;return n<i}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find(o=>o.key.equals(r.accountKey));if(!n)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const o of r.writableIndexes)if(o<n.state.addresses.length)t.writable.push(n.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);for(const o of r.readonlyIndexes)if(o<n.state.addresses.length)t.readonly.push(n.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)}return t}static compile(e){const t=Sr.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const u of o){const y=t.extractTableLookup(u);if(y!==void 0){const[m,{writable:g,readonly:S}]=y;r.push(m),n.writable.push(...g),n.readonly.push(...S)}}const[i,a]=t.getMessageComponents(),l=new Gt(a,n).compileInstructions(e.instructions);return new _t({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:l,addressTableLookups:r})}serialize(){const e=Array();Ue(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();Ue(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),o=Array();Ue(o,this.addressTableLookups.length);const i=W([ee("prefix"),W([ee("numRequiredSignatures"),ee("numReadonlySignedAccounts"),ee("numReadonlyUnsignedAccounts")],"header"),ue(e.length,"staticAccountKeysLength"),Ie(X(),this.staticAccountKeys.length,"staticAccountKeys"),X("recentBlockhash"),ue(r.length,"instructionsLength"),ue(t.length,"serializedInstructions"),ue(o.length,"addressTableLookupsLength"),ue(n.length,"serializedAddressTableLookups")]),a=new Uint8Array(bt),c=1<<7,l=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(u=>u.toBytes()),recentBlockhash:we.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:n},a);return a.slice(0,l)}serializeInstructions(){let e=0;const t=new Uint8Array(bt);for(const r of this.compiledInstructions){const n=Array();Ue(n,r.accountKeyIndexes.length);const o=Array();Ue(o,r.data.length);const i=W([ee("programIdIndex"),ue(n.length,"encodedAccountKeyIndexesLength"),Ie(ee(),r.accountKeyIndexes.length,"accountKeyIndexes"),ue(o.length,"encodedDataLength"),ue(r.data.length,"data")]);e+=i.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(bt);for(const r of this.addressTableLookups){const n=Array();Ue(n,r.writableIndexes.length);const o=Array();Ue(o,r.readonlyIndexes.length);const i=W([X("accountKey"),ue(n.length,"encodedWritableIndexesLength"),Ie(ee(),r.writableIndexes.length,"writableIndexes"),ue(o.length,"encodedReadonlyIndexesLength"),Ie(ee(),r.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=t.shift(),n=r&kr;te(r!==n,"Expected versioned message but received legacy message");const o=n;te(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},a=[],c=Le(t);for(let S=0;S<c;S++)a.push(new x(t.splice(0,Ke)));const l=we.encode(t.splice(0,Ke)),u=Le(t),y=[];for(let S=0;S<u;S++){const w=t.shift(),k=Le(t),B=t.splice(0,k),U=Le(t),_=new Uint8Array(t.splice(0,U));y.push({programIdIndex:w,accountKeyIndexes:B,data:_})}const m=Le(t),g=[];for(let S=0;S<m;S++){const w=new x(t.splice(0,Ke)),k=Le(t),B=t.splice(0,k),U=Le(t),_=t.splice(0,U);g.push({accountKey:w,writableIndexes:B,readonlyIndexes:_})}return new _t({header:i,staticAccountKeys:a,recentBlockhash:l,compiledInstructions:y,addressTableLookups:g})}}const Bn={deserializeMessageVersion(s){const e=s[0],t=e&kr;return t===e?"legacy":t},deserialize:s=>{const e=Bn.deserializeMessageVersion(s);if(e==="legacy")return He.from(s);if(e===0)return _t.deserialize(s);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let nt=function(s){return s[s.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",s[s.PROCESSED=1]="PROCESSED",s[s.TIMED_OUT=2]="TIMED_OUT",s[s.NONCE_INVALID=3]="NONCE_INVALID",s}({});const Ja=M.Buffer.alloc(Nt).fill(0);class ae{constructor(e){this.keys=void 0,this.programId=void 0,this.data=M.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class se{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new ae(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let w=0;w<t.length;w++)if(t[w].programId===void 0)throw new Error(`Transaction instruction index ${w} has undefined program id`);const n=[],o=[];t.forEach(w=>{w.keys.forEach(B=>{o.push({...B})});const k=w.programId.toString();n.includes(k)||n.push(k)}),n.forEach(w=>{o.push({pubkey:new x(w),isSigner:!1,isWritable:!1})});const i=[];o.forEach(w=>{const k=w.pubkey.toString(),B=i.findIndex(U=>U.pubkey.toString()===k);B>-1?(i[B].isWritable=i[B].isWritable||w.isWritable,i[B].isSigner=i[B].isSigner||w.isSigner):i.push(w)}),i.sort(function(w,k){if(w.isSigner!==k.isSigner)return w.isSigner?-1:1;if(w.isWritable!==k.isWritable)return w.isWritable?-1:1;const B={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return w.pubkey.toBase58().localeCompare(k.pubkey.toBase58(),"en",B)});const a=i.findIndex(w=>w.pubkey.equals(r));if(a>-1){const[w]=i.splice(a,1);w.isSigner=!0,w.isWritable=!0,i.unshift(w)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const w of this.signatures){const k=i.findIndex(B=>B.pubkey.equals(w.publicKey));if(k>-1)i[k].isSigner||(i[k].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${w.publicKey.toString()}`)}let c=0,l=0,u=0;const y=[],m=[];i.forEach(({pubkey:w,isSigner:k,isWritable:B})=>{k?(y.push(w.toString()),c+=1,B||(l+=1)):(m.push(w.toString()),B||(u+=1))});const g=y.concat(m),S=t.map(w=>{const{data:k,programId:B}=w;return{programIdIndex:g.indexOf(B.toString()),accounts:w.keys.map(U=>g.indexOf(U.pubkey.toString())),data:we.encode(k)}});return S.forEach(w=>{te(w.programIdIndex>=0),w.accounts.forEach(k=>te(k>=0))}),new He({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:u},accountKeys:g,recentBlockhash:e,instructions:S})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((n,o)=>t[o].equals(n.publicKey))||(this.signatures=t.map(r=>({signature:null,publicKey:r}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(r=>{const n=r.toString();return t.has(n)?!1:(t.add(n),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),r.push(o))}this.signatures=r.map(o=>({signature:null,publicKey:o.publicKey}));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),r.push(o))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(n=>{const o=An(r,n.secretKey);this._addSignature(n.publicKey,J(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){te(t.length===64);const r=this.signatures.findIndex(n=>e.equals(n.publicKey));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=M.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:o}of this.signatures)n===null?t&&(r.missing||=[]).push(o):Fa(n,e,o.toBytes())||(r.invalid||=[]).push(o);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const o=this._getMessageSignednessErrors(n,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];Ue(r,t.length);const n=r.length+t.length*64+e.length,o=M.Buffer.alloc(n);return te(t.length<256),M.Buffer.from(r).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(te(i.length===64,"signature has invalid length"),M.Buffer.from(i).copy(o,r.length+a*64))}),e.copy(o,r.length+t.length*64),te(o.length<=bt,`Transaction too large: ${o.length} > ${bt}`),o}get keys(){return te(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return te(this.instructions.length===1),this.instructions[0].programId}get data(){return te(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const r=Le(t);let n=[];for(let o=0;o<r;o++){const i=t.slice(0,Nt);t=t.slice(Nt),n.push(we.encode(M.Buffer.from(i)))}return se.populate(He.from(t),n)}static populate(e,t=[]){const r=new se;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((n,o)=>{const i={signature:n==we.encode(Ja)?null:we.decode(n),publicKey:e.accountKeys[o]};r.signatures.push(i)}),e.instructions.forEach(n=>{const o=n.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:r.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});r.instructions.push(new ae({keys:o,programId:e.accountKeys[n.programIdIndex],data:we.decode(n.data)}))}),r._message=e,r._json=r.toJSON(),r}}class Pn{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:n,recentBlockhash:o}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=r,l=i-a;te(l>0,"Message header is invalid");const u=e.staticAccountKeys.length-i-c;te(u>=0,"Message header is invalid");const y=e.getAccountKeys(t),m=y.get(0);if(m===void 0)throw new Error("Failed to decompile message because no account keys were found");const g=[];for(const S of n){const w=[];for(const B of S.accountKeyIndexes){const U=y.get(B);if(U===void 0)throw new Error(`Failed to find key for account key index ${B}`);const _=B<i;let v;_?v=B<l:B<y.staticAccountKeys.length?v=B-i<u:v=B-y.staticAccountKeys.length<y.accountKeysFromLookups.writable.length,w.push({pubkey:U,isSigner:B<r.numRequiredSignatures,isWritable:v})}const k=y.get(S.programIdIndex);if(k===void 0)throw new Error(`Failed to find program id for program id index ${S.programIdIndex}`);g.push(new ae({programId:k,data:J(S.data),keys:w}))}return new Pn({payerKey:m,instructions:g,recentBlockhash:o})}compileToLegacyMessage(){return He.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return _t.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class Tn{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)te(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const r=[];for(let n=0;n<e.header.numRequiredSignatures;n++)r.push(new Uint8Array(Nt));this.signatures=r}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Ue(t,this.signatures.length);const r=W([ue(t.length,"encodedSignaturesLength"),Ie(Ha(),this.signatures.length,"signatures"),ue(e.length,"serializedMessage")]),n=new Uint8Array(2048),o=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},n);return n.slice(0,o)}static deserialize(e){let t=[...e];const r=[],n=Le(t);for(let i=0;i<n;i++)r.push(new Uint8Array(t.splice(0,Nt)));const o=Bn.deserialize(new Uint8Array(t));return new Tn(o,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of e){const o=r.findIndex(i=>i.equals(n.publicKey));te(o>=0,`Cannot sign with non signer key ${n.publicKey.toBase58()}`),this.signatures[o]=An(t,n.secretKey)}}addSignature(e,t){te(t.byteLength===64,"Signature must be 64 bytes long");const n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));te(n>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[n]=t}}const Za=160,Xa=64,Qa=Za/Xa,vo=1e3/Qa,je=new x("SysvarC1ock11111111111111111111111111111111"),ec=new x("SysvarEpochSchedu1e111111111111111111111111"),tc=new x("Sysvar1nstructions1111111111111111111111111"),ir=new x("SysvarRecentB1ockHashes11111111111111111111"),Ut=new x("SysvarRent111111111111111111111111111111111"),rc=new x("SysvarRewards111111111111111111111111111111"),nc=new x("SysvarS1otHashes111111111111111111111111111"),sc=new x("SysvarS1otHistory11111111111111111111111111"),ar=new x("SysvarStakeHistory1111111111111111111111111");async function Zr(s,e,t,r){const n=r&&{skipPreflight:r.skipPreflight,preflightCommitment:r.preflightCommitment||r.commitment,maxRetries:r.maxRetries,minContextSlot:r.minContextSlot},o=await s.sendTransaction(e,t,n);let i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await s.confirmTransaction({abortSignal:r?.abortSignal,signature:o,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},r&&r.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(await s.confirmTransaction({abortSignal:r?.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:o},r&&r.commitment)).value}else r?.abortSignal!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(await s.confirmTransaction(o,r&&r.commitment)).value;if(i.err)throw new Error(`Transaction ${o} failed (${JSON.stringify(i)})`);return o}function St(s){return new Promise(e=>setTimeout(e,s))}function Q(s,e){const t=s.layout.span>=0?s.layout.span:_o(s,e),r=M.Buffer.alloc(t),n=Object.assign({instruction:s.index},e);return s.layout.encode(n,r),r}function ne(s,e){let t;try{t=s.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.instruction!==s.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${s.index}`);return t}const Ao=ke("lamportsPerSignature"),Eo=W([K("version"),K("state"),X("authorizedPubkey"),X("nonce"),W([Ao],"feeCalculator")]),Xr=Eo.span;class Ir{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Eo.decode(J(e),0);return new Ir({authorizedPubkey:new x(t.authorizedPubkey),nonce:new x(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const oc=s=>{const e=s.decode.bind(s),t=s.encode.bind(s);return{decode:e,encode:t}},ic=s=>e=>{const t=ue(s,e),{encode:r,decode:n}=oc(t),o=t;return o.decode=(i,a)=>{const c=n(i,a);return ha(M.Buffer.from(c))},o.encode=(i,a,c)=>{const l=co(i,s);return r(l,a,c)},o},Kt=ic(8);class ac{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=K("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(ce))if(i.index==r){n=o;break}if(!n)throw new Error("Instruction type incorrect; not a SystemInstruction");return n}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:n}=ne(ce.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new x(n)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=ne(ce.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:n}=ne(ce.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new x(n)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=ne(ce.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:n,programId:o}=ne(ce.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new x(t),seed:r,space:n,programId:new x(o)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=ne(ce.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new x(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:n}=ne(ce.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new x(t),seed:r,programId:new x(n)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:n,space:o,programId:i}=ne(ce.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new x(t),seed:r,lamports:n,space:o,programId:new x(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=ne(ce.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new x(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ne(ce.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=ne(ce.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=ne(ce.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new x(t)}}static checkProgramId(e){if(!e.equals(_e.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const ce=Object.freeze({Create:{index:0,layout:W([K("instruction"),Ne("lamports"),Ne("space"),X("programId")])},Assign:{index:1,layout:W([K("instruction"),X("programId")])},Transfer:{index:2,layout:W([K("instruction"),Kt("lamports")])},CreateWithSeed:{index:3,layout:W([K("instruction"),X("base"),It("seed"),Ne("lamports"),Ne("space"),X("programId")])},AdvanceNonceAccount:{index:4,layout:W([K("instruction")])},WithdrawNonceAccount:{index:5,layout:W([K("instruction"),Ne("lamports")])},InitializeNonceAccount:{index:6,layout:W([K("instruction"),X("authorized")])},AuthorizeNonceAccount:{index:7,layout:W([K("instruction"),X("authorized")])},Allocate:{index:8,layout:W([K("instruction"),Ne("space")])},AllocateWithSeed:{index:9,layout:W([K("instruction"),X("base"),It("seed"),Ne("space"),X("programId")])},AssignWithSeed:{index:10,layout:W([K("instruction"),X("base"),It("seed"),X("programId")])},TransferWithSeed:{index:11,layout:W([K("instruction"),Kt("lamports"),It("seed"),X("programId")])},UpgradeNonceAccount:{index:12,layout:W([K("instruction")])}});class _e{constructor(){}static createAccount(e){const t=ce.Create,r=Q(t,{lamports:e.lamports,space:e.space,programId:J(e.programId.toBuffer())});return new ae({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let t,r;if("basePubkey"in e){const n=ce.TransferWithSeed;t=Q(n,{lamports:BigInt(e.lamports),seed:e.seed,programId:J(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const n=ce.Transfer;t=Q(n,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new ae({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){const n=ce.AssignWithSeed;t=Q(n,{base:J(e.basePubkey.toBuffer()),seed:e.seed,programId:J(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=ce.Assign;t=Q(n,{programId:J(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ae({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=ce.CreateWithSeed,r=Q(t,{base:J(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:J(e.programId.toBuffer())});let n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&n.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new ae({keys:n,programId:this.programId,data:r})}static createNonceAccount(e){const t=new se;"basePubkey"in e&&"seed"in e?t.add(_e.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Xr,programId:this.programId})):t.add(_e.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Xr,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=ce.InitializeNonceAccount,r=Q(t,{authorized:J(e.authorizedPubkey.toBuffer())}),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ir,isSigner:!1,isWritable:!1},{pubkey:Ut,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new ae(n)}static nonceAdvance(e){const t=ce.AdvanceNonceAccount,r=Q(t),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ir,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new ae(n)}static nonceWithdraw(e){const t=ce.WithdrawNonceAccount,r=Q(t,{lamports:e.lamports});return new ae({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ir,isSigner:!1,isWritable:!1},{pubkey:Ut,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const t=ce.AuthorizeNonceAccount,r=Q(t,{authorized:J(e.newAuthorizedPubkey.toBuffer())});return new ae({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let t,r;if("basePubkey"in e){const n=ce.AllocateWithSeed;t=Q(n,{base:J(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:J(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=ce.Allocate;t=Q(n,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ae({keys:r,programId:this.programId,data:t})}}_e.programId=new x("11111111111111111111111111111111");const cc=bt-300;class vt{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/vt.chunkSize)+1+1)}static async load(e,t,r,n,o){{const y=await e.getMinimumBalanceForRentExemption(o.length),m=await e.getAccountInfo(r.publicKey,"confirmed");let g=null;if(m!==null){if(m.executable)return console.error("Program load failed, account is already executable"),!1;m.data.length!==o.length&&(g=g||new se,g.add(_e.allocate({accountPubkey:r.publicKey,space:o.length}))),m.owner.equals(n)||(g=g||new se,g.add(_e.assign({accountPubkey:r.publicKey,programId:n}))),m.lamports<y&&(g=g||new se,g.add(_e.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:y-m.lamports})))}else g=new se().add(_e.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:y>0?y:1,space:o.length,programId:n}));g!==null&&await Zr(e,g,[t,r],{commitment:"confirmed"})}const i=W([K("instruction"),K("offset"),K("bytesLength"),K("bytesLengthPadding"),Ie(ee("byte"),yt(K(),-8),"bytes")]),a=vt.chunkSize;let c=0,l=o,u=[];for(;l.length>0;){const y=l.slice(0,a),m=M.Buffer.alloc(a+16);i.encode({instruction:0,offset:c,bytes:y,bytesLength:0,bytesLengthPadding:0},m);const g=new se().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:n,data:m});u.push(Zr(e,g,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await St(1e3/4),c+=a,l=l.slice(a)}await Promise.all(u);{const y=W([K("instruction")]),m=M.Buffer.alloc(y.span);y.encode({instruction:1},m);const g=new se().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Ut,isSigner:!1,isWritable:!1}],programId:n,data:m}),S="processed",w=await e.sendTransaction(g,[t,r],{preflightCommitment:S}),{context:k,value:B}=await e.confirmTransaction({signature:w,lastValidBlockHeight:g.lastValidBlockHeight,blockhash:g.recentBlockhash},S);if(B.err)throw new Error(`Transaction ${w} failed (${JSON.stringify(B)})`);for(;;){try{if(await e.getSlot({commitment:S})>k.slot)break}catch{}await new Promise(U=>setTimeout(U,Math.round(vo/2)))}}return!0}}vt.chunkSize=cc;const uc=new x("BPFLoader2111111111111111111111111111111111");class lc{static getMinNumSignatures(e){return vt.getMinNumSignatures(e)}static load(e,t,r,n,o){return vt.load(e,t,r,o,n)}}function dc(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var fc=Object.prototype.toString,hc=Object.keys||function(s){var e=[];for(var t in s)e.push(t);return e};function Ht(s,e){var t,r,n,o,i,a,c;if(s===!0)return"true";if(s===!1)return"false";switch(typeof s){case"object":if(s===null)return null;if(s.toJSON&&typeof s.toJSON=="function")return Ht(s.toJSON(),e);if(c=fc.call(s),c==="[object Array]"){for(n="[",r=s.length-1,t=0;t<r;t++)n+=Ht(s[t],!0)+",";return r>-1&&(n+=Ht(s[t],!0)),n+"]"}else if(c==="[object Object]"){for(o=hc(s).sort(),r=o.length,n="",t=0;t<r;)i=o[t],a=Ht(s[i],!1),a!==void 0&&(n&&(n+=","),n+=JSON.stringify(i)+":"+a),t++;return"{"+n+"}"}else return JSON.stringify(s);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(s);default:return isFinite(s)?s:null}}var pc=function(s){var e=Ht(s,!1);if(e!==void 0)return""+e},bs=dc(pc);const $t=32;function $r(s){let e=0;for(;s>1;)s/=2,e++;return e}function yc(s){return s===0?1:(s--,s|=s>>1,s|=s>>2,s|=s>>4,s|=s>>8,s|=s>>16,s|=s>>32,s+1)}class xo{constructor(e,t,r,n,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=$r(yc(e+$t+1))-$r($t)-1,r=this.getSlotsInEpoch(t),n=e-(r-$t);return[t,n]}else{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch),n=this.firstNormalEpoch+r,o=t%this.slotsPerEpoch;return[n,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*$t:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+$r($t)):this.slotsPerEpoch}}class Qr extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}const gc={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class F extends Error{constructor({code:e,message:t,data:r},n){super(n!=null?`${n}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}var bc=globalThis.fetch;class mc extends Ua{constructor(e,t,r){const n=o=>{const i=Ka(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(n,e,t,r),this.underlyingSocket=void 0}call(...e){const t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){const t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function wc(s,e){let t;try{t=s.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.typeIndex!==s.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${s.index}`);return t}const ms=56;class en{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=wc(kc,e),r=e.length-ms;te(r>=0,"lookup table is invalid"),te(r%32===0,"lookup table is invalid");const n=r/32,{addresses:o}=W([Ie(X(),n,"addresses")]).decode(e.slice(ms));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new x(t.authority[0]):void 0,addresses:o.map(i=>new x(i))}}}const kc={index:1,layout:W([K("typeIndex"),Kt("deactivationSlot"),ke("lastExtendedSlot"),ee("lastExtendedStartIndex"),ee(),Ie(X(),yt(ee(),-1),"authority")])},Sc=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Ic(s){const e=s.match(Sc);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${s}\``);const[t,r,n,o]=e,i=s.startsWith("https:")?"wss:":"ws:",a=n==null?null:parseInt(n.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${r}${c}${o}`}const ge=er(Sn(x),E(),s=>new x(s)),Ro=In([E(),he("base64")]),Ln=er(Sn(M.Buffer),Ro,s=>M.Buffer.from(s[0],"base64")),Bo=30*1e3;function _c(s){if(/^https?:/.test(s)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return s}function de(s){let e,t;if(typeof s=="string")e=s;else if(s){const{commitment:r,...n}=s;e=r,t=n}return{commitment:e,config:t}}function Po(s){return Oe([I({jsonrpc:he("2.0"),id:E(),result:s}),I({jsonrpc:he("2.0"),id:E(),error:I({code:Qt(),message:E(),data:$(Ia())})})])}const vc=Po(Qt());function Y(s){return er(Po(s),vc,e=>"error"in e?e:{...e,result:R(e.result,s)})}function pe(s){return Y(I({context:I({slot:d()}),value:s}))}function _r(s){return I({context:I({slot:d()}),value:s})}function Hr(s,e){return s===0?new _t({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new x(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:we.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new He(e)}const Ac=I({foundation:d(),foundationTerm:d(),initial:d(),taper:d(),terminal:d()}),Ec=Y(O(L(I({epoch:d(),effectiveSlot:d(),amount:d(),postBalance:d(),commission:$(L(d()))})))),xc=O(I({slot:d(),prioritizationFee:d()})),Rc=I({total:d(),validator:d(),foundation:d(),epoch:d()}),Bc=I({epoch:d(),slotIndex:d(),slotsInEpoch:d(),absoluteSlot:d(),blockHeight:$(d()),transactionCount:$(d())}),Pc=I({slotsPerEpoch:d(),leaderScheduleSlotOffset:d(),warmup:Je(),firstNormalEpoch:d(),firstNormalSlot:d()}),Tc=fo(E(),O(d())),xt=L(Oe([I({}),E()])),Lc=I({err:xt}),Cc=he("receivedSignature"),Oc=I({"solana-core":E(),"feature-set":$(d())}),ws=pe(I({err:L(Oe([I({}),E()])),logs:L(O(E())),accounts:$(L(O(L(I({executable:Je(),owner:E(),lamports:d(),data:O(E()),rentEpoch:$(d())}))))),unitsConsumed:$(d()),returnData:$(L(I({programId:E(),data:In([E(),he("base64")])})))})),zc=pe(I({byIdentity:fo(E(),O(d())),range:I({firstSlot:d(),lastSlot:d()})}));function Nc(s,e,t,r,n,o){const i=t||bc;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return r&&(c=async(u,y)=>{const m=await new Promise((g,S)=>{try{r(u,y,(w,k)=>g([w,k]))}catch(w){S(w)}});return await i(...m)}),new Ba(async(u,y)=>{const m={method:"POST",body:u,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Uu)};try{let g=5,S,w=500;for(;c?S=await c(s,m):S=await i(s,m),!(S.status!==429||n===!0||(g-=1,g===0));)console.error(`Server responded with ${S.status} ${S.statusText}.  Retrying after ${w}ms delay...`),await St(w),w*=2;const k=await S.text();S.ok?y(null,k):y(new Error(`${S.status} ${S.statusText}: ${k}`))}catch(g){g instanceof Error&&y(g)}},{})}function Uc(s){return(e,t)=>new Promise((r,n)=>{s.request(e,t,(o,i)=>{if(o){n(o);return}r(i)})})}function Kc(s){return e=>new Promise((t,r)=>{e.length===0&&t([]);const n=e.map(o=>s.request(o.methodName,o.args));s.request(n,(o,i)=>{if(o){r(o);return}t(i)})})}const Wc=Y(Ac),Fc=Y(Rc),Dc=Y(xc),qc=Y(Bc),Mc=Y(Pc),$c=Y(Tc),Hc=Y(d()),Vc=pe(I({total:d(),circulating:d(),nonCirculating:d(),nonCirculatingAccounts:O(ge)})),tn=I({amount:E(),uiAmount:L(d()),decimals:d(),uiAmountString:$(E())}),jc=pe(O(I({address:ge,amount:E(),uiAmount:L(d()),decimals:d(),uiAmountString:$(E())}))),Gc=pe(O(I({pubkey:ge,account:I({executable:Je(),owner:ge,lamports:d(),data:Ln,rentEpoch:d()})}))),rn=I({program:E(),parsed:Qt(),space:d()}),Yc=pe(O(I({pubkey:ge,account:I({executable:Je(),owner:ge,lamports:d(),data:rn,rentEpoch:d()})}))),Jc=pe(O(I({lamports:d(),address:ge}))),Yt=I({executable:Je(),owner:ge,lamports:d(),data:Ln,rentEpoch:d()}),Zc=I({pubkey:ge,account:Yt}),Xc=er(Oe([Sn(M.Buffer),rn]),Oe([Ro,rn]),s=>Array.isArray(s)?R(s,Ln):s),nn=I({executable:Je(),owner:ge,lamports:d(),data:Xc,rentEpoch:d()}),Qc=I({pubkey:ge,account:nn}),eu=I({state:Oe([he("active"),he("inactive"),he("activating"),he("deactivating")]),active:d(),inactive:d()}),tu=Y(O(I({signature:E(),slot:d(),err:xt,memo:L(E()),blockTime:$(L(d()))}))),ru=Y(O(I({signature:E(),slot:d(),err:xt,memo:L(E()),blockTime:$(L(d()))}))),nu=I({subscription:d(),result:_r(Yt)}),su=I({pubkey:ge,account:Yt}),ou=I({subscription:d(),result:_r(su)}),iu=I({parent:d(),slot:d(),root:d()}),au=I({subscription:d(),result:iu}),cu=Oe([I({type:Oe([he("firstShredReceived"),he("completed"),he("optimisticConfirmation"),he("root")]),slot:d(),timestamp:d()}),I({type:he("createdBank"),parent:d(),slot:d(),timestamp:d()}),I({type:he("frozen"),slot:d(),timestamp:d(),stats:I({numTransactionEntries:d(),numSuccessfulTransactions:d(),numFailedTransactions:d(),maxTransactionsPerEntry:d()})}),I({type:he("dead"),slot:d(),timestamp:d(),err:E()})]),uu=I({subscription:d(),result:cu}),lu=I({subscription:d(),result:_r(Oe([Lc,Cc]))}),du=I({subscription:d(),result:d()}),fu=I({pubkey:E(),gossip:L(E()),tpu:L(E()),rpc:L(E()),version:L(E())}),ks=I({votePubkey:E(),nodePubkey:E(),activatedStake:d(),epochVoteAccount:Je(),epochCredits:O(In([d(),d(),d()])),commission:d(),lastVote:d(),rootSlot:L(d())}),hu=Y(I({current:O(ks),delinquent:O(ks)})),pu=Oe([he("processed"),he("confirmed"),he("finalized")]),yu=I({slot:d(),confirmations:L(d()),err:xt,confirmationStatus:$(pu)}),gu=pe(O(L(yu))),bu=Y(d()),To=I({accountKey:ge,writableIndexes:O(d()),readonlyIndexes:O(d())}),Cn=I({signatures:O(E()),message:I({accountKeys:O(E()),header:I({numRequiredSignatures:d(),numReadonlySignedAccounts:d(),numReadonlyUnsignedAccounts:d()}),instructions:O(I({accounts:O(d()),data:E(),programIdIndex:d()})),recentBlockhash:E(),addressTableLookups:$(O(To))})}),Lo=I({pubkey:ge,signer:Je(),writable:Je(),source:$(Oe([he("transaction"),he("lookupTable")]))}),Co=I({accountKeys:O(Lo),signatures:O(E())}),Oo=I({parsed:Qt(),program:E(),programId:ge}),zo=I({accounts:O(ge),data:E(),programId:ge}),mu=Oe([zo,Oo]),wu=Oe([I({parsed:Qt(),program:E(),programId:E()}),I({accounts:O(E()),data:E(),programId:E()})]),No=er(mu,wu,s=>"accounts"in s?R(s,zo):R(s,Oo)),Uo=I({signatures:O(E()),message:I({accountKeys:O(Lo),instructions:O(No),recentBlockhash:E(),addressTableLookups:$(L(O(To)))})}),pr=I({accountIndex:d(),mint:E(),owner:$(E()),uiTokenAmount:tn}),Ko=I({writable:O(ge),readonly:O(ge)}),vr=I({err:xt,fee:d(),innerInstructions:$(L(O(I({index:d(),instructions:O(I({accounts:O(d()),data:E(),programIdIndex:d()}))})))),preBalances:O(d()),postBalances:O(d()),logMessages:$(L(O(E()))),preTokenBalances:$(L(O(pr))),postTokenBalances:$(L(O(pr))),loadedAddresses:$(Ko),computeUnitsConsumed:$(d())}),On=I({err:xt,fee:d(),innerInstructions:$(L(O(I({index:d(),instructions:O(No)})))),preBalances:O(d()),postBalances:O(d()),logMessages:$(L(O(E()))),preTokenBalances:$(L(O(pr))),postTokenBalances:$(L(O(pr))),loadedAddresses:$(Ko),computeUnitsConsumed:$(d())}),qt=Oe([he(0),he("legacy")]),Rt=I({pubkey:E(),lamports:d(),postBalance:L(d()),rewardType:L(E()),commission:$(L(d()))}),ku=Y(L(I({blockhash:E(),previousBlockhash:E(),parentSlot:d(),transactions:O(I({transaction:Cn,meta:L(vr),version:$(qt)})),rewards:$(O(Rt)),blockTime:L(d()),blockHeight:L(d())}))),Su=Y(L(I({blockhash:E(),previousBlockhash:E(),parentSlot:d(),rewards:$(O(Rt)),blockTime:L(d()),blockHeight:L(d())}))),Iu=Y(L(I({blockhash:E(),previousBlockhash:E(),parentSlot:d(),transactions:O(I({transaction:Co,meta:L(vr),version:$(qt)})),rewards:$(O(Rt)),blockTime:L(d()),blockHeight:L(d())}))),_u=Y(L(I({blockhash:E(),previousBlockhash:E(),parentSlot:d(),transactions:O(I({transaction:Uo,meta:L(On),version:$(qt)})),rewards:$(O(Rt)),blockTime:L(d()),blockHeight:L(d())}))),vu=Y(L(I({blockhash:E(),previousBlockhash:E(),parentSlot:d(),transactions:O(I({transaction:Co,meta:L(On),version:$(qt)})),rewards:$(O(Rt)),blockTime:L(d()),blockHeight:L(d())}))),Au=Y(L(I({blockhash:E(),previousBlockhash:E(),parentSlot:d(),rewards:$(O(Rt)),blockTime:L(d()),blockHeight:L(d())}))),Eu=Y(L(I({blockhash:E(),previousBlockhash:E(),parentSlot:d(),transactions:O(I({transaction:Cn,meta:L(vr)})),rewards:$(O(Rt)),blockTime:L(d())}))),Ss=Y(L(I({blockhash:E(),previousBlockhash:E(),parentSlot:d(),signatures:O(E()),blockTime:L(d())}))),Vr=Y(L(I({slot:d(),meta:L(vr),blockTime:$(L(d())),transaction:Cn,version:$(qt)}))),or=Y(L(I({slot:d(),transaction:Uo,meta:L(On),blockTime:$(L(d())),version:$(qt)}))),xu=pe(I({blockhash:E(),feeCalculator:I({lamportsPerSignature:d()})})),Ru=pe(I({blockhash:E(),lastValidBlockHeight:d()})),Bu=pe(Je()),Pu=I({slot:d(),numTransactions:d(),numSlots:d(),samplePeriodSecs:d()}),Tu=Y(O(Pu)),Lu=pe(L(I({feeCalculator:I({lamportsPerSignature:d()})}))),Cu=Y(E()),Ou=Y(E()),zu=I({err:xt,logs:O(E()),signature:E()}),Nu=I({result:_r(zu),subscription:d()}),Uu={"solana-client":"js/0.0.0-development"};class Ku{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const l={};return async u=>{const{commitment:y,config:m}=de(u),g=this._buildArgs([],y,void 0,m),S=bs(g);return l[S]=l[S]??(async()=>{try{const w=await this._rpcRequest("getBlockHeight",g),k=R(w,Y(d()));if("error"in k)throw new F(k.error,"failed to get block height information");return k.result}finally{delete l[S]}})(),await l[S]}})();let r,n,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,n=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=_c(e),this._rpcWsEndpoint=r||Ic(e),this._rpcClient=Nc(e,n,o,i,a,c),this._rpcRequest=Uc(this._rpcClient),this._rpcBatchRequest=Kc(this._rpcClient),this._rpcWebSocket=new mc(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:n}=de(t),o=this._buildArgs([e.toBase58()],r,void 0,n),i=await this._rpcRequest("getBalance",o),a=R(i,pe(d()));if("error"in a)throw new F(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+r)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=R(t,Y(L(d())));if("error"in r)throw new F(r.error,`failed to get block time for slot ${e}`);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=R(e,Y(d()));if("error"in t)throw new F(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=R(e,Hc);if("error"in t)throw new F(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),n=R(r,Vc);if("error"in n)throw new F(n.error,"failed to get supply");return n.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenSupply",r),o=R(n,pe(tn));if("error"in o)throw new F(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenAccountBalance",r),o=R(n,pe(tn));if("error"in o)throw new F(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,r){const{commitment:n,config:o}=de(r);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,n,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),l=R(c,Gc);if("error"in l)throw new F(l.error,`failed to get token accounts owned by account ${e.toBase58()}`);return l.result}async getParsedTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});const o=this._buildArgs(n,r,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=R(i,Yc);if("error"in a)throw new F(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],n=await this._rpcRequest("getLargestAccounts",r),o=R(n,Jc);if("error"in o)throw new F(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenLargestAccounts",r),o=R(n,jc);if("error"in o)throw new F(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:n}=de(t),o=this._buildArgs([e.toBase58()],r,"base64",n),i=await this._rpcRequest("getAccountInfo",o),a=R(i,pe(L(Yt)));if("error"in a)throw new F(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:r,config:n}=de(t),o=this._buildArgs([e.toBase58()],r,"jsonParsed",n),i=await this._rpcRequest("getAccountInfo",o),a=R(i,pe(L(nn)));if("error"in a)throw new F(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:n}=de(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],r,"jsonParsed",n),a=await this._rpcRequest("getMultipleAccounts",i),c=R(a,pe(O(L(nn))));if("error"in c)throw new F(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:n}=de(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],r,"base64",n),a=await this._rpcRequest("getMultipleAccounts",i),c=R(a,pe(O(L(Yt))));if("error"in c)throw new F(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,r){const{commitment:n,config:o}=de(t),i=this._buildArgs([e.toBase58()],n,void 0,{...o,epoch:r??o?.epoch}),a=await this._rpcRequest("getStakeActivation",i),c=R(a,Y(eu));if("error"in c)throw new F(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:r,config:n}=de(t),{encoding:o,...i}=n||{},a=this._buildArgs([e.toBase58()],r,o||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),l=O(Zc),u=i.withContext===!0?R(c,pe(l)):R(c,Y(l));if("error"in u)throw new F(u.error,`failed to get accounts owned by program ${e.toBase58()}`);return u.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:n}=de(t),o=this._buildArgs([e.toBase58()],r,"jsonParsed",n),i=await this._rpcRequest("getProgramAccounts",o),a=R(i,Y(O(Qc)));if("error"in a)throw new F(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){let r;if(typeof e=="string")r=e;else{const o=e;if(o.abortSignal?.aborted)return Promise.reject(o.abortSignal.reason);r=o.signature}let n;try{n=we.decode(r)}catch{throw new Error("signature must be base58 encoded: "+r)}return te(n.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{e!=null&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,n,o=!1;const i=new Promise((c,l)=>{try{r=this.onSignature(t,(y,m)=>{r=void 0;const g={context:m,value:y};c({__type:nt.PROCESSED,response:g})},e);const u=new Promise(y=>{r==null?y():n=this._onSubscriptionStateChange(r,m=>{m==="subscribed"&&y()})});(async()=>{if(await u,o)return;const y=await this.getSignatureStatus(t);if(o||y==null)return;const{context:m,value:g}=y;if(g!=null)if(g?.err)l(g.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(g.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(g.confirmationStatus==="processed"||g.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:nt.PROCESSED,response:{context:m,value:g}})}})()}catch(u){l(u)}});return{abortConfirmation:()=>{n&&(n(),n=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:n}}){let o=!1;const i=new Promise(y=>{const m=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let g=await m();if(!o){for(;g<=r;)if(await St(1e3),o||(g=await m(),o))return;y({__type:nt.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:n}),l=this.getCancellationPromise(t);let u;try{const y=await Promise.race([l,c,i]);if(y.__type===nt.PROCESSED)u=y.response;else throw new xn(n)}finally{o=!0,a()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:n,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(g=>{let S=o,w=null;const k=async()=>{try{const{context:B,value:U}=await this.getNonceAndContext(n,{commitment:e,minContextSlot:r});return w=B.slot,U?.nonce}catch{return S}};(async()=>{if(S=await k(),!a)for(;;){if(o!==S){g({__type:nt.NONCE_INVALID,slotInWhichNonceDidAdvance:w});return}if(await St(2e3),a||(S=await k(),a))return}})()}),{abortConfirmation:l,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),y=this.getCancellationPromise(t);let m;try{const g=await Promise.race([y,u,c]);if(g.__type===nt.PROCESSED)m=g.response;else{let S;for(;;){const w=await this.getSignatureStatus(i);if(w==null)break;if(w.context.slot<(g.slotInWhichNonceDidAdvance??r)){await St(400);continue}S=w;break}if(S?.value){const w=e||"finalized",{confirmationStatus:k}=S.value;switch(w){case"processed":case"recent":if(k!=="processed"&&k!=="confirmed"&&k!=="finalized")throw new Lt(i);break;case"confirmed":case"single":case"singleGossip":if(k!=="confirmed"&&k!=="finalized")throw new Lt(i);break;case"finalized":case"max":case"root":if(k!=="finalized")throw new Lt(i);break;default:(B=>{})(w)}m={context:S.context,value:{err:S.value.err}}}else throw new Lt(i)}}finally{a=!0,l()}return m}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const n=new Promise(c=>{let l=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{l=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>c({__type:nt.TIMED_OUT,timeoutMs:l}),l)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,n]);if(c.__type===nt.PROCESSED)a=c.response;else throw new Rn(t,c.timeoutMs/1e3)}finally{clearTimeout(r),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=R(e,Y(O(fu)));if("error"in t)throw new F(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),n=R(r,hu);if("error"in n)throw new F(n.error,"failed to get vote accounts");return n.result}async getSlot(e){const{commitment:t,config:r}=de(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getSlot",n),i=R(o,Y(d()));if("error"in i)throw new F(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:r}=de(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getSlotLeader",n),i=R(o,Y(E()));if("error"in i)throw new F(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const r=[e,t],n=await this._rpcRequest("getSlotLeaders",r),o=R(n,Y(O(ge)));if("error"in o)throw new F(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:r,value:n}=await this.getSignatureStatuses([e],t);te(n.length===1);const o=n[0];return{context:r,value:o}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const n=await this._rpcRequest("getSignatureStatuses",r),o=R(n,gu);if("error"in o)throw new F(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:r}=de(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getTransactionCount",n),i=R(o,Y(d()));if("error"in i)throw new F(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),n=R(r,Wc);if("error"in n)throw new F(n.error,"failed to get inflation");return n.result}async getInflationReward(e,t,r){const{commitment:n,config:o}=de(r),i=this._buildArgs([e.map(l=>l.toBase58())],n,void 0,{...o,epoch:t??o?.epoch}),a=await this._rpcRequest("getInflationReward",i),c=R(a,Ec);if("error"in c)throw new F(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=R(e,Fc);if("error"in t)throw new F(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:r}=de(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getEpochInfo",n),i=R(o,qc);if("error"in i)throw new F(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=R(e,Mc);if("error"in t)throw new F(t.error,"failed to get epoch schedule");const r=t.result;return new xo(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=R(e,$c);if("error"in t)throw new F(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getMinimumBalanceForRentExemption",r),o=R(n,bu);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),n=R(r,xu);if("error"in n)throw new F(n.error,"failed to get recent blockhash");return n.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),r=R(t,Tu);if("error"in r)throw new F(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getFeeCalculatorForBlockhash",r),o=R(n,Lu);if("error"in o)throw new F(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const r=J(e.serialize()).toString("base64"),n=this._buildArgs([r],t),o=await this._rpcRequest("getFeeForMessage",n),i=R(o,pe(L(d())));if("error"in i)throw new F(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){const t=e?.lockedWritableAccounts?.map(i=>i.toBase58()),r=t?.length?[t]:[],n=await this._rpcRequest("getRecentPrioritizationFees",r),o=R(n,Dc);if("error"in o)throw new F(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=de(e),n=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getLatestBlockhash",n),i=R(o,Ru);if("error"in i)throw new F(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:r,config:n}=de(t),o=this._buildArgs([e],r,void 0,n),i=await this._rpcRequest("isBlockhashValid",o),a=R(i,Bu);if("error"in a)throw new F(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=R(e,Y(Oc));if("error"in t)throw new F(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=R(e,Y(E()));if("error"in t)throw new F(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:r,config:n}=de(t),o=this._buildArgsAtLeastConfirmed([e],r,void 0,n),i=await this._rpcRequest("getBlock",o);try{switch(n?.transactionDetails){case"accounts":{const a=R(i,Iu);if("error"in a)throw a.error;return a.result}case"none":{const a=R(i,Su);if("error"in a)throw a.error;return a.result}default:{const a=R(i,ku);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:l,meta:u,version:y})=>({meta:u,transaction:{...l,message:Hr(y,l.message)},version:y}))}:null}}}catch(a){throw new F(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:n}=de(t),o=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),i=await this._rpcRequest("getBlock",o);try{switch(n?.transactionDetails){case"accounts":{const a=R(i,vu);if("error"in a)throw a.error;return a.result}case"none":{const a=R(i,Au);if("error"in a)throw a.error;return a.result}default:{const a=R(i,_u);if("error"in a)throw a.error;return a.result}}}catch(a){throw new F(a,"failed to get block")}}async getBlockProduction(e){let t,r;if(typeof e=="string")r=e;else if(e){const{commitment:a,...c}=e;r=a,t=c}const n=this._buildArgs([],r,"base64",t),o=await this._rpcRequest("getBlockProduction",n),i=R(o,zc);if("error"in i)throw new F(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:r,config:n}=de(t),o=this._buildArgsAtLeastConfirmed([e],r,void 0,n),i=await this._rpcRequest("getTransaction",o),a=R(i,Vr);if("error"in a)throw new F(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Hr(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:r,config:n}=de(t),o=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),i=await this._rpcRequest("getTransaction",o),a=R(i,or);if("error"in a)throw new F(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:r,config:n}=de(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],r,"jsonParsed",n)}));return(await this._rpcBatchRequest(o)).map(c=>{const l=R(c,or);if("error"in l)throw new F(l.error,"failed to get transactions");return l.result})}async getTransactions(e,t){const{commitment:r,config:n}=de(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],r,void 0,n)}));return(await this._rpcBatchRequest(o)).map(c=>{const l=R(c,Vr);if("error"in l)throw new F(l.error,"failed to get transactions");const u=l.result;return u&&{...u,transaction:{...u.transaction,message:Hr(u.version,u.transaction.message)}}})}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedBlock",r),o=R(n,Eu);if("error"in o)throw new F(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:l})=>{const u=new He(c.message);return{meta:l,transaction:{...c,message:u}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:l})=>({meta:l,transaction:se.populate(c.message,c.signatures)}))}}async getBlocks(e,t,r){const n=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],r),o=await this._rpcRequest("getBlocks",n),i=R(o,Y(O(d())));if("error"in i)throw new F(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getBlock",r),o=R(n,Ss);if("error"in o)throw new F(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getConfirmedBlock",r),o=R(n,Ss);if("error"in o)throw new F(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedTransaction",r),o=R(n,Vr);if("error"in o)throw new F(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new He(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:se.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=await this._rpcRequest("getConfirmedTransaction",r),o=R(n,or);if("error"in o)throw new F(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const r=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(r)).map(i=>{const a=R(i,or);if("error"in a)throw new F(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,r){let n={},o=await this.getFirstAvailableBlock();for(;!("until"in n)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(n.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in n)&&(r++,!(r>i));)try{const c=await this.getConfirmedBlockSignatures(r);c.signatures.length>0&&(n.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,n)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",n),i=R(o,tu);if("error"in i)throw new F(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",n),i=R(o,ru);if("error"in i)throw new F(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let o=null;return n!==null&&(o=new en({key:e,state:en.deserialize(n.data)})),{context:r,value:o}}async getNonceAndContext(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let o=null;return n!==null&&(o=Ir.fromAccountData(n.data)),{context:r,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+r)})}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),n=R(r,Cu);if("error"in n)throw new F(n.error,`airdrop to ${e.toBase58()} failed`);return n.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await St(100);const r=Date.now()-this._blockhashInfo.lastFetch>=Bo;if(this._blockhashInfo.latestBlockhash!==null&&!r)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let n=0;n<50;n++){const o=await this.getLatestBlockhash("finalized");if(r!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await St(vo/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=de(e),n=this._buildArgs([],t,"base64",r),o=await this._rpcRequest("getStakeMinimumDelegation",n),i=R(o,pe(d()));if("error"in i)throw new F(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,r){if("message"in e){const w=e.serialize(),k=M.Buffer.from(w).toString("base64");if(Array.isArray(t)||r!==void 0)throw new Error("Invalid arguments");const B=t||{};B.encoding="base64","commitment"in B||(B.commitment=this.commitment);const U=[k,B],_=await this._rpcRequest("simulateTransaction",U),v=R(_,ws);if("error"in v)throw new Error("failed to simulate transaction: "+v.error.message);return v.result}let n;if(e instanceof se){let S=e;n=new se,n.feePayer=S.feePayer,n.instructions=e.instructions,n.nonceInfo=S.nonceInfo,n.signatures=S.signatures}else n=se.populate(e),n._message=n._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(n.nonceInfo&&o)n.sign(...o);else{let S=this._disableBlockhashCaching;for(;;){const w=await this._blockhashWithExpiryBlockHeight(S);if(n.lastValidBlockHeight=w.lastValidBlockHeight,n.recentBlockhash=w.blockhash,!o)break;if(n.sign(...o),!n.signature)throw new Error("!signature");const k=n.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(k)&&!this._blockhashInfo.transactionSignatures.includes(k)){this._blockhashInfo.simulatedSignatures.push(k);break}else S=!0}}const i=n._compile(),a=i.serialize(),l=n._serialize(a).toString("base64"),u={encoding:"base64",commitment:this.commitment};if(r){const S=(Array.isArray(r)?r:i.nonProgramIds()).map(w=>w.toBase58());u.accounts={encoding:"base64",addresses:S}}o&&(u.sigVerify=!0);const y=[l,u],m=await this._rpcRequest("simulateTransaction",y),g=R(m,ws);if("error"in g){let S;if("data"in g.error&&(S=g.error.data.logs,S&&Array.isArray(S))){const w=`
    `,k=w+S.join(w);console.error(g.error.message,k)}throw new Qr("failed to simulate transaction: "+g.error.message,S)}return g.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const n=t;if(e.nonceInfo)e.sign(...n);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...n),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,r)}async sendRawTransaction(e,t){const r=J(e).toString("base64");return await this.sendEncodedTransaction(r,t)}async sendEncodedTransaction(e,t){const r={encoding:"base64"},n=t&&t.skipPreflight,o=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(r.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(r.minContextSlot=t.minContextSlot),n&&(r.skipPreflight=n),o&&(r.preflightCommitment=o);const i=[e,r],a=await this._rpcRequest("sendTransaction",i),c=R(a,Ou);if("error"in c){let l;throw"data"in c.error&&(l=c.error.data.logs),new Qr("failed to send transaction: "+c.error.message,l)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,r])=>{this._setSubscription(t,{...r,state:"pending"})})}_setSubscription(e,t){const r=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,r!==t.state){const n=this._subscriptionStateChangeCallbacksByHash[e];n&&n.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){const r=this._subscriptionHashByClientSubscriptionId[e];if(r==null)return()=>{};const n=this._subscriptionStateChangeCallbacksByHash[r]||=new Set;return n.add(t),()=>{n.delete(t),n.size===0&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{const n=this._subscriptionsByHash[r];if(n!==void 0)switch(n.state){case"pending":case"unsubscribed":if(n.callbacks.size===0){delete this._subscriptionsByHash[r],n.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=n;try{this._setSubscription(r,{...n,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(r,{...n,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=n.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,o,a.message),!t())return;this._setSubscription(r,{...n,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":n.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=n;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(r,{...n,state:"unsubscribing"}),this._setSubscription(r,{...n,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(r,{...n,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...n,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];r!==void 0&&r.forEach(n=>{try{n(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:r}=R(e,nu);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,n=bs([e.method,t],!0),o=this._subscriptionsByHash[n];return o===void 0?this._subscriptionsByHash[n]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=n,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const i=this._subscriptionsByHash[n];te(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const n=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},n)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=R(e,ou);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,n){const o=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",n?{filters:n}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const n=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=R(e,Nu);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=R(e,au);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=R(e,uu);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,r,n){const o=t||this._commitment;if(o||r||n){let i={};r&&(i.encoding=r),o&&(i.commitment=o),n&&(i=Object.assign(i,n)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,r,n){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,n)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=R(e,lu);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const n=this._buildArgs([e],r||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return o}onSignatureWithOptions(e,t,r){const{commitment:n,...o}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},i=this._buildArgs([e],n,void 0,o),a=this._makeSubscription({callback:(c,l)=>{t(c,l);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=R(e,du);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Ct{constructor(e){this._keypair=void 0,this._keypair=e??ps()}static generate(){return new Ct(ps())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const n=e.slice(0,32),o=hr(n);for(let i=0;i<32;i++)if(r[i]!==o[i])throw new Error("provided secretKey is invalid")}return new Ct({publicKey:r,secretKey:e})}static fromSeed(e){const t=hr(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Ct({publicKey:t,secretKey:r})}get publicKey(){return new x(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const ot=Object.freeze({CreateLookupTable:{index:0,layout:W([K("instruction"),Kt("recentSlot"),ee("bumpSeed")])},FreezeLookupTable:{index:1,layout:W([K("instruction")])},ExtendLookupTable:{index:2,layout:W([K("instruction"),Kt(),Ie(X(),yt(K(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:W([K("instruction")])},CloseLookupTable:{index:4,layout:W([K("instruction")])}});class Wu{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=K("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(ot))if(i.index==r){n=o;break}if(!n)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return n}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=ne(ot.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=ne(ot.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(r=>new x(r))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(zn.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class zn{constructor(){}static createLookupTable(e){const[t,r]=x.findProgramAddressSync([e.authority.toBuffer(),co(BigInt(e.recentSlot),8)],this.programId),n=ot.CreateLookupTable,o=Q(n,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:_e.programId,isSigner:!1,isWritable:!1}];return[new ae({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){const t=ot.FreezeLookupTable,r=Q(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new ae({programId:this.programId,keys:n,data:r})}static extendLookupTable(e){const t=ot.ExtendLookupTable,r=Q(t,{addresses:e.addresses.map(o=>o.toBytes())}),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&n.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:_e.programId,isSigner:!1,isWritable:!1}),new ae({programId:this.programId,keys:n,data:r})}static deactivateLookupTable(e){const t=ot.DeactivateLookupTable,r=Q(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new ae({programId:this.programId,keys:n,data:r})}static closeLookupTable(e){const t=ot.CloseLookupTable,r=Q(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new ae({programId:this.programId,keys:n,data:r})}}zn.programId=new x("AddressLookupTab1e1111111111111111111111111");class Fu{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=ee("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(Ge))if(i.index==r){n=o;break}if(!n)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return n}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=ne(Ge.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=ne(Ge.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=ne(Ge.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=ne(Ge.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(Nn.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const Ge=Object.freeze({RequestUnits:{index:0,layout:W([ee("instruction"),K("units"),K("additionalFee")])},RequestHeapFrame:{index:1,layout:W([ee("instruction"),K("bytes")])},SetComputeUnitLimit:{index:2,layout:W([ee("instruction"),K("units")])},SetComputeUnitPrice:{index:3,layout:W([ee("instruction"),Kt("microLamports")])}});class Nn{constructor(){}static requestUnits(e){const t=Ge.RequestUnits,r=Q(t,e);return new ae({keys:[],programId:this.programId,data:r})}static requestHeapFrame(e){const t=Ge.RequestHeapFrame,r=Q(t,e);return new ae({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(e){const t=Ge.SetComputeUnitLimit,r=Q(t,e);return new ae({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(e){const t=Ge.SetComputeUnitPrice,r=Q(t,{microLamports:BigInt(e.microLamports)});return new ae({keys:[],programId:this.programId,data:r})}}Nn.programId=new x("ComputeBudget111111111111111111111111111111");const Is=64,_s=32,vs=64,As=W([ee("numSignatures"),ee("padding"),Fe("signatureOffset"),Fe("signatureInstructionIndex"),Fe("publicKeyOffset"),Fe("publicKeyInstructionIndex"),Fe("messageDataOffset"),Fe("messageDataSize"),Fe("messageInstructionIndex")]);class Ar{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,instructionIndex:o}=e;te(t.length===_s,`Public Key must be ${_s} bytes but received ${t.length} bytes`),te(n.length===vs,`Signature must be ${vs} bytes but received ${n.length} bytes`);const i=As.span,a=i+t.length,c=a+n.length,l=1,u=M.Buffer.alloc(c+r.length),y=o??65535;return As.encode({numSignatures:l,padding:0,signatureOffset:a,signatureInstructionIndex:y,publicKeyOffset:i,publicKeyInstructionIndex:y,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:y},u),u.fill(t,i),u.fill(n,a),u.fill(r,c),new ae({keys:[],programId:Ar.programId,data:u})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;te(t.length===Is,`Private key must be ${Is} bytes but received ${t.length} bytes`);try{const o=Ct.fromSecretKey(t),i=o.publicKey.toBytes(),a=An(r,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:a,instructionIndex:n})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}Ar.programId=new x("Ed25519SigVerify111111111111111111111111111");const Du=(s,e)=>{const t=an.sign(s,e);return[t.toCompactRawBytes(),t.recovery]};an.utils.isValidPrivateKey;const qu=an.getPublicKey,Es=32,jr=20,xs=64,Mu=11,Gr=W([ee("numSignatures"),Fe("signatureOffset"),ee("signatureInstructionIndex"),Fe("ethAddressOffset"),ee("ethAddressInstructionIndex"),Fe("messageDataOffset"),Fe("messageDataSize"),ee("messageInstructionIndex"),ue(20,"ethAddress"),ue(64,"signature"),ee("recoveryId")]);class Ot{constructor(){}static publicKeyToEthAddress(e){te(e.length===xs,`Public key must be ${xs} bytes but received ${e.length} bytes`);try{return M.Buffer.from(Xn(J(e))).slice(-jr)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:o,instructionIndex:i}=e;return Ot.createInstructionWithEthAddress({ethAddress:Ot.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:n,recoveryId:o,instructionIndex:i=0}=e;let a;typeof t=="string"?t.startsWith("0x")?a=M.Buffer.from(t.substr(2),"hex"):a=M.Buffer.from(t,"hex"):a=t,te(a.length===jr,`Address must be ${jr} bytes but received ${a.length} bytes`);const c=1+Mu,l=c,u=c+a.length,y=u+n.length+1,m=1,g=M.Buffer.alloc(Gr.span+r.length);return Gr.encode({numSignatures:m,signatureOffset:u,signatureInstructionIndex:i,ethAddressOffset:l,ethAddressInstructionIndex:i,messageDataOffset:y,messageDataSize:r.length,messageInstructionIndex:i,signature:J(n),ethAddress:J(a),recoveryId:o},g),g.fill(J(r),Gr.span),new ae({keys:[],programId:Ot.programId,data:g})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;te(t.length===Es,`Private key must be ${Es} bytes but received ${t.length} bytes`);try{const o=J(t),i=qu(o,!1).slice(1),a=M.Buffer.from(Xn(J(r))),[c,l]=Du(a,o);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:c,recoveryId:l,instructionIndex:n})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}Ot.programId=new x("KeccakSecp256k11111111111111111111111111111");var Wo;const Fo=new x("StakeConfig11111111111111111111111111111111");class Do{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class tr{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}Wo=tr;tr.default=new Wo(0,0,x.default);class $u{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=K("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(me))if(i.index==r){n=o;break}if(!n)throw new Error("Instruction type incorrect; not a StakeInstruction");return n}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:r}=ne(me.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Do(new x(t.staker),new x(t.withdrawer)),lockup:new tr(r.unixTimestamp,r.epoch,new x(r.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),ne(me.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:r}=ne(me.Authorize,e.data),n={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new x(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(n.custodianPubkey=e.keys[3].pubkey),n}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:r,authoritySeed:n,authorityOwner:o}=ne(me.AuthorizeWithSeed,e.data),i={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:n,authorityOwner:new x(o),newAuthorizedPubkey:new x(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=ne(me.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ne(me.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=ne(me.Withdraw,e.data),r={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(r.custodianPubkey=e.keys[5].pubkey),r}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ne(me.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(Er.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const me=Object.freeze({Initialize:{index:0,layout:W([K("instruction"),Va(),ja()])},Authorize:{index:1,layout:W([K("instruction"),X("newAuthorized"),K("stakeAuthorizationType")])},Delegate:{index:2,layout:W([K("instruction")])},Split:{index:3,layout:W([K("instruction"),Ne("lamports")])},Withdraw:{index:4,layout:W([K("instruction"),Ne("lamports")])},Deactivate:{index:5,layout:W([K("instruction")])},Merge:{index:7,layout:W([K("instruction")])},AuthorizeWithSeed:{index:8,layout:W([K("instruction"),X("newAuthorized"),K("stakeAuthorizationType"),It("authoritySeed"),X("authorityOwner")])}}),Hu=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class Er{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,o=n||tr.default,i=me.Initialize,a=Q(i,{authorized:{staker:J(r.staker.toBuffer()),withdrawer:J(r.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:J(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ut,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new ae(c)}static createAccountWithSeed(e){const t=new se;t.add(_e.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:o}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:o}))}static createAccount(e){const t=new se;t.add(_e.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:o}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:o}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,o=me.Delegate,i=Q(o);return new se().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:Fo,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:o,custodianPubkey:i}=e,a=me.Authorize,c=Q(a,{newAuthorized:J(n.toBuffer()),stakeAuthorizationType:o.index}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new se().add({keys:l,programId:this.programId,data:c})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,l=me.AuthorizeWithSeed,u=Q(l,{newAuthorized:J(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:n,authorityOwner:J(o.toBuffer())}),y=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:je,isSigner:!1,isWritable:!1}];return c&&y.push({pubkey:c,isSigner:!0,isWritable:!1}),new se().add({keys:y,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:o}=e,i=me.Split,a=Q(i,{lamports:o});return new ae({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e){const t=new se;return t.add(_e.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:0,space:this.space,programId:this.programId})),t.add(this.splitInstruction(e))}static splitWithSeed(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,basePubkey:o,seed:i,lamports:a}=e,c=new se;return c.add(_e.allocate({accountPubkey:n,basePubkey:o,seed:i,space:this.space,programId:this.programId})),c.add(this.splitInstruction({stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,o=me.Merge,i=Q(o);return new se().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:o,custodianPubkey:i}=e,a=me.Withdraw,c=Q(a,{lamports:o}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new se().add({keys:l,programId:this.programId,data:c})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=me.Deactivate,o=Q(n);return new se().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}}Er.programId=new x("Stake11111111111111111111111111111111111111");Er.space=200;class qo{constructor(e,t,r,n){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=r,this.commission=n}}class Vu{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=K("instruction").decode(e.data);let n;for(const[o,i]of Object.entries(it))if(i.index==r){n=o;break}if(!n)throw new Error("Instruction type incorrect; not a VoteInstruction");return n}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=ne(it.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new qo(new x(t.nodePubkey),new x(t.authorizedVoter),new x(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:r}=ne(it.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new x(t),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:r,newAuthorized:n,voteAuthorizationType:o}}=ne(it.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new x(t),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new x(n),voteAuthorizationType:{index:o},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=ne(it.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Mt.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const it=Object.freeze({InitializeAccount:{index:0,layout:W([K("instruction"),Ga()])},Authorize:{index:1,layout:W([K("instruction"),X("newAuthorized"),K("voteAuthorizationType")])},Withdraw:{index:3,layout:W([K("instruction"),Ne("lamports")])},AuthorizeWithSeed:{index:10,layout:W([K("instruction"),Ya()])}}),ju=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Mt{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,o=it.InitializeAccount,i=Q(o,{voteInit:{nodePubkey:J(n.nodePubkey.toBuffer()),authorizedVoter:J(n.authorizedVoter.toBuffer()),authorizedWithdrawer:J(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ut,isSigner:!1,isWritable:!1},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new ae(a)}static createAccount(e){const t=new se;return t.add(_e.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:o}=e,i=it.Authorize,a=Q(i,{newAuthorized:J(n.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new se().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:a}=e,c=it.AuthorizeWithSeed,l=Q(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:J(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:J(o.toBuffer()),voteAuthorizationType:i.index}}),u=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new se().add({keys:u,programId:this.programId,data:l})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:o}=e,i=it.Withdraw,a=Q(i,{lamports:n}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return new se().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insuffcient funds.");return Mt.withdraw(e)}}Mt.programId=new x("Vote111111111111111111111111111111111111111");Mt.space=3731;const Mo=new x("Va1idator1nfo111111111111111111111111111111"),Gu=I({name:E(),website:$(E()),details:$(E()),keybaseUsername:$(E())});class Un{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(Le(t)!==2)return null;const n=[];for(let o=0;o<2;o++){const i=new x(t.slice(0,Ke));t=t.slice(Ke);const a=t.slice(0,1)[0]===1;t=t.slice(1),n.push({publicKey:i,isSigner:a})}if(n[0].publicKey.equals(Mo)&&n[1].isSigner){const o=It().decode(M.Buffer.from(t)),i=JSON.parse(o);return uo(i,Gu),new Un(n[1].publicKey,i)}return null}}const Yu=new x("Vote111111111111111111111111111111111111111"),Ju=W([X("nodePubkey"),X("authorizedWithdrawer"),ee("commission"),ke(),Ie(W([ke("slot"),K("confirmationCount")]),yt(K(),-8),"votes"),ee("rootSlotValid"),ke("rootSlot"),ke(),Ie(W([ke("epoch"),X("authorizedVoter")]),yt(K(),-8),"authorizedVoters"),W([Ie(W([X("authorizedPubkey"),ke("epochOfLastAuthorizedSwitch"),ke("targetEpoch")]),32,"buf"),ke("idx"),ee("isEmpty")],"priorVoters"),ke(),Ie(W([ke("epoch"),ke("credits"),ke("prevCredits")]),yt(K(),-8),"epochCredits"),W([ke("slot"),ke("timestamp")],"lastTimestamp")]);class Kn{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const r=Ju.decode(J(e),4);let n=r.rootSlot;return r.rootSlotValid||(n=null),new Kn({nodePubkey:new x(r.nodePubkey),authorizedWithdrawer:new x(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:n,authorizedVoters:r.authorizedVoters.map(Zu),priorVoters:Xu(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function Zu({authorizedVoter:s,epoch:e}){return{epoch:e,authorizedVoter:new x(s)}}function Rs({authorizedPubkey:s,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new x(s),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function Xu({buf:s,idx:e,isEmpty:t}){return t?[]:[...s.slice(e+1).map(Rs),...s.slice(0,e).map(Rs)]}const Bs={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function Qu(s,e){const t=e===!1?"http":"https";if(!s)return Bs[t].devnet;const r=Bs[t][s];if(!r)throw new Error(`Unknown ${t} cluster: ${s}`);return r}async function el(s,e,t,r){let n,o;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(n=t,o=r):o=t;const i=o&&{skipPreflight:o.skipPreflight,preflightCommitment:o.preflightCommitment||o.commitment,minContextSlot:o.minContextSlot},a=await s.sendRawTransaction(e,i),c=o&&o.commitment,u=(await(n?s.confirmTransaction(n,c):s.confirmTransaction(a,c))).value;if(u.err)throw new Error(`Raw transaction ${a} failed (${JSON.stringify(u)})`);return a}const tl=1e9,nl=Object.freeze(Object.defineProperty({__proto__:null,Account:Ma,AddressLookupTableAccount:en,AddressLookupTableInstruction:Wu,AddressLookupTableProgram:zn,Authorized:Do,BLOCKHASH_CACHE_TIMEOUT_MS:Bo,BPF_LOADER_DEPRECATED_PROGRAM_ID:$a,BPF_LOADER_PROGRAM_ID:uc,BpfLoader:lc,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:Ge,ComputeBudgetInstruction:Fu,ComputeBudgetProgram:Nn,Connection:Ku,Ed25519Program:Ar,Enum:Da,EpochSchedule:xo,FeeCalculatorLayout:Ao,Keypair:Ct,LAMPORTS_PER_SOL:tl,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:ot,Loader:vt,Lockup:tr,MAX_SEED_LENGTH:Io,Message:He,MessageAccountKeys:Gt,MessageV0:_t,NONCE_ACCOUNT_LENGTH:Xr,NonceAccount:Ir,PACKET_DATA_SIZE:bt,PUBLIC_KEY_LENGTH:Ke,PublicKey:x,SIGNATURE_LENGTH_IN_BYTES:Nt,SOLANA_SCHEMA:Vt,STAKE_CONFIG_ID:Fo,STAKE_INSTRUCTION_LAYOUTS:me,SYSTEM_INSTRUCTION_LAYOUTS:ce,SYSVAR_CLOCK_PUBKEY:je,SYSVAR_EPOCH_SCHEDULE_PUBKEY:ec,SYSVAR_INSTRUCTIONS_PUBKEY:tc,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:ir,SYSVAR_RENT_PUBKEY:Ut,SYSVAR_REWARDS_PUBKEY:rc,SYSVAR_SLOT_HASHES_PUBKEY:nc,SYSVAR_SLOT_HISTORY_PUBKEY:sc,SYSVAR_STAKE_HISTORY_PUBKEY:ar,Secp256k1Program:Ot,SendTransactionError:Qr,SolanaJSONRPCError:F,SolanaJSONRPCErrorCode:gc,StakeAuthorizationLayout:Hu,StakeInstruction:$u,StakeProgram:Er,Struct:En,SystemInstruction:ac,SystemProgram:_e,Transaction:se,TransactionExpiredBlockheightExceededError:xn,TransactionExpiredNonceInvalidError:Lt,TransactionExpiredTimeoutError:Rn,TransactionInstruction:ae,TransactionMessage:Pn,TransactionStatus:nt,VALIDATOR_INFO_KEY:Mo,VERSION_PREFIX_MASK:kr,VOTE_PROGRAM_ID:Yu,ValidatorInfo:Un,VersionedMessage:Bn,VersionedTransaction:Tn,VoteAccount:Kn,VoteAuthorizationLayout:ju,VoteInit:qo,VoteInstruction:Vu,VoteProgram:Mt,clusterApiUrl:Qu,sendAndConfirmRawTransaction:el,sendAndConfirmTransaction:Zr},Symbol.toStringTag,{value:"Module"}));export{Ct as K,x as P,Ut as S,ae as T,co as a,ue as b,_e as c,K as d,se as e,Zr as f,nl as i,W as s,ha as t,ee as u};
