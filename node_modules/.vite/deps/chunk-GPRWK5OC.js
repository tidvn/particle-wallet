import {
  require_dist,
  require_dist2,
  require_keccak
} from "./chunk-YM32VLGM.js";
import {
  require_events
} from "./chunk-E4YFJ4DO.js";
import {
  __commonJS
} from "./chunk-IKJM6GHQ.js";

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "node_modules/crc-32/crc32.js"(exports) {
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n)
          table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256)
            v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n)
          out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; )
          C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; )
          C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while (i < L)
          C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// node_modules/@ethereumjs/common/dist/chains/goerli.json
var require_goerli = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/goerli.json"(exports, module) {
    module.exports = {
      name: "goerli",
      chainId: 5,
      networkId: 5,
      defaultHardfork: "merge",
      consensus: {
        type: "poa",
        algorithm: "clique",
        clique: {
          period: 15,
          epoch: 3e4
        }
      },
      comment: "Cross-client PoA test network",
      url: "https://github.com/goerli/testnet",
      genesis: {
        timestamp: "0x5c51a607",
        gasLimit: 10485760,
        difficulty: 1,
        nonce: "0x0000000000000000",
        extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "byzantium",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "constantinople",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "petersburg",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "istanbul",
          block: 1561651,
          forkHash: "0xc25efa5c"
        },
        {
          name: "berlin",
          block: 4460644,
          forkHash: "0x757a1c47"
        },
        {
          name: "london",
          block: 5062605,
          forkHash: "0xb8c6299d"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
          name: "merge",
          ttd: "10790000",
          block: 7382819,
          forkHash: "0xb8c6299d"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1678832736",
          forkHash: "0xf9843abf"
        }
      ],
      bootstrapNodes: [
        {
          ip: "51.141.78.53",
          port: 30303,
          id: "011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",
          location: "",
          comment: "Upstream bootnode 1"
        },
        {
          ip: "13.93.54.137",
          port: 30303,
          id: "176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",
          location: "",
          comment: "Upstream bootnode 2"
        },
        {
          ip: "94.237.54.114",
          port: 30313,
          id: "46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",
          location: "",
          comment: "Upstream bootnode 3"
        },
        {
          ip: "18.218.250.66",
          port: 30313,
          id: "b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",
          location: "",
          comment: "Upstream bootnode 4"
        },
        {
          ip: "3.11.147.67",
          port: 30303,
          id: "a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",
          location: "",
          comment: "Ethereum Foundation bootnode"
        },
        {
          ip: "51.15.116.226",
          port: 30303,
          id: "a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",
          location: "",
          comment: "Goerli Initiative bootnode"
        },
        {
          ip: "51.15.119.157",
          port: 30303,
          id: "807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",
          location: "",
          comment: "Goerli Initiative bootnode"
        },
        {
          ip: "51.15.119.157",
          port: 40303,
          id: "a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",
          location: "",
          comment: "Goerli Initiative bootnode"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/chains/mainnet.json
var require_mainnet = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/mainnet.json"(exports, module) {
    module.exports = {
      name: "mainnet",
      chainId: 1,
      networkId: 1,
      defaultHardfork: "merge",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "The Ethereum main chain",
      url: "https://ethstats.net/",
      genesis: {
        gasLimit: 5e3,
        difficulty: 17179869184,
        nonce: "0x0000000000000042",
        extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xfc64ec04"
        },
        {
          name: "homestead",
          block: 115e4,
          forkHash: "0x97c2c34c"
        },
        {
          name: "dao",
          block: 192e4,
          forkHash: "0x91d1f948"
        },
        {
          name: "tangerineWhistle",
          block: 2463e3,
          forkHash: "0x7a64da13"
        },
        {
          name: "spuriousDragon",
          block: 2675e3,
          forkHash: "0x3edd5b10"
        },
        {
          name: "byzantium",
          block: 437e4,
          forkHash: "0xa00bc324"
        },
        {
          name: "constantinople",
          block: 728e4,
          forkHash: "0x668db0af"
        },
        {
          name: "petersburg",
          block: 728e4,
          forkHash: "0x668db0af"
        },
        {
          name: "istanbul",
          block: 9069e3,
          forkHash: "0x879d6e30"
        },
        {
          name: "muirGlacier",
          block: 92e5,
          forkHash: "0xe029e991"
        },
        {
          name: "berlin",
          block: 12244e3,
          forkHash: "0x0eb440f6"
        },
        {
          name: "london",
          block: 12965e3,
          forkHash: "0xb715077d"
        },
        {
          name: "arrowGlacier",
          block: 13773e3,
          forkHash: "0x20c327fc"
        },
        {
          name: "grayGlacier",
          block: 1505e4,
          forkHash: "0xf0afd0e3"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
          name: "merge",
          ttd: "58750000000000000000000",
          block: 15537394,
          forkHash: "0xf0afd0e3"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1681338455",
          forkHash: "0xdce96c2d"
        }
      ],
      bootstrapNodes: [
        {
          ip: "18.138.108.67",
          port: 30303,
          id: "d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",
          location: "ap-southeast-1-001",
          comment: "bootnode-aws-ap-southeast-1-001"
        },
        {
          ip: "3.209.45.79",
          port: 30303,
          id: "22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",
          location: "us-east-1-001",
          comment: "bootnode-aws-us-east-1-001"
        },
        {
          ip: "65.108.70.101",
          port: 30303,
          id: "2b252ab6a1d0f971d9722cb839a42cb81db019ba44c08754628ab4a823487071b5695317c8ccd085219c3a03af063495b2f1da8d18218da2d6a82981b45e6ffc",
          location: "eu-west-1-001",
          comment: "bootnode-hetzner-hel"
        },
        {
          ip: "157.90.35.166",
          port: 30303,
          id: "4aeb4ab6c14b23e2c4cfdce879c04b0748a20d8e9b59e25ded2a08143e265c6c25936e74cbc8e641e3312ca288673d91f2f93f8e277de3cfa444ecdaaf982052",
          location: "eu-central-1-001",
          comment: "bootnode-hetzner-fsn"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/chains/rinkeby.json
var require_rinkeby = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/rinkeby.json"(exports, module) {
    module.exports = {
      name: "rinkeby",
      chainId: 4,
      networkId: 4,
      defaultHardfork: "london",
      consensus: {
        type: "poa",
        algorithm: "clique",
        clique: {
          period: 15,
          epoch: 3e4
        }
      },
      comment: "PoA test network",
      url: "https://www.rinkeby.io",
      genesis: {
        timestamp: "0x58ee40ba",
        gasLimit: 47e5,
        difficulty: 1,
        nonce: "0x0000000000000000",
        extraData: "0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0x3b8e0691"
        },
        {
          name: "homestead",
          block: 1,
          forkHash: "0x60949295"
        },
        {
          name: "tangerineWhistle",
          block: 2,
          forkHash: "0x8bde40dd"
        },
        {
          name: "spuriousDragon",
          block: 3,
          forkHash: "0xcb3a64bb"
        },
        {
          name: "byzantium",
          block: 1035301,
          forkHash: "0x8d748b57"
        },
        {
          name: "constantinople",
          block: 3660663,
          forkHash: "0xe49cab14"
        },
        {
          name: "petersburg",
          block: 4321234,
          forkHash: "0xafec6b27"
        },
        {
          name: "istanbul",
          block: 5435345,
          forkHash: "0xcbdb8838"
        },
        {
          name: "berlin",
          block: 8290928,
          forkHash: "0x6910c8bd"
        },
        {
          name: "london",
          block: 8897988,
          forkHash: "0x8e29f2f3"
        },
        {
          name: "merge",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          forkHash: null
        }
      ],
      bootstrapNodes: [
        {
          ip: "52.169.42.101",
          port: 30303,
          id: "a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",
          location: "",
          comment: "IE"
        },
        {
          ip: "52.3.158.184",
          port: 30303,
          id: "343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",
          location: "",
          comment: "INFURA"
        },
        {
          ip: "159.89.28.211",
          port: 30303,
          id: "b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",
          location: "",
          comment: "AKASHA"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/chains/ropsten.json
var require_ropsten = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/ropsten.json"(exports, module) {
    module.exports = {
      name: "ropsten",
      chainId: 3,
      networkId: 3,
      defaultHardfork: "merge",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "PoW test network",
      url: "https://github.com/ethereum/ropsten",
      genesis: {
        gasLimit: 16777216,
        difficulty: 1048576,
        nonce: "0x0000000000000042",
        extraData: "0x3535353535353535353535353535353535353535353535353535353535353535"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0x30c7ddbc"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0x30c7ddbc"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0x30c7ddbc"
        },
        {
          name: "spuriousDragon",
          block: 10,
          forkHash: "0x63760190"
        },
        {
          name: "byzantium",
          block: 17e5,
          forkHash: "0x3ea159c7"
        },
        {
          name: "constantinople",
          block: 423e4,
          forkHash: "0x97b544f3"
        },
        {
          name: "petersburg",
          block: 4939394,
          forkHash: "0xd6e2149b"
        },
        {
          name: "istanbul",
          block: 6485846,
          forkHash: "0x4bc66396"
        },
        {
          name: "muirGlacier",
          block: 7117117,
          forkHash: "0x6727ef90"
        },
        {
          name: "berlin",
          block: 9812189,
          forkHash: "0xa157d377"
        },
        {
          name: "london",
          block: 10499401,
          forkHash: "0x7119b6b3"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge",
          name: "merge",
          ttd: "50000000000000000",
          block: null,
          forkHash: "0x7119b6b3"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          forkHash: null
        }
      ],
      bootstrapNodes: [
        {
          ip: "52.176.7.10",
          port: 30303,
          id: "30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",
          location: "",
          comment: "US-Azure geth"
        },
        {
          ip: "52.176.100.77",
          port: 30303,
          id: "865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",
          location: "",
          comment: "US-Azure parity"
        },
        {
          ip: "52.232.243.152",
          port: 30303,
          id: "6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",
          location: "",
          comment: "Parity"
        },
        {
          ip: "192.81.208.223",
          port: 30303,
          id: "94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",
          location: "",
          comment: "@gpip"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/chains/sepolia.json
var require_sepolia = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/sepolia.json"(exports, module) {
    module.exports = {
      name: "sepolia",
      chainId: 11155111,
      networkId: 11155111,
      defaultHardfork: "merge",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "PoW test network to replace Ropsten",
      url: "https://github.com/ethereum/go-ethereum/pull/23730",
      genesis: {
        timestamp: "0x6159af19",
        gasLimit: 3e7,
        difficulty: 131072,
        nonce: "0x0000000000000000",
        extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "byzantium",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "constantinople",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "petersburg",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "istanbul",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "muirGlacier",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "berlin",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "london",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
          name: "merge",
          ttd: "17000000000000000",
          block: 1450409,
          forkHash: "0xfe3366e7"
        },
        {
          name: "mergeForkIdTransition",
          block: 1735371,
          forkHash: "0xb96cbd13"
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1677557088",
          forkHash: "0xf7f9bc08"
        }
      ],
      bootstrapNodes: [
        {
          ip: "18.168.182.86",
          port: 30303,
          id: "9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",
          location: "",
          comment: "geth"
        },
        {
          ip: "52.14.151.177",
          port: 30303,
          id: "ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",
          location: "",
          comment: "besu"
        },
        {
          ip: "165.22.196.173",
          port: 30303,
          id: "ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",
          location: "",
          comment: "EF"
        },
        {
          ip: "65.108.95.67",
          port: 30303,
          id: "075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",
          location: "",
          comment: "lodestar"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/1153.json
var require__ = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/1153.json"(exports, module) {
    module.exports = {
      name: "EIP-1153",
      number: 1153,
      comment: "Transient Storage",
      url: "https://eips.ethereum.org/EIPS/eip-1153",
      status: "Review",
      minimumHardfork: "chainstart",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        tstore: {
          v: 100,
          d: "Base fee of the TSTORE opcode"
        },
        tload: {
          v: 100,
          d: "Base fee of the TLOAD opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/1559.json
var require__2 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/1559.json"(exports, module) {
    module.exports = {
      name: "EIP-1559",
      number: 1559,
      comment: "Fee market change for ETH 1.0 chain",
      url: "https://eips.ethereum.org/EIPS/eip-1559",
      status: "Final",
      minimumHardfork: "berlin",
      requiredEIPs: [2930],
      gasConfig: {
        baseFeeMaxChangeDenominator: {
          v: 8,
          d: "Maximum base fee change denominator"
        },
        elasticityMultiplier: {
          v: 2,
          d: "Maximum block gas target elasticity"
        },
        initialBaseFee: {
          v: 1e9,
          d: "Initial base fee on first EIP1559 block"
        }
      },
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2315.json
var require__3 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2315.json"(exports, module) {
    module.exports = {
      name: "EIP-2315",
      number: 2315,
      comment: "Simple subroutines for the EVM",
      url: "https://eips.ethereum.org/EIPS/eip-2315",
      status: "Draft",
      minimumHardfork: "istanbul",
      gasConfig: {},
      gasPrices: {
        beginsub: {
          v: 2,
          d: "Base fee of the BEGINSUB opcode"
        },
        returnsub: {
          v: 5,
          d: "Base fee of the RETURNSUB opcode"
        },
        jumpsub: {
          v: 10,
          d: "Base fee of the JUMPSUB opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2537.json
var require__4 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2537.json"(exports, module) {
    module.exports = {
      name: "EIP-2537",
      number: 2537,
      comment: "BLS12-381 precompiles",
      url: "https://eips.ethereum.org/EIPS/eip-2537",
      status: "Draft",
      minimumHardfork: "chainstart",
      gasConfig: {},
      gasPrices: {
        Bls12381G1AddGas: {
          v: 600,
          d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
        },
        Bls12381G1MulGas: {
          v: 12e3,
          d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
        },
        Bls12381G2AddGas: {
          v: 4500,
          d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
        },
        Bls12381G2MulGas: {
          v: 55e3,
          d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
        },
        Bls12381PairingBaseGas: {
          v: 115e3,
          d: "Base gas cost of BLS12-381 pairing check"
        },
        Bls12381PairingPerPairGas: {
          v: 23e3,
          d: "Per-pair gas cost of BLS12-381 pairing check"
        },
        Bls12381MapG1Gas: {
          v: 5500,
          d: "Gas cost of BLS12-381 map field element to G1"
        },
        Bls12381MapG2Gas: {
          v: 11e4,
          d: "Gas cost of BLS12-381 map field element to G2"
        },
        Bls12381MultiExpGasDiscount: {
          v: [
            [1, 1200],
            [2, 888],
            [3, 764],
            [4, 641],
            [5, 594],
            [6, 547],
            [7, 500],
            [8, 453],
            [9, 438],
            [10, 423],
            [11, 408],
            [12, 394],
            [13, 379],
            [14, 364],
            [15, 349],
            [16, 334],
            [17, 330],
            [18, 326],
            [19, 322],
            [20, 318],
            [21, 314],
            [22, 310],
            [23, 306],
            [24, 302],
            [25, 298],
            [26, 294],
            [27, 289],
            [28, 285],
            [29, 281],
            [30, 277],
            [31, 273],
            [32, 269],
            [33, 268],
            [34, 266],
            [35, 265],
            [36, 263],
            [37, 262],
            [38, 260],
            [39, 259],
            [40, 257],
            [41, 256],
            [42, 254],
            [43, 253],
            [44, 251],
            [45, 250],
            [46, 248],
            [47, 247],
            [48, 245],
            [49, 244],
            [50, 242],
            [51, 241],
            [52, 239],
            [53, 238],
            [54, 236],
            [55, 235],
            [56, 233],
            [57, 232],
            [58, 231],
            [59, 229],
            [60, 228],
            [61, 226],
            [62, 225],
            [63, 223],
            [64, 222],
            [65, 221],
            [66, 220],
            [67, 219],
            [68, 219],
            [69, 218],
            [70, 217],
            [71, 216],
            [72, 216],
            [73, 215],
            [74, 214],
            [75, 213],
            [76, 213],
            [77, 212],
            [78, 211],
            [79, 211],
            [80, 210],
            [81, 209],
            [82, 208],
            [83, 208],
            [84, 207],
            [85, 206],
            [86, 205],
            [87, 205],
            [88, 204],
            [89, 203],
            [90, 202],
            [91, 202],
            [92, 201],
            [93, 200],
            [94, 199],
            [95, 199],
            [96, 198],
            [97, 197],
            [98, 196],
            [99, 196],
            [100, 195],
            [101, 194],
            [102, 193],
            [103, 193],
            [104, 192],
            [105, 191],
            [106, 191],
            [107, 190],
            [108, 189],
            [109, 188],
            [110, 188],
            [111, 187],
            [112, 186],
            [113, 185],
            [114, 185],
            [115, 184],
            [116, 183],
            [117, 182],
            [118, 182],
            [119, 181],
            [120, 180],
            [121, 179],
            [122, 179],
            [123, 178],
            [124, 177],
            [125, 176],
            [126, 176],
            [127, 175],
            [128, 174]
          ],
          d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2565.json
var require__5 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2565.json"(exports, module) {
    module.exports = {
      name: "EIP-2565",
      number: 2565,
      comment: "ModExp gas cost",
      url: "https://eips.ethereum.org/EIPS/eip-2565",
      status: "Final",
      minimumHardfork: "byzantium",
      gasConfig: {},
      gasPrices: {
        modexpGquaddivisor: {
          v: 3,
          d: "Gquaddivisor from modexp precompile for gas calculation"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2718.json
var require__6 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2718.json"(exports, module) {
    module.exports = {
      name: "EIP-2718",
      comment: "Typed Transaction Envelope",
      url: "https://eips.ethereum.org/EIPS/eip-2718",
      status: "Final",
      minimumHardfork: "chainstart",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2929.json
var require__7 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2929.json"(exports, module) {
    module.exports = {
      name: "EIP-2929",
      comment: "Gas cost increases for state access opcodes",
      url: "https://eips.ethereum.org/EIPS/eip-2929",
      status: "Final",
      minimumHardfork: "chainstart",
      gasConfig: {},
      gasPrices: {
        coldsload: {
          v: 2100,
          d: "Gas cost of the first read of storage from a given location (per transaction)"
        },
        coldaccountaccess: {
          v: 2600,
          d: "Gas cost of the first read of a given address (per transaction)"
        },
        warmstorageread: {
          v: 100,
          d: "Gas cost of reading storage locations which have already loaded 'cold'"
        },
        sstoreCleanGasEIP2200: {
          v: 2900,
          d: "Once per SSTORE operation from clean non-zero to something else"
        },
        sstoreNoopGasEIP2200: {
          v: 100,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 100,
          d: "Once per SSTORE operation if a dirty value is changed"
        },
        sstoreInitRefundEIP2200: {
          v: 19900,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        sstoreCleanRefundEIP2200: {
          v: 4900,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        call: {
          v: 0,
          d: "Base fee of the CALL opcode"
        },
        callcode: {
          v: 0,
          d: "Base fee of the CALLCODE opcode"
        },
        delegatecall: {
          v: 0,
          d: "Base fee of the DELEGATECALL opcode"
        },
        staticcall: {
          v: 0,
          d: "Base fee of the STATICCALL opcode"
        },
        balance: {
          v: 0,
          d: "Base fee of the BALANCE opcode"
        },
        extcodesize: {
          v: 0,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 0,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        extcodehash: {
          v: 0,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        sload: {
          v: 0,
          d: "Base fee of the SLOAD opcode"
        },
        sstore: {
          v: 0,
          d: "Base fee of the SSTORE opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2930.json
var require__8 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2930.json"(exports, module) {
    module.exports = {
      name: "EIP-2930",
      comment: "Optional access lists",
      url: "https://eips.ethereum.org/EIPS/eip-2930",
      status: "Final",
      minimumHardfork: "istanbul",
      requiredEIPs: [2718, 2929],
      gasConfig: {},
      gasPrices: {
        accessListStorageKeyCost: {
          v: 1900,
          d: "Gas cost per storage key in an Access List transaction"
        },
        accessListAddressCost: {
          v: 2400,
          d: "Gas cost per storage key in an Access List transaction"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3074.json
var require__9 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3074.json"(exports, module) {
    module.exports = {
      name: "EIP-3074",
      number: 3074,
      comment: "AUTH and AUTHCALL opcodes",
      url: "https://eips.ethereum.org/EIPS/eip-3074",
      status: "Review",
      minimumHardfork: "london",
      gasConfig: {},
      gasPrices: {
        auth: {
          v: 3100,
          d: "Gas cost of the AUTH opcode"
        },
        authcall: {
          v: 0,
          d: "Gas cost of the AUTHCALL opcode"
        },
        authcallValueTransfer: {
          v: 6700,
          d: "Paid for CALL when the value transfer is non-zero"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3198.json
var require__10 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3198.json"(exports, module) {
    module.exports = {
      name: "EIP-3198",
      number: 3198,
      comment: "BASEFEE opcode",
      url: "https://eips.ethereum.org/EIPS/eip-3198",
      status: "Final",
      minimumHardfork: "london",
      gasConfig: {},
      gasPrices: {
        basefee: {
          v: 2,
          d: "Gas cost of the BASEFEE opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3529.json
var require__11 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3529.json"(exports, module) {
    module.exports = {
      name: "EIP-3529",
      comment: "Reduction in refunds",
      url: "https://eips.ethereum.org/EIPS/eip-3529",
      status: "Final",
      minimumHardfork: "berlin",
      requiredEIPs: [2929],
      gasConfig: {
        maxRefundQuotient: {
          v: 5,
          d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
      },
      gasPrices: {
        selfdestructRefund: {
          v: 0,
          d: "Refunded following a selfdestruct operation"
        },
        sstoreClearRefundEIP2200: {
          v: 4800,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3540.json
var require__12 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3540.json"(exports, module) {
    module.exports = {
      name: "EIP-3540",
      number: 3540,
      comment: "EVM Object Format (EOF) v1",
      url: "https://eips.ethereum.org/EIPS/eip-3540",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [3541],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3541.json
var require__13 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3541.json"(exports, module) {
    module.exports = {
      name: "EIP-3541",
      comment: "Reject new contracts starting with the 0xEF byte",
      url: "https://eips.ethereum.org/EIPS/eip-3541",
      status: "Final",
      minimumHardfork: "berlin",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3554.json
var require__14 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3554.json"(exports, module) {
    module.exports = {
      name: "EIP-3554",
      comment: "Reduction in refunds",
      url: "Difficulty Bomb Delay to December 1st 2021",
      status: "Final",
      minimumHardfork: "muirGlacier",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 95e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3607.json
var require__15 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3607.json"(exports, module) {
    module.exports = {
      name: "EIP-3607",
      number: 3607,
      comment: "Reject transactions from senders with deployed code",
      url: "https://eips.ethereum.org/EIPS/eip-3607",
      status: "Final",
      minimumHardfork: "chainstart",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3651.json
var require__16 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3651.json"(exports, module) {
    module.exports = {
      name: "EIP-3651",
      number: 3198,
      comment: "Warm COINBASE",
      url: "https://eips.ethereum.org/EIPS/eip-3651",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [2929],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3670.json
var require__17 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3670.json"(exports, module) {
    module.exports = {
      name: "EIP-3670",
      number: 3670,
      comment: "EOF - Code Validation",
      url: "https://eips.ethereum.org/EIPS/eip-3670",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [3540],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3675.json
var require__18 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3675.json"(exports, module) {
    module.exports = {
      name: "EIP-3675",
      number: 3675,
      comment: "Upgrade consensus to Proof-of-Stake",
      url: "https://eips.ethereum.org/EIPS/eip-3675",
      status: "Final",
      minimumHardfork: "london",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3855.json
var require__19 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3855.json"(exports, module) {
    module.exports = {
      name: "EIP-3855",
      number: 3855,
      comment: "PUSH0 instruction",
      url: "https://eips.ethereum.org/EIPS/eip-3855",
      status: "Review",
      minimumHardfork: "chainstart",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        push0: {
          v: 2,
          d: "Base fee of the PUSH0 opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3860.json
var require__20 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3860.json"(exports, module) {
    module.exports = {
      name: "EIP-3860",
      number: 3860,
      comment: "Limit and meter initcode",
      url: "https://eips.ethereum.org/EIPS/eip-3860",
      status: "Review",
      minimumHardfork: "spuriousDragon",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        initCodeWordCost: {
          v: 2,
          d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
        }
      },
      vm: {
        maxInitCodeSize: {
          v: 49152,
          d: "Maximum length of initialization code when creating a contract"
        }
      },
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/4345.json
var require__21 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/4345.json"(exports, module) {
    module.exports = {
      name: "EIP-4345",
      number: 4345,
      comment: "Difficulty Bomb Delay to June 2022",
      url: "https://eips.ethereum.org/EIPS/eip-4345",
      status: "Final",
      minimumHardfork: "london",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 107e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/4399.json
var require__22 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/4399.json"(exports, module) {
    module.exports = {
      name: "EIP-4399",
      number: 4399,
      comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
      url: "https://eips.ethereum.org/EIPS/eip-4399",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/4844.json
var require__23 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/4844.json"(exports, module) {
    module.exports = {
      name: "EIP-4844",
      number: 4844,
      comment: "Shard Blob Transactions",
      url: "https://eips.ethereum.org/EIPS/eip-4844",
      status: "Draft",
      minimumHardfork: "merge",
      requiredEIPs: [1559, 2718, 2930, 4895],
      gasConfig: {
        dataGasPerBlob: {
          v: 131072,
          d: "The base fee for data gas per blob"
        },
        targetDataGasPerBlock: {
          v: 262144,
          d: "The target data gas consumed per block"
        },
        maxDataGasPerBlock: {
          v: 524288,
          d: "The max data gas allowable per block"
        },
        dataGasPriceUpdateFraction: {
          v: 2225652,
          d: "The denominator used in the exponential when calculating a data gas price"
        }
      },
      gasPrices: {
        simpleGasPerBlob: {
          v: 12e3,
          d: "The basic gas fee for each blob"
        },
        minDataGasPrice: {
          v: 1,
          d: "The minimum fee per data gas"
        },
        kzgPointEvaluationGasPrecompilePrice: {
          v: 5e4,
          d: "The fee associated with the point evaluation precompile"
        },
        datahash: {
          v: 3,
          d: "Base fee of the DATAHASH opcode"
        }
      },
      sharding: {
        blobCommitmentVersionKzg: {
          v: 1,
          d: "The number indicated a versioned hash is a KZG commitment"
        },
        fieldElementsPerBlob: {
          v: 4096,
          d: "The number of field elements allowed per blob"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/4895.json
var require__24 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/4895.json"(exports, module) {
    module.exports = {
      name: "EIP-4895",
      number: 4895,
      comment: "Beacon chain push withdrawals as operations",
      url: "https://eips.ethereum.org/EIPS/eip-4895",
      status: "Review",
      minimumHardfork: "merge",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/5133.json
var require__25 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/5133.json"(exports, module) {
    module.exports = {
      name: "EIP-5133",
      number: 5133,
      comment: "Delaying Difficulty Bomb to mid-September 2022",
      url: "https://eips.ethereum.org/EIPS/eip-5133",
      status: "Draft",
      minimumHardfork: "grayGlacier",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 114e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/index.js
var require_eips = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EIPs = void 0;
    exports.EIPs = {
      1153: require__(),
      1559: require__2(),
      2315: require__3(),
      2537: require__4(),
      2565: require__5(),
      2718: require__6(),
      2929: require__7(),
      2930: require__8(),
      3074: require__9(),
      3198: require__10(),
      3529: require__11(),
      3540: require__12(),
      3541: require__13(),
      3554: require__14(),
      3607: require__15(),
      3651: require__16(),
      3670: require__17(),
      3675: require__18(),
      3855: require__19(),
      3860: require__20(),
      4345: require__21(),
      4399: require__22(),
      4844: require__23(),
      4895: require__24(),
      5133: require__25()
    };
  }
});

// node_modules/@ethereumjs/common/dist/enums.js
var require_enums = __commonJS({
  "node_modules/@ethereumjs/common/dist/enums.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CustomChain = exports.ConsensusAlgorithm = exports.ConsensusType = exports.Hardfork = exports.Chain = void 0;
    var Chain;
    (function(Chain2) {
      Chain2[Chain2["Mainnet"] = 1] = "Mainnet";
      Chain2[Chain2["Ropsten"] = 3] = "Ropsten";
      Chain2[Chain2["Rinkeby"] = 4] = "Rinkeby";
      Chain2[Chain2["Goerli"] = 5] = "Goerli";
      Chain2[Chain2["Sepolia"] = 11155111] = "Sepolia";
    })(Chain = exports.Chain || (exports.Chain = {}));
    var Hardfork;
    (function(Hardfork2) {
      Hardfork2["Chainstart"] = "chainstart";
      Hardfork2["Homestead"] = "homestead";
      Hardfork2["Dao"] = "dao";
      Hardfork2["TangerineWhistle"] = "tangerineWhistle";
      Hardfork2["SpuriousDragon"] = "spuriousDragon";
      Hardfork2["Byzantium"] = "byzantium";
      Hardfork2["Constantinople"] = "constantinople";
      Hardfork2["Petersburg"] = "petersburg";
      Hardfork2["Istanbul"] = "istanbul";
      Hardfork2["MuirGlacier"] = "muirGlacier";
      Hardfork2["Berlin"] = "berlin";
      Hardfork2["London"] = "london";
      Hardfork2["ArrowGlacier"] = "arrowGlacier";
      Hardfork2["GrayGlacier"] = "grayGlacier";
      Hardfork2["MergeForkIdTransition"] = "mergeForkIdTransition";
      Hardfork2["Merge"] = "merge";
      Hardfork2["Shanghai"] = "shanghai";
      Hardfork2["ShardingForkDev"] = "shardingFork";
    })(Hardfork = exports.Hardfork || (exports.Hardfork = {}));
    var ConsensusType;
    (function(ConsensusType2) {
      ConsensusType2["ProofOfStake"] = "pos";
      ConsensusType2["ProofOfWork"] = "pow";
      ConsensusType2["ProofOfAuthority"] = "poa";
    })(ConsensusType = exports.ConsensusType || (exports.ConsensusType = {}));
    var ConsensusAlgorithm;
    (function(ConsensusAlgorithm2) {
      ConsensusAlgorithm2["Ethash"] = "ethash";
      ConsensusAlgorithm2["Clique"] = "clique";
      ConsensusAlgorithm2["Casper"] = "casper";
    })(ConsensusAlgorithm = exports.ConsensusAlgorithm || (exports.ConsensusAlgorithm = {}));
    var CustomChain;
    (function(CustomChain2) {
      CustomChain2["PolygonMainnet"] = "polygon-mainnet";
      CustomChain2["PolygonMumbai"] = "polygon-mumbai";
      CustomChain2["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
      CustomChain2["ArbitrumOne"] = "arbitrum-one";
      CustomChain2["xDaiChain"] = "x-dai-chain";
      CustomChain2["OptimisticKovan"] = "optimistic-kovan";
      CustomChain2["OptimisticEthereum"] = "optimistic-ethereum";
    })(CustomChain = exports.CustomChain || (exports.CustomChain = {}));
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/chainstart.json
var require_chainstart = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/chainstart.json"(exports, module) {
    module.exports = {
      name: "chainstart",
      comment: "Start of the Ethereum main chain",
      url: "",
      status: "",
      gasConfig: {
        minGasLimit: {
          v: 5e3,
          d: "Minimum the gas limit may ever be"
        },
        gasLimitBoundDivisor: {
          v: 1024,
          d: "The bound divisor of the gas limit, used in update calculations"
        },
        maxRefundQuotient: {
          v: 2,
          d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
      },
      gasPrices: {
        base: {
          v: 2,
          d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
        },
        tierStep: {
          v: [0, 2, 3, 5, 8, 10, 20],
          d: "Once per operation, for a selection of them"
        },
        exp: {
          v: 10,
          d: "Base fee of the EXP opcode"
        },
        expByte: {
          v: 10,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        },
        sha3: {
          v: 30,
          d: "Base fee of the SHA3 opcode"
        },
        sha3Word: {
          v: 6,
          d: "Once per word of the SHA3 operation's data"
        },
        sload: {
          v: 50,
          d: "Base fee of the SLOAD opcode"
        },
        sstoreSet: {
          v: 2e4,
          d: "Once per SSTORE operation if the zeroness changes from zero"
        },
        sstoreReset: {
          v: 5e3,
          d: "Once per SSTORE operation if the zeroness does not change from zero"
        },
        sstoreRefund: {
          v: 15e3,
          d: "Once per SSTORE operation if the zeroness changes to zero"
        },
        jumpdest: {
          v: 1,
          d: "Base fee of the JUMPDEST opcode"
        },
        log: {
          v: 375,
          d: "Base fee of the LOG opcode"
        },
        logData: {
          v: 8,
          d: "Per byte in a LOG* operation's data"
        },
        logTopic: {
          v: 375,
          d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
        },
        create: {
          v: 32e3,
          d: "Base fee of the CREATE opcode"
        },
        call: {
          v: 40,
          d: "Base fee of the CALL opcode"
        },
        callStipend: {
          v: 2300,
          d: "Free gas given at beginning of call"
        },
        callValueTransfer: {
          v: 9e3,
          d: "Paid for CALL when the value transfor is non-zero"
        },
        callNewAccount: {
          v: 25e3,
          d: "Paid for CALL when the destination address didn't exist prior"
        },
        selfdestructRefund: {
          v: 24e3,
          d: "Refunded following a selfdestruct operation"
        },
        memory: {
          v: 3,
          d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
        },
        quadCoeffDiv: {
          v: 512,
          d: "Divisor for the quadratic particle of the memory cost equation"
        },
        createData: {
          v: 200,
          d: ""
        },
        tx: {
          v: 21e3,
          d: "Per transaction. NOTE: Not payable on data of calls between transactions"
        },
        txCreation: {
          v: 32e3,
          d: "The cost of creating a contract via tx"
        },
        txDataZero: {
          v: 4,
          d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
        },
        txDataNonZero: {
          v: 68,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        copy: {
          v: 3,
          d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
        },
        ecRecover: {
          v: 3e3,
          d: ""
        },
        sha256: {
          v: 60,
          d: ""
        },
        sha256Word: {
          v: 12,
          d: ""
        },
        ripemd160: {
          v: 600,
          d: ""
        },
        ripemd160Word: {
          v: 120,
          d: ""
        },
        identity: {
          v: 15,
          d: ""
        },
        identityWord: {
          v: 3,
          d: ""
        },
        stop: {
          v: 0,
          d: "Base fee of the STOP opcode"
        },
        add: {
          v: 3,
          d: "Base fee of the ADD opcode"
        },
        mul: {
          v: 5,
          d: "Base fee of the MUL opcode"
        },
        sub: {
          v: 3,
          d: "Base fee of the SUB opcode"
        },
        div: {
          v: 5,
          d: "Base fee of the DIV opcode"
        },
        sdiv: {
          v: 5,
          d: "Base fee of the SDIV opcode"
        },
        mod: {
          v: 5,
          d: "Base fee of the MOD opcode"
        },
        smod: {
          v: 5,
          d: "Base fee of the SMOD opcode"
        },
        addmod: {
          v: 8,
          d: "Base fee of the ADDMOD opcode"
        },
        mulmod: {
          v: 8,
          d: "Base fee of the MULMOD opcode"
        },
        signextend: {
          v: 5,
          d: "Base fee of the SIGNEXTEND opcode"
        },
        lt: {
          v: 3,
          d: "Base fee of the LT opcode"
        },
        gt: {
          v: 3,
          d: "Base fee of the GT opcode"
        },
        slt: {
          v: 3,
          d: "Base fee of the SLT opcode"
        },
        sgt: {
          v: 3,
          d: "Base fee of the SGT opcode"
        },
        eq: {
          v: 3,
          d: "Base fee of the EQ opcode"
        },
        iszero: {
          v: 3,
          d: "Base fee of the ISZERO opcode"
        },
        and: {
          v: 3,
          d: "Base fee of the AND opcode"
        },
        or: {
          v: 3,
          d: "Base fee of the OR opcode"
        },
        xor: {
          v: 3,
          d: "Base fee of the XOR opcode"
        },
        not: {
          v: 3,
          d: "Base fee of the NOT opcode"
        },
        byte: {
          v: 3,
          d: "Base fee of the BYTE opcode"
        },
        address: {
          v: 2,
          d: "Base fee of the ADDRESS opcode"
        },
        balance: {
          v: 20,
          d: "Base fee of the BALANCE opcode"
        },
        origin: {
          v: 2,
          d: "Base fee of the ORIGIN opcode"
        },
        caller: {
          v: 2,
          d: "Base fee of the CALLER opcode"
        },
        callvalue: {
          v: 2,
          d: "Base fee of the CALLVALUE opcode"
        },
        calldataload: {
          v: 3,
          d: "Base fee of the CALLDATALOAD opcode"
        },
        calldatasize: {
          v: 2,
          d: "Base fee of the CALLDATASIZE opcode"
        },
        calldatacopy: {
          v: 3,
          d: "Base fee of the CALLDATACOPY opcode"
        },
        codesize: {
          v: 2,
          d: "Base fee of the CODESIZE opcode"
        },
        codecopy: {
          v: 3,
          d: "Base fee of the CODECOPY opcode"
        },
        gasprice: {
          v: 2,
          d: "Base fee of the GASPRICE opcode"
        },
        extcodesize: {
          v: 20,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 20,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        blockhash: {
          v: 20,
          d: "Base fee of the BLOCKHASH opcode"
        },
        coinbase: {
          v: 2,
          d: "Base fee of the COINBASE opcode"
        },
        timestamp: {
          v: 2,
          d: "Base fee of the TIMESTAMP opcode"
        },
        number: {
          v: 2,
          d: "Base fee of the NUMBER opcode"
        },
        difficulty: {
          v: 2,
          d: "Base fee of the DIFFICULTY opcode"
        },
        gaslimit: {
          v: 2,
          d: "Base fee of the GASLIMIT opcode"
        },
        pop: {
          v: 2,
          d: "Base fee of the POP opcode"
        },
        mload: {
          v: 3,
          d: "Base fee of the MLOAD opcode"
        },
        mstore: {
          v: 3,
          d: "Base fee of the MSTORE opcode"
        },
        mstore8: {
          v: 3,
          d: "Base fee of the MSTORE8 opcode"
        },
        sstore: {
          v: 0,
          d: "Base fee of the SSTORE opcode"
        },
        jump: {
          v: 8,
          d: "Base fee of the JUMP opcode"
        },
        jumpi: {
          v: 10,
          d: "Base fee of the JUMPI opcode"
        },
        pc: {
          v: 2,
          d: "Base fee of the PC opcode"
        },
        msize: {
          v: 2,
          d: "Base fee of the MSIZE opcode"
        },
        gas: {
          v: 2,
          d: "Base fee of the GAS opcode"
        },
        push: {
          v: 3,
          d: "Base fee of the PUSH opcode"
        },
        dup: {
          v: 3,
          d: "Base fee of the DUP opcode"
        },
        swap: {
          v: 3,
          d: "Base fee of the SWAP opcode"
        },
        callcode: {
          v: 40,
          d: "Base fee of the CALLCODE opcode"
        },
        return: {
          v: 0,
          d: "Base fee of the RETURN opcode"
        },
        invalid: {
          v: 0,
          d: "Base fee of the INVALID opcode"
        },
        selfdestruct: {
          v: 0,
          d: "Base fee of the SELFDESTRUCT opcode"
        }
      },
      vm: {
        stackLimit: {
          v: 1024,
          d: "Maximum size of VM stack allowed"
        },
        callCreateDepth: {
          v: 1024,
          d: "Maximum depth of call/create stack"
        },
        maxExtraDataSize: {
          v: 32,
          d: "Maximum size extra data may be after Genesis"
        }
      },
      pow: {
        minimumDifficulty: {
          v: 131072,
          d: "The minimum that the difficulty may ever be"
        },
        difficultyBoundDivisor: {
          v: 2048,
          d: "The bound divisor of the difficulty, used in the update calculations"
        },
        durationLimit: {
          v: 13,
          d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
        },
        epochDuration: {
          v: 3e4,
          d: "Duration between proof-of-work epochs"
        },
        timebombPeriod: {
          v: 1e5,
          d: "Exponential difficulty timebomb period"
        },
        minerReward: {
          v: "5000000000000000000",
          d: "the amount a miner get rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 0,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/homestead.json
var require_homestead = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/homestead.json"(exports, module) {
    module.exports = {
      name: "homestead",
      comment: "Homestead hardfork with protocol and network changes",
      url: "https://eips.ethereum.org/EIPS/eip-606",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        delegatecall: {
          v: 40,
          d: "Base fee of the DELEGATECALL opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/dao.json
var require_dao = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/dao.json"(exports, module) {
    module.exports = {
      name: "dao",
      comment: "DAO rescue hardfork",
      url: "https://eips.ethereum.org/EIPS/eip-779",
      status: "Final",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/tangerineWhistle.json
var require_tangerineWhistle = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/tangerineWhistle.json"(exports, module) {
    module.exports = {
      name: "tangerineWhistle",
      comment: "Hardfork with gas cost changes for IO-heavy operations",
      url: "https://eips.ethereum.org/EIPS/eip-608",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        sload: {
          v: 200,
          d: "Once per SLOAD operation"
        },
        call: {
          v: 700,
          d: "Once per CALL operation & message call transaction"
        },
        extcodesize: {
          v: 700,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 700,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        balance: {
          v: 400,
          d: "Base fee of the BALANCE opcode"
        },
        delegatecall: {
          v: 700,
          d: "Base fee of the DELEGATECALL opcode"
        },
        callcode: {
          v: 700,
          d: "Base fee of the CALLCODE opcode"
        },
        selfdestruct: {
          v: 5e3,
          d: "Base fee of the SELFDESTRUCT opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/spuriousDragon.json
var require_spuriousDragon = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/spuriousDragon.json"(exports, module) {
    module.exports = {
      name: "spuriousDragon",
      comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
      url: "https://eips.ethereum.org/EIPS/eip-607",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        expByte: {
          v: 50,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        }
      },
      vm: {
        maxCodeSize: {
          v: 24576,
          d: "Maximum length of contract code"
        }
      },
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/byzantium.json
var require_byzantium = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/byzantium.json"(exports, module) {
    module.exports = {
      name: "byzantium",
      comment: "Hardfork with new precompiles, instructions and other protocol changes",
      url: "https://eips.ethereum.org/EIPS/eip-609",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        modexpGquaddivisor: {
          v: 20,
          d: "Gquaddivisor from modexp precompile for gas calculation"
        },
        ecAdd: {
          v: 500,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 4e4,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 1e5,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 8e4,
          d: "Gas costs regarding curve pairing precompile input length"
        },
        revert: {
          v: 0,
          d: "Base fee of the REVERT opcode"
        },
        staticcall: {
          v: 700,
          d: "Base fee of the STATICCALL opcode"
        },
        returndatasize: {
          v: 2,
          d: "Base fee of the RETURNDATASIZE opcode"
        },
        returndatacopy: {
          v: 3,
          d: "Base fee of the RETURNDATACOPY opcode"
        }
      },
      vm: {},
      pow: {
        minerReward: {
          v: "3000000000000000000",
          d: "the amount a miner get rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 3e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/constantinople.json
var require_constantinople = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/constantinople.json"(exports, module) {
    module.exports = {
      name: "constantinople",
      comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
      url: "https://eips.ethereum.org/EIPS/eip-1013",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {
          v: 200,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        netSstoreInitGas: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero"
        },
        netSstoreCleanGas: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero"
        },
        netSstoreDirtyGas: {
          v: 200,
          d: "Once per SSTORE operation from dirty"
        },
        netSstoreClearRefund: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        netSstoreResetRefund: {
          v: 4800,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        netSstoreResetClearRefund: {
          v: 19800,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        shl: {
          v: 3,
          d: "Base fee of the SHL opcode"
        },
        shr: {
          v: 3,
          d: "Base fee of the SHR opcode"
        },
        sar: {
          v: 3,
          d: "Base fee of the SAR opcode"
        },
        extcodehash: {
          v: 400,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        create2: {
          v: 32e3,
          d: "Base fee of the CREATE2 opcode"
        }
      },
      vm: {},
      pow: {
        minerReward: {
          v: "2000000000000000000",
          d: "The amount a miner gets rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 5e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/petersburg.json
var require_petersburg = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/petersburg.json"(exports, module) {
    module.exports = {
      name: "petersburg",
      comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
      url: "https://eips.ethereum.org/EIPS/eip-1716",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreInitGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreCleanGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreDirtyGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/istanbul.json
var require_istanbul = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/istanbul.json"(exports, module) {
    module.exports = {
      name: "istanbul",
      comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
      url: "https://eips.ethereum.org/EIPS/eip-1679",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        blake2Round: {
          v: 1,
          d: "Gas cost per round for the Blake2 F precompile"
        },
        ecAdd: {
          v: 150,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 6e3,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 45e3,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 34e3,
          d: "Gas costs regarding curve pairing precompile input length"
        },
        txDataNonZero: {
          v: 16,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        sstoreSentryGasEIP2200: {
          v: 2300,
          d: "Minimum gas required to be present for an SSTORE call, not consumed"
        },
        sstoreNoopGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if a dirty value is changed"
        },
        sstoreInitGasEIP2200: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero to non-zero"
        },
        sstoreInitRefundEIP2200: {
          v: 19200,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        sstoreCleanGasEIP2200: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero to something else"
        },
        sstoreCleanRefundEIP2200: {
          v: 4200,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        sstoreClearRefundEIP2200: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        balance: {
          v: 700,
          d: "Base fee of the BALANCE opcode"
        },
        extcodehash: {
          v: 700,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        chainid: {
          v: 2,
          d: "Base fee of the CHAINID opcode"
        },
        selfbalance: {
          v: 5,
          d: "Base fee of the SELFBALANCE opcode"
        },
        sload: {
          v: 800,
          d: "Base fee of the SLOAD opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/muirGlacier.json
var require_muirGlacier = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/muirGlacier.json"(exports, module) {
    module.exports = {
      name: "muirGlacier",
      comment: "HF to delay the difficulty bomb",
      url: "https://eips.ethereum.org/EIPS/eip-2384",
      status: "Final",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 9e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/berlin.json
var require_berlin = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/berlin.json"(exports, module) {
    module.exports = {
      name: "berlin",
      comment: "HF targeted for July 2020 following the Muir Glacier HF",
      url: "https://eips.ethereum.org/EIPS/eip-2070",
      status: "Final",
      eips: [2565, 2929, 2718, 2930]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/london.json
var require_london = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/london.json"(exports, module) {
    module.exports = {
      name: "london",
      comment: "HF targeted for July 2021 following the Berlin fork",
      url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
      status: "Final",
      eips: [1559, 3198, 3529, 3541]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/shanghai.json
var require_shanghai = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/shanghai.json"(exports, module) {
    module.exports = {
      name: "shanghai",
      comment: "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
      status: "Final",
      eips: [3651, 3855, 3860, 4895]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/arrowGlacier.json
var require_arrowGlacier = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/arrowGlacier.json"(exports, module) {
    module.exports = {
      name: "arrowGlacier",
      comment: "HF to delay the difficulty bomb",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
      status: "Final",
      eips: [4345],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/grayGlacier.json
var require_grayGlacier = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/grayGlacier.json"(exports, module) {
    module.exports = {
      name: "grayGlacier",
      comment: "Delaying the difficulty bomb to Mid September 2022",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
      status: "Draft",
      eips: [5133],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/mergeForkIdTransition.json
var require_mergeForkIdTransition = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/mergeForkIdTransition.json"(exports, module) {
    module.exports = {
      name: "mergeForkIdTransition",
      comment: "Pre-merge hardfork to fork off non-upgraded clients",
      url: "https://eips.ethereum.org/EIPS/eip-3675",
      status: "Draft",
      eips: []
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/merge.json
var require_merge = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/merge.json"(exports, module) {
    module.exports = {
      name: "merge",
      comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
      status: "Final",
      consensus: {
        type: "pos",
        algorithm: "casper",
        casper: {}
      },
      eips: [3675, 4399]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/sharding.json
var require_sharding = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/sharding.json"(exports, module) {
    module.exports = {
      name: "shardingFork",
      comment: "Internal hardfork to test proto-danksharding (do not use in production)",
      url: "https://eips.ethereum.org/EIPS/eip-4844",
      status: "Experimental",
      eips: [4844]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/index.js
var require_hardforks = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hardforks = void 0;
    exports.hardforks = {
      chainstart: require_chainstart(),
      homestead: require_homestead(),
      dao: require_dao(),
      tangerineWhistle: require_tangerineWhistle(),
      spuriousDragon: require_spuriousDragon(),
      byzantium: require_byzantium(),
      constantinople: require_constantinople(),
      petersburg: require_petersburg(),
      istanbul: require_istanbul(),
      muirGlacier: require_muirGlacier(),
      berlin: require_berlin(),
      london: require_london(),
      shanghai: require_shanghai(),
      arrowGlacier: require_arrowGlacier(),
      grayGlacier: require_grayGlacier(),
      mergeForkIdTransition: require_mergeForkIdTransition(),
      merge: require_merge(),
      shardingFork: require_sharding()
    };
  }
});

// node_modules/@ethereumjs/common/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@ethereumjs/common/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGethGenesis = void 0;
    var util_1 = require_dist2();
    var enums_1 = require_enums();
    function formatNonce(nonce) {
      if (!nonce || nonce === "0x0") {
        return "0x0000000000000000";
      }
      if ((0, util_1.isHexPrefixed)(nonce)) {
        return "0x" + (0, util_1.stripHexPrefix)(nonce).padStart(16, "0");
      }
      return "0x" + nonce.padStart(16, "0");
    }
    function parseGethParams(json, mergeForkIdPostMerge = true) {
      const { name, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas } = json;
      let { extraData, timestamp, nonce } = json;
      const genesisTimestamp = Number(timestamp);
      const { chainId } = config;
      if (extraData === "") {
        extraData = "0x";
      }
      if (!(0, util_1.isHexPrefixed)(timestamp)) {
        timestamp = (0, util_1.intToHex)(parseInt(timestamp));
      }
      if (nonce.length !== 18) {
        nonce = formatNonce(nonce);
      }
      if (config.eip155Block !== config.eip158Block) {
        throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
      }
      const params = {
        name,
        chainId,
        networkId: chainId,
        genesis: {
          timestamp,
          gasLimit: parseInt(gasLimit),
          difficulty: parseInt(difficulty),
          nonce,
          extraData,
          mixHash,
          coinbase,
          baseFeePerGas
        },
        hardfork: void 0,
        hardforks: [],
        bootstrapNodes: [],
        consensus: config.clique !== void 0 ? {
          type: "poa",
          algorithm: "clique",
          clique: {
            period: config.clique.period ?? config.clique.blockperiodseconds,
            epoch: config.clique.epoch ?? config.clique.epochlength
          }
        } : {
          type: "pow",
          algorithm: "ethash",
          ethash: {}
        }
      };
      const forkMap = {
        [enums_1.Hardfork.Homestead]: { name: "homesteadBlock" },
        [enums_1.Hardfork.Dao]: { name: "daoForkBlock" },
        [enums_1.Hardfork.TangerineWhistle]: { name: "eip150Block" },
        [enums_1.Hardfork.SpuriousDragon]: { name: "eip155Block" },
        [enums_1.Hardfork.Byzantium]: { name: "byzantiumBlock" },
        [enums_1.Hardfork.Constantinople]: { name: "constantinopleBlock" },
        [enums_1.Hardfork.Petersburg]: { name: "petersburgBlock" },
        [enums_1.Hardfork.Istanbul]: { name: "istanbulBlock" },
        [enums_1.Hardfork.MuirGlacier]: { name: "muirGlacierBlock" },
        [enums_1.Hardfork.Berlin]: { name: "berlinBlock" },
        [enums_1.Hardfork.London]: { name: "londonBlock" },
        [enums_1.Hardfork.MergeForkIdTransition]: { name: "mergeForkBlock", postMerge: mergeForkIdPostMerge },
        [enums_1.Hardfork.Shanghai]: { name: "shanghaiTime", postMerge: true, isTimestamp: true },
        [enums_1.Hardfork.ShardingForkDev]: { name: "shardingForkTime", postMerge: true, isTimestamp: true }
      };
      const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {
        acc[forkMap[elem].name] = elem;
        return acc;
      }, {});
      const configHardforkNames = Object.keys(config).filter((key) => forkMapRev[key] !== void 0 && config[key] !== void 0 && config[key] !== null);
      params.hardforks = configHardforkNames.map((nameBlock) => ({
        name: forkMapRev[nameBlock],
        block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== "number" ? null : config[nameBlock],
        timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === "number" ? config[nameBlock] : void 0
      })).filter((fork) => fork.block !== null || fork.timestamp !== void 0);
      params.hardforks.sort(function(a, b) {
        return (a.block ?? Infinity) - (b.block ?? Infinity);
      });
      params.hardforks.sort(function(a, b) {
        return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp);
      });
      if (config.terminalTotalDifficulty !== void 0) {
        const mergeConfig = {
          name: enums_1.Hardfork.Merge,
          ttd: config.terminalTotalDifficulty,
          block: null
        };
        const postMergeIndex = params.hardforks.findIndex((hf) => forkMap[hf.name]?.postMerge === true);
        if (postMergeIndex !== -1) {
          params.hardforks.splice(postMergeIndex, 0, mergeConfig);
        } else {
          params.hardforks.push(mergeConfig);
        }
      }
      const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : void 0;
      params.hardfork = latestHardfork?.name;
      params.hardforks.unshift({ name: enums_1.Hardfork.Chainstart, block: 0 });
      return params;
    }
    function parseGethGenesis(json, name, mergeForkIdPostMerge) {
      try {
        if (["config", "difficulty", "gasLimit", "alloc"].some((field) => !(field in json))) {
          throw new Error("Invalid format, expected geth genesis fields missing");
        }
        if (name !== void 0) {
          json.name = name;
        }
        return parseGethParams(json, mergeForkIdPostMerge);
      } catch (e) {
        throw new Error(`Error parsing parameters file: ${e.message}`);
      }
    }
    exports.parseGethGenesis = parseGethGenesis;
  }
});

// node_modules/@ethereumjs/common/dist/common.js
var require_common = __commonJS({
  "node_modules/@ethereumjs/common/dist/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Common = void 0;
    var util_1 = require_dist2();
    var crc_32_1 = require_crc32();
    var events_1 = require_events();
    var goerli = require_goerli();
    var mainnet = require_mainnet();
    var rinkeby = require_rinkeby();
    var ropsten = require_ropsten();
    var sepolia = require_sepolia();
    var eips_1 = require_eips();
    var enums_1 = require_enums();
    var hardforks_1 = require_hardforks();
    var utils_1 = require_utils();
    var Common = class extends events_1.EventEmitter {
      constructor(opts) {
        super();
        this._eips = [];
        this._customChains = opts.customChains ?? [];
        this._chainParams = this.setChain(opts.chain);
        this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? enums_1.Hardfork.Merge;
        this.HARDFORK_CHANGES = this.hardforks().map((hf) => [
          hf.name,
          hardforks_1.hardforks[hf.name]
        ]);
        this._hardfork = this.DEFAULT_HARDFORK;
        if (opts.hardfork !== void 0) {
          this.setHardfork(opts.hardfork);
        }
        if (opts.eips) {
          this.setEIPs(opts.eips);
        }
      }
      static custom(chainParamsOrName, opts = {}) {
        const baseChain = opts.baseChain ?? "mainnet";
        const standardChainParams = { ...Common._getChainParams(baseChain) };
        standardChainParams["name"] = "custom-chain";
        if (typeof chainParamsOrName !== "string") {
          return new Common({
            chain: {
              ...standardChainParams,
              ...chainParamsOrName
            },
            ...opts
          });
        } else {
          if (chainParamsOrName === enums_1.CustomChain.PolygonMainnet) {
            return Common.custom({
              name: enums_1.CustomChain.PolygonMainnet,
              chainId: 137,
              networkId: 137
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.PolygonMumbai) {
            return Common.custom({
              name: enums_1.CustomChain.PolygonMumbai,
              chainId: 80001,
              networkId: 80001
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.ArbitrumRinkebyTestnet) {
            return Common.custom({
              name: enums_1.CustomChain.ArbitrumRinkebyTestnet,
              chainId: 421611,
              networkId: 421611
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.ArbitrumOne) {
            return Common.custom({
              name: enums_1.CustomChain.ArbitrumOne,
              chainId: 42161,
              networkId: 42161
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.xDaiChain) {
            return Common.custom({
              name: enums_1.CustomChain.xDaiChain,
              chainId: 100,
              networkId: 100
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.OptimisticKovan) {
            return Common.custom(
              {
                name: enums_1.CustomChain.OptimisticKovan,
                chainId: 69,
                networkId: 69
              },
              { hardfork: enums_1.Hardfork.Berlin, ...opts }
            );
          }
          if (chainParamsOrName === enums_1.CustomChain.OptimisticEthereum) {
            return Common.custom(
              {
                name: enums_1.CustomChain.OptimisticEthereum,
                chainId: 10,
                networkId: 10
              },
              { hardfork: enums_1.Hardfork.Berlin, ...opts }
            );
          }
          throw new Error(`Custom chain ${chainParamsOrName} not supported`);
        }
      }
      static fromGethGenesis(genesisJson, { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }) {
        const genesisParams = (0, utils_1.parseGethGenesis)(genesisJson, chain, mergeForkIdPostMerge);
        const common = new Common({
          chain: genesisParams.name ?? "custom",
          customChains: [genesisParams],
          eips,
          hardfork: hardfork ?? genesisParams.hardfork
        });
        if (genesisHash !== void 0) {
          common.setForkHashes(genesisHash);
        }
        return common;
      }
      static isSupportedChainId(chainId) {
        const initializedChains = this._getInitializedChains();
        return Boolean(initializedChains["names"][chainId.toString()]);
      }
      static _getChainParams(chain, customChains) {
        const initializedChains = this._getInitializedChains(customChains);
        if (typeof chain === "number" || typeof chain === "bigint") {
          chain = chain.toString();
          if (initializedChains["names"][chain]) {
            const name = initializedChains["names"][chain];
            return initializedChains[name];
          }
          throw new Error(`Chain with ID ${chain} not supported`);
        }
        if (initializedChains[chain] !== void 0) {
          return initializedChains[chain];
        }
        throw new Error(`Chain with name ${chain} not supported`);
      }
      setChain(chain) {
        if (typeof chain === "number" || typeof chain === "bigint" || typeof chain === "string") {
          this._chainParams = Common._getChainParams(chain, this._customChains);
        } else if (typeof chain === "object") {
          if (this._customChains.length > 0) {
            throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
          }
          const required = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
          for (const param of required) {
            if (!(param in chain)) {
              throw new Error(`Missing required chain parameter: ${param}`);
            }
          }
          this._chainParams = chain;
        } else {
          throw new Error("Wrong input format");
        }
        for (const hf of this.hardforks()) {
          if (hf.block === void 0) {
            throw new Error(`Hardfork cannot have undefined block number`);
          }
        }
        return this._chainParams;
      }
      setHardfork(hardfork) {
        let existing = false;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if (hfChanges[0] === hardfork) {
            if (this._hardfork !== hardfork) {
              this._hardfork = hardfork;
              this.emit("hardforkChanged", hardfork);
            }
            existing = true;
          }
        }
        if (!existing) {
          throw new Error(`Hardfork with name ${hardfork} not supported`);
        }
      }
      getHardforkByBlockNumber(blockNumber, td, timestamp) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        td = (0, util_1.toType)(td, util_1.TypeOutput.BigInt);
        timestamp = (0, util_1.toType)(timestamp, util_1.TypeOutput.Number);
        const hfs = this.hardforks().filter((hf) => hf.block !== null || hf.ttd !== null && hf.ttd !== void 0 || hf.timestamp !== void 0);
        const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
        const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
        if (doubleTTDHF >= 0) {
          throw Error(`More than one merge hardforks found with ttd specified`);
        }
        let hfIndex = hfs.findIndex((hf) => hf.block !== null && hf.block > blockNumber || timestamp !== void 0 && Number(hf.timestamp) > timestamp);
        if (hfIndex === -1) {
          hfIndex = hfs.length;
        } else if (hfIndex === 0) {
          throw Error("Must have at least one hardfork at block 0");
        }
        if (timestamp === void 0) {
          const stepBack = hfs.slice(0, hfIndex).reverse().findIndex((hf) => hf.block !== null || hf.ttd !== void 0);
          hfIndex = hfIndex - stepBack;
        }
        hfIndex = hfIndex - 1;
        if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === void 0) {
          if (td === void 0 || td === null || BigInt(hfs[hfIndex].ttd) > td) {
            hfIndex -= 1;
          }
        } else {
          if (mergeIndex >= 0 && td !== void 0 && td !== null) {
            if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {
              throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
            } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {
              throw Error("HF determined by block number is lower than the minimum total difficulty HF");
            }
          }
        }
        const hfStartIndex = hfIndex;
        for (; hfIndex < hfs.length - 1; hfIndex++) {
          if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {
            break;
          }
        }
        if (timestamp) {
          const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => Math.max(Number(hf.timestamp ?? "0"), acc), 0);
          if (minTimeStamp > timestamp) {
            throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);
          }
          const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), timestamp);
          if (maxTimeStamp < timestamp) {
            throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);
          }
        }
        const hardfork = hfs[hfIndex];
        return hardfork.name;
      }
      setHardforkByBlockNumber(blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        this.setHardfork(hardfork);
        return hardfork;
      }
      _getHardfork(hardfork) {
        const hfs = this.hardforks();
        for (const hf of hfs) {
          if (hf["name"] === hardfork)
            return hf;
        }
        return null;
      }
      setEIPs(eips = []) {
        for (const eip of eips) {
          if (!(eip in eips_1.EIPs)) {
            throw new Error(`${eip} not supported`);
          }
          const minHF = this.gteHardfork(eips_1.EIPs[eip]["minimumHardfork"]);
          if (!minHF) {
            throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);
          }
          if (eips_1.EIPs[eip].requiredEIPs !== void 0) {
            for (const elem of eips_1.EIPs[eip].requiredEIPs) {
              if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {
                throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);
              }
            }
          }
        }
        this._eips = eips;
      }
      param(topic, name) {
        let value;
        for (const eip of this._eips) {
          value = this.paramByEIP(topic, name, eip);
          if (value !== void 0)
            return value;
        }
        return this.paramByHardfork(topic, name, this._hardfork);
      }
      paramByHardfork(topic, name, hardfork) {
        let value = null;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("eips" in hfChanges[1]) {
            const hfEIPs = hfChanges[1]["eips"];
            for (const eip of hfEIPs) {
              const valueEIP = this.paramByEIP(topic, name, eip);
              value = typeof valueEIP === "bigint" ? valueEIP : value;
            }
          } else {
            if (hfChanges[1][topic] === void 0) {
              throw new Error(`Topic ${topic} not defined`);
            }
            if (hfChanges[1][topic][name] !== void 0) {
              value = hfChanges[1][topic][name].v;
            }
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return BigInt(value ?? 0);
      }
      paramByEIP(topic, name, eip) {
        if (!(eip in eips_1.EIPs)) {
          throw new Error(`${eip} not supported`);
        }
        const eipParams = eips_1.EIPs[eip];
        if (!(topic in eipParams)) {
          throw new Error(`Topic ${topic} not defined`);
        }
        if (eipParams[topic][name] === void 0) {
          return void 0;
        }
        const value = eipParams[topic][name].v;
        return BigInt(value);
      }
      paramByBlock(topic, name, blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        return this.paramByHardfork(topic, name, hardfork);
      }
      isActivatedEIP(eip) {
        if (this.eips().includes(eip)) {
          return true;
        }
        for (const hfChanges of this.HARDFORK_CHANGES) {
          const hf = hfChanges[1];
          if (this.gteHardfork(hf["name"]) && "eips" in hf) {
            if (hf["eips"].includes(eip)) {
              return true;
            }
          }
        }
        return false;
      }
      hardforkIsActiveOnBlock(hardfork, blockNumber) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const hfBlock = this.hardforkBlock(hardfork);
        if (typeof hfBlock === "bigint" && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {
          return true;
        }
        return false;
      }
      activeOnBlock(blockNumber) {
        return this.hardforkIsActiveOnBlock(null, blockNumber);
      }
      hardforkGteHardfork(hardfork1, hardfork2) {
        hardfork1 = hardfork1 ?? this._hardfork;
        const hardforks = this.hardforks();
        let posHf1 = -1, posHf2 = -1;
        let index = 0;
        for (const hf of hardforks) {
          if (hf["name"] === hardfork1)
            posHf1 = index;
          if (hf["name"] === hardfork2)
            posHf2 = index;
          index += 1;
        }
        return posHf1 >= posHf2 && posHf2 !== -1;
      }
      gteHardfork(hardfork) {
        return this.hardforkGteHardfork(null, hardfork);
      }
      hardforkBlock(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const block = this._getHardfork(hardfork)?.["block"];
        if (block === void 0 || block === null) {
          return null;
        }
        return BigInt(block);
      }
      hardforkTimestamp(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const timestamp = this._getHardfork(hardfork)?.["timestamp"];
        if (timestamp === void 0 || timestamp === null) {
          return null;
        }
        return BigInt(timestamp);
      }
      eipBlock(eip) {
        for (const hfChanges of this.HARDFORK_CHANGES) {
          const hf = hfChanges[1];
          if ("eips" in hf) {
            if (hf["eips"].includes(eip)) {
              return this.hardforkBlock(hfChanges[0]);
            }
          }
        }
        return null;
      }
      hardforkTTD(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const ttd = this._getHardfork(hardfork)?.["ttd"];
        if (ttd === void 0 || ttd === null) {
          return null;
        }
        return BigInt(ttd);
      }
      isHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const block = this.hardforkBlock(hardfork);
        return typeof block === "bigint" && block !== BigInt(0) ? block === blockNumber : false;
      }
      nextHardforkBlockOrTimestamp(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const hfs = this.hardforks();
        let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);
        if (hardfork === enums_1.Hardfork.Merge) {
          hfIndex -= 1;
        }
        if (hfIndex < 0) {
          return null;
        }
        let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;
        currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== void 0 ? Number(currHfTimeOrBlock) : null;
        const nextHf = hfs.slice(hfIndex + 1).find((hf) => {
          let hfTimeOrBlock = hf.timestamp ?? hf.block;
          hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 ? Number(hfTimeOrBlock) : null;
          return hf.name !== enums_1.Hardfork.Merge && hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 && hfTimeOrBlock !== currHfTimeOrBlock;
        });
        if (nextHf === void 0) {
          return null;
        }
        const nextHfBlock = nextHf.timestamp ?? nextHf.block;
        if (nextHfBlock === null || nextHfBlock === void 0) {
          return null;
        }
        return BigInt(nextHfBlock);
      }
      nextHardforkBlock(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        let hfBlock = this.hardforkBlock(hardfork);
        if (hfBlock === null && hardfork === enums_1.Hardfork.Merge) {
          const hfs = this.hardforks();
          const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
          if (mergeIndex < 0) {
            throw Error(`Merge hardfork should have been found`);
          }
          hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);
        }
        if (hfBlock === null) {
          return null;
        }
        const nextHfBlock = this.hardforks().reduce((acc, hf) => {
          const block = BigInt(hf.block === null || hf.ttd !== void 0 && hf.ttd !== null ? 0 : hf.block);
          return block > hfBlock && acc === null ? block : acc;
        }, null);
        return nextHfBlock;
      }
      isNextHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const nextHardforkBlock = this.nextHardforkBlock(hardfork);
        return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;
      }
      _calcForkHash(hardfork, genesisHash) {
        let hfBuffer = Buffer.alloc(0);
        let prevBlockOrTime = 0;
        for (const hf of this.hardforks()) {
          const { block, timestamp, name } = hf;
          let blockOrTime = timestamp ?? block;
          blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;
          if (typeof blockOrTime === "number" && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== enums_1.Hardfork.Merge) {
            const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, "0"), "hex");
            hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer]);
            prevBlockOrTime = blockOrTime;
          }
          if (hf.name === hardfork)
            break;
        }
        const inputBuffer = Buffer.concat([genesisHash, hfBuffer]);
        const forkhash = (0, util_1.intToBuffer)((0, crc_32_1.buf)(inputBuffer) >>> 0).toString("hex");
        return `0x${forkhash}`;
      }
      forkHash(hardfork, genesisHash) {
        hardfork = hardfork ?? this._hardfork;
        const data = this._getHardfork(hardfork);
        if (data === null || data?.block === null && data?.timestamp === void 0 && data?.ttd === void 0) {
          const msg = "No fork hash calculation possible for future hardfork";
          throw new Error(msg);
        }
        if (data?.forkHash !== null && data?.forkHash !== void 0) {
          return data.forkHash;
        }
        if (!genesisHash)
          throw new Error("genesisHash required for forkHash calculation");
        return this._calcForkHash(hardfork, genesisHash);
      }
      hardforkForForkHash(forkHash) {
        const resArray = this.hardforks().filter((hf) => {
          return hf.forkHash === forkHash;
        });
        return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
      }
      setForkHashes(genesisHash) {
        for (const hf of this.hardforks()) {
          const blockOrTime = hf.timestamp ?? hf.block;
          if ((hf.forkHash === null || hf.forkHash === void 0) && (blockOrTime !== null && blockOrTime !== void 0 || typeof hf.ttd !== "undefined")) {
            hf.forkHash = this.forkHash(hf.name, genesisHash);
          }
        }
      }
      genesis() {
        return this._chainParams.genesis;
      }
      hardforks() {
        return this._chainParams.hardforks;
      }
      bootstrapNodes() {
        return this._chainParams.bootstrapNodes;
      }
      dnsNetworks() {
        return this._chainParams.dnsNetworks;
      }
      hardfork() {
        return this._hardfork;
      }
      chainId() {
        return BigInt(this._chainParams.chainId);
      }
      chainName() {
        return this._chainParams.name;
      }
      networkId() {
        return BigInt(this._chainParams.networkId);
      }
      eips() {
        return this._eips;
      }
      consensusType() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("consensus" in hfChanges[1]) {
            value = hfChanges[1]["consensus"]["type"];
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return value ?? this._chainParams["consensus"]["type"];
      }
      consensusAlgorithm() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("consensus" in hfChanges[1]) {
            value = hfChanges[1]["consensus"]["algorithm"];
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return value ?? this._chainParams["consensus"]["algorithm"];
      }
      consensusConfig() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("consensus" in hfChanges[1]) {
            value = hfChanges[1]["consensus"][hfChanges[1]["consensus"]["algorithm"]];
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return value ?? this._chainParams["consensus"][this.consensusAlgorithm()] ?? {};
      }
      copy() {
        const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
        copy.removeAllListeners();
        return copy;
      }
      static _getInitializedChains(customChains) {
        const names = {};
        for (const [name, id] of Object.entries(enums_1.Chain)) {
          names[id] = name.toLowerCase();
        }
        const chains = { mainnet, ropsten, rinkeby, goerli, sepolia };
        if (customChains) {
          for (const chain of customChains) {
            const { name } = chain;
            names[chain.chainId.toString()] = name;
            chains[name] = chain;
          }
        }
        chains.names = names;
        return chains;
      }
    };
    exports.Common = Common;
  }
});

// node_modules/@ethereumjs/common/dist/types.js
var require_types = __commonJS({
  "node_modules/@ethereumjs/common/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ethereumjs/common/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@ethereumjs/common/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_common(), exports);
    __exportStar(require_enums(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_utils(), exports);
  }
});

// node_modules/@ethereumjs/tx/dist/types.js
var require_types2 = __commonJS({
  "node_modules/@ethereumjs/tx/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAccessList = exports.isAccessListBuffer = exports.Capability = void 0;
    var Capability;
    (function(Capability2) {
      Capability2[Capability2["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
      Capability2[Capability2["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
      Capability2[Capability2["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
      Capability2[Capability2["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
    })(Capability = exports.Capability || (exports.Capability = {}));
    function isAccessListBuffer(input) {
      if (input.length === 0) {
        return true;
      }
      const firstItem = input[0];
      if (Array.isArray(firstItem)) {
        return true;
      }
      return false;
    }
    exports.isAccessListBuffer = isAccessListBuffer;
    function isAccessList(input) {
      return !isAccessListBuffer(input);
    }
    exports.isAccessList = isAccessList;
  }
});

// node_modules/@ethereumjs/tx/dist/util.js
var require_util = __commonJS({
  "node_modules/@ethereumjs/tx/dist/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccessLists = exports.checkMaxInitCodeSize = void 0;
    var util_1 = require_dist2();
    var types_1 = require_types2();
    function checkMaxInitCodeSize(common, length) {
      const maxInitCodeSize = common.param("vm", "maxInitCodeSize");
      if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
        throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param("vm", "maxInitCodeSize")}`);
      }
    }
    exports.checkMaxInitCodeSize = checkMaxInitCodeSize;
    var AccessLists = class {
      static getAccessListData(accessList) {
        let AccessListJSON;
        let bufferAccessList;
        if ((0, types_1.isAccessList)(accessList)) {
          AccessListJSON = accessList;
          const newAccessList = [];
          for (let i = 0; i < accessList.length; i++) {
            const item = accessList[i];
            const addressBuffer = (0, util_1.toBuffer)(item.address);
            const storageItems = [];
            for (let index = 0; index < item.storageKeys.length; index++) {
              storageItems.push((0, util_1.toBuffer)(item.storageKeys[index]));
            }
            newAccessList.push([addressBuffer, storageItems]);
          }
          bufferAccessList = newAccessList;
        } else {
          bufferAccessList = accessList ?? [];
          const json = [];
          for (let i = 0; i < bufferAccessList.length; i++) {
            const data = bufferAccessList[i];
            const address = (0, util_1.bufferToHex)(data[0]);
            const storageKeys = [];
            for (let item = 0; item < data[1].length; item++) {
              storageKeys.push((0, util_1.bufferToHex)(data[1][item]));
            }
            const jsonItem = {
              address,
              storageKeys
            };
            json.push(jsonItem);
          }
          AccessListJSON = json;
        }
        return {
          AccessListJSON,
          accessList: bufferAccessList
        };
      }
      static verifyAccessList(accessList) {
        for (let key = 0; key < accessList.length; key++) {
          const accessListItem = accessList[key];
          const address = accessListItem[0];
          const storageSlots = accessListItem[1];
          if (accessListItem[2] !== void 0) {
            throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
          }
          if (address.length !== 20) {
            throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
          }
          for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {
            if (storageSlots[storageSlot].length !== 32) {
              throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes");
            }
          }
        }
      }
      static getAccessListJSON(accessList) {
        const accessListJSON = [];
        for (let index = 0; index < accessList.length; index++) {
          const item = accessList[index];
          const JSONItem = {
            address: "0x" + (0, util_1.setLengthLeft)(item[0], 20).toString("hex"),
            storageKeys: []
          };
          const storageSlots = item[1];
          for (let slot = 0; slot < storageSlots.length; slot++) {
            const storageSlot = storageSlots[slot];
            JSONItem.storageKeys.push("0x" + (0, util_1.setLengthLeft)(storageSlot, 32).toString("hex"));
          }
          accessListJSON.push(JSONItem);
        }
        return accessListJSON;
      }
      static getDataFeeEIP2930(accessList, common) {
        const accessListStorageKeyCost = common.param("gasPrices", "accessListStorageKeyCost");
        const accessListAddressCost = common.param("gasPrices", "accessListAddressCost");
        let slots = 0;
        for (let index = 0; index < accessList.length; index++) {
          const item = accessList[index];
          const storageSlots = item[1];
          slots += storageSlots.length;
        }
        const addresses = accessList.length;
        return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
      }
    };
    exports.AccessLists = AccessLists;
  }
});

// node_modules/@ethereumjs/tx/dist/baseTransaction.js
var require_baseTransaction = __commonJS({
  "node_modules/@ethereumjs/tx/dist/baseTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseTransaction = void 0;
    var common_1 = require_dist3();
    var util_1 = require_dist2();
    var types_1 = require_types2();
    var util_2 = require_util();
    var BaseTransaction = class {
      constructor(txData, opts) {
        this.cache = {
          hash: void 0,
          dataFee: void 0
        };
        this.activeCapabilities = [];
        this.DEFAULT_CHAIN = common_1.Chain.Mainnet;
        this.DEFAULT_HARDFORK = common_1.Hardfork.Merge;
        const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
        this._type = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(type)));
        this.txOptions = opts;
        const toB = (0, util_1.toBuffer)(to === "" ? "0x" : to);
        const vB = (0, util_1.toBuffer)(v === "" ? "0x" : v);
        const rB = (0, util_1.toBuffer)(r === "" ? "0x" : r);
        const sB = (0, util_1.toBuffer)(s === "" ? "0x" : s);
        this.nonce = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(nonce === "" ? "0x" : nonce));
        this.gasLimit = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasLimit === "" ? "0x" : gasLimit));
        this.to = toB.length > 0 ? new util_1.Address(toB) : void 0;
        this.value = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(value === "" ? "0x" : value));
        this.data = (0, util_1.toBuffer)(data === "" ? "0x" : data);
        this.v = vB.length > 0 ? (0, util_1.bufferToBigInt)(vB) : void 0;
        this.r = rB.length > 0 ? (0, util_1.bufferToBigInt)(rB) : void 0;
        this.s = sB.length > 0 ? (0, util_1.bufferToBigInt)(sB) : void 0;
        this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
        this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
        this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
        const createContract = this.to === void 0 || this.to === null;
        const allowUnlimitedInitCodeSize = opts.allowUnlimitedInitCodeSize ?? false;
        const common = opts.common ?? this._getCommon();
        if (createContract && common.isActivatedEIP(3860) && allowUnlimitedInitCodeSize === false) {
          (0, util_2.checkMaxInitCodeSize)(common, this.data.length);
        }
      }
      get type() {
        return this._type;
      }
      supports(capability) {
        return this.activeCapabilities.includes(capability);
      }
      validate(stringError = false) {
        const errors = [];
        if (this.getBaseFee() > this.gasLimit) {
          errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
        }
        if (this.isSigned() && !this.verifySignature()) {
          errors.push("Invalid Signature");
        }
        return stringError ? errors : errors.length === 0;
      }
      _validateYParity() {
        const { v } = this;
        if (v !== void 0 && v !== BigInt(0) && v !== BigInt(1)) {
          const msg = this._errorMsg("The y-parity of the transaction should either be 0 or 1");
          throw new Error(msg);
        }
      }
      _validateHighS() {
        const { s } = this;
        if (this.common.gteHardfork("homestead") && s !== void 0 && s > util_1.SECP256K1_ORDER_DIV_2) {
          const msg = this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
          throw new Error(msg);
        }
      }
      getBaseFee() {
        const txFee = this.common.param("gasPrices", "tx");
        let fee = this.getDataFee();
        if (txFee)
          fee += txFee;
        if (this.common.gteHardfork("homestead") && this.toCreationAddress()) {
          const txCreationFee = this.common.param("gasPrices", "txCreation");
          if (txCreationFee)
            fee += txCreationFee;
        }
        return fee;
      }
      getDataFee() {
        const txDataZero = this.common.param("gasPrices", "txDataZero");
        const txDataNonZero = this.common.param("gasPrices", "txDataNonZero");
        let cost = BigInt(0);
        for (let i = 0; i < this.data.length; i++) {
          this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;
        }
        if ((this.to === void 0 || this.to === null) && this.common.isActivatedEIP(3860)) {
          const dataLength = BigInt(Math.ceil(this.data.length / 32));
          const initCodeCost = this.common.param("gasPrices", "initCodeWordCost") * dataLength;
          cost += initCodeCost;
        }
        return cost;
      }
      toCreationAddress() {
        return this.to === void 0 || this.to.buf.length === 0;
      }
      isSigned() {
        const { v, r, s } = this;
        if (v === void 0 || r === void 0 || s === void 0) {
          return false;
        } else {
          return true;
        }
      }
      verifySignature() {
        try {
          const publicKey = this.getSenderPublicKey();
          return (0, util_1.unpadBuffer)(publicKey).length !== 0;
        } catch (e) {
          return false;
        }
      }
      getSenderAddress() {
        return new util_1.Address((0, util_1.publicToAddress)(this.getSenderPublicKey()));
      }
      sign(privateKey) {
        if (privateKey.length !== 32) {
          const msg = this._errorMsg("Private key must be 32 bytes in length.");
          throw new Error(msg);
        }
        let hackApplied = false;
        if (this.type === 0 && this.common.gteHardfork("spuriousDragon") && !this.supports(types_1.Capability.EIP155ReplayProtection)) {
          this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
          hackApplied = true;
        }
        const msgHash = this.getMessageToSign(true);
        const { v, r, s } = (0, util_1.ecsign)(msgHash, privateKey);
        const tx = this._processSignature(v, r, s);
        if (hackApplied) {
          const index = this.activeCapabilities.indexOf(types_1.Capability.EIP155ReplayProtection);
          if (index > -1) {
            this.activeCapabilities.splice(index, 1);
          }
        }
        return tx;
      }
      _getCommon(common, chainId) {
        if (chainId !== void 0) {
          const chainIdBigInt = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(chainId));
          if (common) {
            if (common.chainId() !== chainIdBigInt) {
              const msg = this._errorMsg("The chain ID does not match the chain ID of Common");
              throw new Error(msg);
            }
            return common.copy();
          } else {
            if (common_1.Common.isSupportedChainId(chainIdBigInt)) {
              return new common_1.Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK });
            } else {
              return common_1.Common.custom({
                name: "custom-chain",
                networkId: chainIdBigInt,
                chainId: chainIdBigInt
              }, { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
            }
          }
        } else {
          return common?.copy() ?? new common_1.Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
        }
      }
      _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
        for (const [key, value] of Object.entries(values)) {
          switch (bits) {
            case 64:
              if (cannotEqual) {
                if (value !== void 0 && value >= util_1.MAX_UINT64) {
                  const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
                  throw new Error(msg);
                }
              } else {
                if (value !== void 0 && value > util_1.MAX_UINT64) {
                  const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
                  throw new Error(msg);
                }
              }
              break;
            case 256:
              if (cannotEqual) {
                if (value !== void 0 && value >= util_1.MAX_INTEGER) {
                  const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
                  throw new Error(msg);
                }
              } else {
                if (value !== void 0 && value > util_1.MAX_INTEGER) {
                  const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
                  throw new Error(msg);
                }
              }
              break;
            default: {
              const msg = this._errorMsg("unimplemented bits value");
              throw new Error(msg);
            }
          }
        }
      }
      static _validateNotArray(values) {
        const txDataKeys = [
          "nonce",
          "gasPrice",
          "gasLimit",
          "to",
          "value",
          "data",
          "v",
          "r",
          "s",
          "type",
          "baseFee",
          "maxFeePerGas",
          "chainId"
        ];
        for (const [key, value] of Object.entries(values)) {
          if (txDataKeys.includes(key)) {
            if (Array.isArray(value)) {
              throw new Error(`${key} cannot be an array`);
            }
          }
        }
      }
      _getSharedErrorPostfix() {
        let hash = "";
        try {
          hash = this.isSigned() ? (0, util_1.bufferToHex)(this.hash()) : "not available (unsigned)";
        } catch (e) {
          hash = "error";
        }
        let isSigned = "";
        try {
          isSigned = this.isSigned().toString();
        } catch (e) {
          hash = "error";
        }
        let hf = "";
        try {
          hf = this.common.hardfork();
        } catch (e) {
          hf = "error";
        }
        let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `;
        postfix += `signed=${isSigned} hf=${hf}`;
        return postfix;
      }
    };
    exports.BaseTransaction = BaseTransaction;
  }
});

// node_modules/@ethereumjs/tx/dist/eip1559Transaction.js
var require_eip1559Transaction = __commonJS({
  "node_modules/@ethereumjs/tx/dist/eip1559Transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FeeMarketEIP1559Transaction = void 0;
    var rlp_1 = require_dist();
    var util_1 = require_dist2();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var util_2 = require_util();
    var TRANSACTION_TYPE = 2;
    var TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, "0"), "hex");
    var FeeMarketEIP1559Transaction = class extends baseTransaction_1.BaseTransaction {
      constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.DEFAULT_HARDFORK = "london";
        const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (this.common.isActivatedEIP(1559) === false) {
          throw new Error("EIP-1559 not enabled on Common");
        }
        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.maxFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxFeePerGas === "" ? "0x" : maxFeePerGas));
        this.maxPriorityFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxPriorityFeePerGas === "" ? "0x" : maxPriorityFeePerGas));
        this._validateCannotExceedMaxInteger({
          maxFeePerGas: this.maxFeePerGas,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasLimit * this.maxFeePerGas > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
          throw new Error(msg);
        }
        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
          const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
          throw new Error(msg);
        }
        this._validateYParity();
        this._validateHighS();
        const freeze = opts?.freeze ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      static fromTxData(txData, opts = {}) {
        return new FeeMarketEIP1559Transaction(txData, opts);
      }
      static fromSerializedTx(serialized, opts = {}) {
        if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {
          throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized.slice(0, 1).toString("hex")}`);
        }
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(serialized.slice(1)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized tx input: must be array");
        }
        return FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
      }
      static fromValuesArray(values, opts = {}) {
        if (values.length !== 9 && values.length !== 12) {
          throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
        }
        const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s] = values;
        this._validateNotArray({ chainId, v });
        (0, util_1.validateNoLeadingZeroes)({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s });
        return new FeeMarketEIP1559Transaction({
          chainId: (0, util_1.bufferToBigInt)(chainId),
          nonce,
          maxPriorityFeePerGas,
          maxFeePerGas,
          gasLimit,
          to,
          value,
          data,
          accessList: accessList ?? [],
          v: v !== void 0 ? (0, util_1.bufferToBigInt)(v) : void 0,
          r,
          s
        }, opts);
      }
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
          return this.cache.dataFee.value;
        }
        let cost = super.getDataFee();
        cost += BigInt(util_2.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
        if (Object.isFrozen(this)) {
          this.cache.dataFee = {
            value: cost,
            hardfork: this.common.hardfork()
          };
        }
        return cost;
      }
      getUpfrontCost(baseFee = BigInt(0)) {
        const prio = this.maxPriorityFeePerGas;
        const maxBase = this.maxFeePerGas - baseFee;
        const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
        const gasPrice = inclusionFeePerGas + baseFee;
        return this.gasLimit * gasPrice + this.value;
      }
      raw() {
        return [
          (0, util_1.bigIntToUnpaddedBuffer)(this.chainId),
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.maxPriorityFeePerGas),
          (0, util_1.bigIntToUnpaddedBuffer)(this.maxFeePerGas),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data,
          this.accessList,
          this.v !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
          this.r !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
          this.s !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])
        ];
      }
      serialize() {
        const base = this.raw();
        return Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
      }
      getMessageToSign(hashMessage = true) {
        const base = this.raw().slice(0, 9);
        const message = Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
        if (hashMessage) {
          return Buffer.from((0, keccak_1.keccak256)(message));
        } else {
          return message;
        }
      }
      hash() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
          throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
          if (!this.cache.hash) {
            this.cache.hash = Buffer.from((0, keccak_1.keccak256)(this.serialize()));
          }
          return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
      }
      getMessageToVerifySignature() {
        return this.getMessageToSign();
      }
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call this method if transaction is not signed");
          throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(
            msgHash,
            v + BigInt(27),
            (0, util_1.bigIntToUnpaddedBuffer)(r),
            (0, util_1.bigIntToUnpaddedBuffer)(s)
          );
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return FeeMarketEIP1559Transaction.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas,
          maxFeePerGas: this.maxFeePerGas,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: v - BigInt(27),
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s)
        }, opts);
      }
      toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
          chainId: (0, util_1.bigIntToHex)(this.chainId),
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          maxPriorityFeePerGas: (0, util_1.bigIntToHex)(this.maxPriorityFeePerGas),
          maxFeePerGas: (0, util_1.bigIntToHex)(this.maxFeePerGas),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          accessList: accessListJSON,
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0
        };
      }
      errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
        return errorStr;
      }
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
    };
    exports.FeeMarketEIP1559Transaction = FeeMarketEIP1559Transaction;
  }
});

// node_modules/@ethereumjs/tx/dist/eip2930Transaction.js
var require_eip2930Transaction = __commonJS({
  "node_modules/@ethereumjs/tx/dist/eip2930Transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccessListEIP2930Transaction = void 0;
    var rlp_1 = require_dist();
    var util_1 = require_dist2();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var util_2 = require_util();
    var TRANSACTION_TYPE = 1;
    var TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, "0"), "hex");
    var AccessListEIP2930Transaction = class extends baseTransaction_1.BaseTransaction {
      constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.DEFAULT_HARDFORK = "berlin";
        const { chainId, accessList, gasPrice } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (!this.common.isActivatedEIP(2930)) {
          throw new Error("EIP-2930 not enabled on Common");
        }
        this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.gasPrice = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasPrice === "" ? "0x" : gasPrice));
        this._validateCannotExceedMaxInteger({
          gasPrice: this.gasPrice
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasPrice * this.gasLimit > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
          throw new Error(msg);
        }
        this._validateYParity();
        this._validateHighS();
        const freeze = opts?.freeze ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      static fromTxData(txData, opts = {}) {
        return new AccessListEIP2930Transaction(txData, opts);
      }
      static fromSerializedTx(serialized, opts = {}) {
        if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {
          throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized.slice(0, 1).toString("hex")}`);
        }
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized.slice(1))));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized tx input: must be array");
        }
        return AccessListEIP2930Transaction.fromValuesArray(values, opts);
      }
      static fromValuesArray(values, opts = {}) {
        if (values.length !== 8 && values.length !== 11) {
          throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
        }
        const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;
        this._validateNotArray({ chainId, v });
        (0, util_1.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
        const emptyAccessList = [];
        return new AccessListEIP2930Transaction({
          chainId: (0, util_1.bufferToBigInt)(chainId),
          nonce,
          gasPrice,
          gasLimit,
          to,
          value,
          data,
          accessList: accessList ?? emptyAccessList,
          v: v !== void 0 ? (0, util_1.bufferToBigInt)(v) : void 0,
          r,
          s
        }, opts);
      }
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
          return this.cache.dataFee.value;
        }
        let cost = super.getDataFee();
        cost += BigInt(util_2.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
        if (Object.isFrozen(this)) {
          this.cache.dataFee = {
            value: cost,
            hardfork: this.common.hardfork()
          };
        }
        return cost;
      }
      getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value;
      }
      raw() {
        return [
          (0, util_1.bigIntToUnpaddedBuffer)(this.chainId),
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data,
          this.accessList,
          this.v !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
          this.r !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
          this.s !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])
        ];
      }
      serialize() {
        const base = this.raw();
        return Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
      }
      getMessageToSign(hashMessage = true) {
        const base = this.raw().slice(0, 8);
        const message = Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
        if (hashMessage) {
          return Buffer.from((0, keccak_1.keccak256)(message));
        } else {
          return message;
        }
      }
      hash() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
          throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
          if (!this.cache.hash) {
            this.cache.hash = Buffer.from((0, keccak_1.keccak256)(this.serialize()));
          }
          return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
      }
      getMessageToVerifySignature() {
        return this.getMessageToSign();
      }
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call this method if transaction is not signed");
          throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(
            msgHash,
            v + BigInt(27),
            (0, util_1.bigIntToUnpaddedBuffer)(r),
            (0, util_1.bigIntToUnpaddedBuffer)(s)
          );
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return AccessListEIP2930Transaction.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: v - BigInt(27),
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s)
        }, opts);
      }
      toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
          chainId: (0, util_1.bigIntToHex)(this.chainId),
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          gasPrice: (0, util_1.bigIntToHex)(this.gasPrice),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          accessList: accessListJSON,
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0
        };
      }
      errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length ?? 0}`;
        return errorStr;
      }
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
    };
    exports.AccessListEIP2930Transaction = AccessListEIP2930Transaction;
  }
});

// node_modules/@ethereumjs/tx/dist/legacyTransaction.js
var require_legacyTransaction = __commonJS({
  "node_modules/@ethereumjs/tx/dist/legacyTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transaction = void 0;
    var rlp_1 = require_dist();
    var util_1 = require_dist2();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var types_1 = require_types2();
    var TRANSACTION_TYPE = 0;
    function meetsEIP155(_v, chainId) {
      const v = Number(_v);
      const chainIdDoubled = Number(chainId) * 2;
      return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
    }
    var Transaction = class extends baseTransaction_1.BaseTransaction {
      constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.common = this._validateTxV(this.v, opts.common);
        this.gasPrice = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.gasPrice === "" ? "0x" : txData.gasPrice));
        if (this.gasPrice * this.gasLimit > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
          throw new Error(msg);
        }
        this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.common.gteHardfork("spuriousDragon")) {
          if (!this.isSigned()) {
            this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
          } else {
            if (meetsEIP155(this.v, this.common.chainId())) {
              this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
            }
          }
        }
        const freeze = opts?.freeze ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      static fromTxData(txData, opts = {}) {
        return new Transaction(txData, opts);
      }
      static fromSerializedTx(serialized, opts = {}) {
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized tx input. Must be array");
        }
        return this.fromValuesArray(values, opts);
      }
      static fromValuesArray(values, opts = {}) {
        if (values.length !== 6 && values.length !== 9) {
          throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
        }
        const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
        (0, util_1.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
        return new Transaction({
          nonce,
          gasPrice,
          gasLimit,
          to,
          value,
          data,
          v,
          r,
          s
        }, opts);
      }
      raw() {
        return [
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data,
          this.v !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
          this.r !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
          this.s !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])
        ];
      }
      serialize() {
        return Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw())));
      }
      _getMessageToSign() {
        const values = [
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data
        ];
        if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
          values.push((0, util_1.bigIntToUnpaddedBuffer)(this.common.chainId()));
          values.push((0, util_1.unpadBuffer)((0, util_1.toBuffer)(0)));
          values.push((0, util_1.unpadBuffer)((0, util_1.toBuffer)(0)));
        }
        return values;
      }
      getMessageToSign(hashMessage = true) {
        const message = this._getMessageToSign();
        if (hashMessage) {
          return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(message))));
        } else {
          return message;
        }
      }
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
          return this.cache.dataFee.value;
        }
        if (Object.isFrozen(this)) {
          this.cache.dataFee = {
            value: super.getDataFee(),
            hardfork: this.common.hardfork()
          };
        }
        return super.getDataFee();
      }
      getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value;
      }
      hash() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
          throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
          if (!this.cache.hash) {
            this.cache.hash = Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw()))));
          }
          return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw()))));
      }
      getMessageToVerifySignature() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("This transaction is not signed");
          throw new Error(msg);
        }
        const message = this._getMessageToSign();
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(message))));
      }
      getSenderPublicKey() {
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(msgHash, v, (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s), this.supports(types_1.Capability.EIP155ReplayProtection) ? this.common.chainId() : void 0);
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      _processSignature(v, r, s) {
        if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
          v += this.common.chainId() * BigInt(2) + BigInt(8);
        }
        const opts = { ...this.txOptions, common: this.common };
        return Transaction.fromTxData({
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          v,
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s)
        }, opts);
      }
      toJSON() {
        return {
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          gasPrice: (0, util_1.bigIntToHex)(this.gasPrice),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0
        };
      }
      _validateTxV(_v, common) {
        let chainIdBigInt;
        const v = _v !== void 0 ? Number(_v) : void 0;
        if (v !== void 0) {
          if (v < 37 && v !== 27 && v !== 28) {
            throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
          }
        }
        if (v !== void 0 && v !== 0 && (!common || common.gteHardfork("spuriousDragon")) && v !== 27 && v !== 28) {
          if (common) {
            if (!meetsEIP155(BigInt(v), common.chainId())) {
              throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
            }
          } else {
            let numSub;
            if ((v - 35) % 2 === 0) {
              numSub = 35;
            } else {
              numSub = 36;
            }
            chainIdBigInt = BigInt(v - numSub) / BigInt(2);
          }
        }
        return this._getCommon(common, chainIdBigInt);
      }
      errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` gasPrice=${this.gasPrice}`;
        return errorStr;
      }
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
    };
    exports.Transaction = Transaction;
  }
});

// node_modules/@ethereumjs/tx/dist/fromRpc.js
var require_fromRpc = __commonJS({
  "node_modules/@ethereumjs/tx/dist/fromRpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeTxParams = void 0;
    var util_1 = require_dist2();
    var normalizeTxParams = (_txParams) => {
      const txParams = Object.assign({}, _txParams);
      txParams.gasLimit = (0, util_1.toType)(txParams.gasLimit ?? txParams.gas, util_1.TypeOutput.BigInt);
      txParams.data = txParams.data === void 0 ? txParams.input : txParams.data;
      txParams.gasPrice = txParams.gasPrice !== void 0 ? BigInt(txParams.gasPrice) : void 0;
      txParams.value = txParams.value !== void 0 ? BigInt(txParams.value) : void 0;
      txParams.to = txParams.to !== null && txParams.to !== void 0 ? (0, util_1.setLengthLeft)((0, util_1.toBuffer)(txParams.to), 20) : null;
      txParams.v = txParams.v === "0x0" ? "0x" : txParams.v;
      txParams.r = txParams.r === "0x0" ? "0x" : txParams.r;
      txParams.s = txParams.s === "0x0" ? "0x" : txParams.s;
      if (txParams.v !== "0x") {
        txParams.v = (0, util_1.toType)(txParams.v, util_1.TypeOutput.BigInt);
      }
      return txParams;
    };
    exports.normalizeTxParams = normalizeTxParams;
  }
});

// node_modules/@ethereumjs/tx/dist/transactionFactory.js
var require_transactionFactory = __commonJS({
  "node_modules/@ethereumjs/tx/dist/transactionFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionFactory = void 0;
    var util_1 = require_dist2();
    var eip1559Transaction_1 = require_eip1559Transaction();
    var eip2930Transaction_1 = require_eip2930Transaction();
    var fromRpc_1 = require_fromRpc();
    var legacyTransaction_1 = require_legacyTransaction();
    var TransactionFactory = class {
      constructor() {
      }
      static fromTxData(txData, txOptions = {}) {
        if (!("type" in txData) || txData.type === void 0) {
          return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
        } else {
          const txType = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.type)));
          if (txType === 0) {
            return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
          } else if (txType === 1) {
            return eip2930Transaction_1.AccessListEIP2930Transaction.fromTxData(txData, txOptions);
          } else if (txType === 2) {
            return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);
          } else {
            throw new Error(`Tx instantiation with type ${txType} not supported`);
          }
        }
      }
      static fromSerializedData(data, txOptions = {}) {
        if (data[0] <= 127) {
          switch (data[0]) {
            case 1:
              return eip2930Transaction_1.AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);
            case 2:
              return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);
            default:
              throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
          }
        } else {
          return legacyTransaction_1.Transaction.fromSerializedTx(data, txOptions);
        }
      }
      static fromBlockBodyData(data, txOptions = {}) {
        if (Buffer.isBuffer(data)) {
          return this.fromSerializedData(data, txOptions);
        } else if (Array.isArray(data)) {
          return legacyTransaction_1.Transaction.fromValuesArray(data, txOptions);
        } else {
          throw new Error("Cannot decode transaction: unknown type input");
        }
      }
      static async fromEthersProvider(provider, txHash, txOptions) {
        const prov = (0, util_1.getProvider)(provider);
        const txData = await (0, util_1.fetchFromProvider)(prov, {
          method: "eth_getTransactionByHash",
          params: [txHash]
        });
        if (txData === null) {
          throw new Error("No data returned from provider");
        }
        return TransactionFactory.fromRPCTx(txData, txOptions);
      }
      static async fromRPCTx(txData, txOptions = {}) {
        return TransactionFactory.fromTxData((0, fromRpc_1.normalizeTxParams)(txData), txOptions);
      }
    };
    exports.TransactionFactory = TransactionFactory;
  }
});

// node_modules/@ethereumjs/tx/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@ethereumjs/tx/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionFactory = exports.Transaction = exports.AccessListEIP2930Transaction = exports.FeeMarketEIP1559Transaction = void 0;
    var eip1559Transaction_1 = require_eip1559Transaction();
    Object.defineProperty(exports, "FeeMarketEIP1559Transaction", { enumerable: true, get: function() {
      return eip1559Transaction_1.FeeMarketEIP1559Transaction;
    } });
    var eip2930Transaction_1 = require_eip2930Transaction();
    Object.defineProperty(exports, "AccessListEIP2930Transaction", { enumerable: true, get: function() {
      return eip2930Transaction_1.AccessListEIP2930Transaction;
    } });
    var legacyTransaction_1 = require_legacyTransaction();
    Object.defineProperty(exports, "Transaction", { enumerable: true, get: function() {
      return legacyTransaction_1.Transaction;
    } });
    var transactionFactory_1 = require_transactionFactory();
    Object.defineProperty(exports, "TransactionFactory", { enumerable: true, get: function() {
      return transactionFactory_1.TransactionFactory;
    } });
    __exportStar(require_types2(), exports);
  }
});

export {
  require_dist3 as require_dist,
  require_dist4 as require_dist2
};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
//# sourceMappingURL=chunk-GPRWK5OC.js.map
