{
  "version": 3,
  "sources": ["../../crc-32/crc32.js", "../../@ethereumjs/common/src/eips/index.ts", "../../@ethereumjs/common/src/enums.ts", "../../@ethereumjs/common/src/hardforks/index.ts", "../../@ethereumjs/common/src/utils.ts", "../../@ethereumjs/common/src/common.ts", "../../@ethereumjs/common/dist/types.js", "../../@ethereumjs/common/src/index.ts", "../../@ethereumjs/tx/src/types.ts", "../../@ethereumjs/tx/src/util.ts", "../../@ethereumjs/tx/src/baseTransaction.ts", "../../@ethereumjs/tx/src/eip1559Transaction.ts", "../../@ethereumjs/tx/src/eip2930Transaction.ts", "../../@ethereumjs/tx/src/legacyTransaction.ts", "../../@ethereumjs/tx/src/fromRpc.ts", "../../@ethereumjs/tx/src/transactionFactory.ts", "../../@ethereumjs/tx/src/index.ts"],
  "sourcesContent": ["/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\n/*exported CRC32 */\nvar CRC32;\n(function (factory) {\n\t/*jshint ignore:start */\n\t/*eslint-disable */\n\tif(typeof DO_NOT_EXPORT_CRC === 'undefined') {\n\t\tif('object' === typeof exports) {\n\t\t\tfactory(exports);\n\t\t} else if ('function' === typeof define && define.amd) {\n\t\t\tdefine(function () {\n\t\t\t\tvar module = {};\n\t\t\t\tfactory(module);\n\t\t\t\treturn module;\n\t\t\t});\n\t\t} else {\n\t\t\tfactory(CRC32 = {});\n\t\t}\n\t} else {\n\t\tfactory(CRC32 = {});\n\t}\n\t/*eslint-enable */\n\t/*jshint ignore:end */\n}(function(CRC32) {\nCRC32.version = '1.2.2';\n/*global Int32Array */\nfunction signed_crc_table() {\n\tvar c = 0, table = new Array(256);\n\n\tfor(var n =0; n != 256; ++n){\n\t\tc = n;\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\ttable[n] = c;\n\t}\n\n\treturn typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n}\n\nvar T0 = signed_crc_table();\nfunction slice_by_16_tables(T) {\n\tvar c = 0, v = 0, n = 0, table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;\n\n\tfor(n = 0; n != 256; ++n) table[n] = T[n];\n\tfor(n = 0; n != 256; ++n) {\n\t\tv = T[n];\n\t\tfor(c = 256 + n; c < 4096; c += 256) v = table[c] = (v >>> 8) ^ T[v & 0xFF];\n\t}\n\tvar out = [];\n\tfor(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);\n\treturn out;\n}\nvar TT = slice_by_16_tables(T0);\nvar T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];\nvar T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];\nvar Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];\nfunction crc32_bstr(bstr, seed) {\n\tvar C = seed ^ -1;\n\tfor(var i = 0, L = bstr.length; i < L;) C = (C>>>8) ^ T0[(C^bstr.charCodeAt(i++))&0xFF];\n\treturn ~C;\n}\n\nfunction crc32_buf(B, seed) {\n\tvar C = seed ^ -1, L = B.length - 15, i = 0;\n\tfor(; i < L;) C =\n\t\tTf[B[i++] ^ (C & 255)] ^\n\t\tTe[B[i++] ^ ((C >> 8) & 255)] ^\n\t\tTd[B[i++] ^ ((C >> 16) & 255)] ^\n\t\tTc[B[i++] ^ (C >>> 24)] ^\n\t\tTb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^\n\t\tT7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^\n\t\tT3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];\n\tL += 15;\n\twhile(i < L) C = (C>>>8) ^ T0[(C^B[i++])&0xFF];\n\treturn ~C;\n}\n\nfunction crc32_str(str, seed) {\n\tvar C = seed ^ -1;\n\tfor(var i = 0, L = str.length, c = 0, d = 0; i < L;) {\n\t\tc = str.charCodeAt(i++);\n\t\tif(c < 0x80) {\n\t\t\tC = (C>>>8) ^ T0[(C^c)&0xFF];\n\t\t} else if(c < 0x800) {\n\t\t\tC = (C>>>8) ^ T0[(C ^ (192|((c>>6)&31)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];\n\t\t} else if(c >= 0xD800 && c < 0xE000) {\n\t\t\tc = (c&1023)+64; d = str.charCodeAt(i++)&1023;\n\t\t\tC = (C>>>8) ^ T0[(C ^ (240|((c>>8)&7)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|((c>>2)&63)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|(d&63)))&0xFF];\n\t\t} else {\n\t\t\tC = (C>>>8) ^ T0[(C ^ (224|((c>>12)&15)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|((c>>6)&63)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];\n\t\t}\n\t}\n\treturn ~C;\n}\nCRC32.table = T0;\n// $FlowIgnore\nCRC32.bstr = crc32_bstr;\n// $FlowIgnore\nCRC32.buf = crc32_buf;\n// $FlowIgnore\nCRC32.str = crc32_str;\n}));\n", "export const EIPs: { [key: number]: any } = {\n  1153: require('./1153.json'),\n  1559: require('./1559.json'),\n  2315: require('./2315.json'),\n  2537: require('./2537.json'),\n  2565: require('./2565.json'),\n  2718: require('./2718.json'),\n  2929: require('./2929.json'),\n  2930: require('./2930.json'),\n  3074: require('./3074.json'),\n  3198: require('./3198.json'),\n  3529: require('./3529.json'),\n  3540: require('./3540.json'),\n  3541: require('./3541.json'),\n  3554: require('./3554.json'),\n  3607: require('./3607.json'),\n  3651: require('./3651.json'),\n  3670: require('./3670.json'),\n  3675: require('./3675.json'),\n  3855: require('./3855.json'),\n  3860: require('./3860.json'),\n  4345: require('./4345.json'),\n  4399: require('./4399.json'),\n  4844: require('./4844.json'),\n  4895: require('./4895.json'),\n  5133: require('./5133.json'),\n}\n", "export enum Chain {\n  Mainnet = 1,\n  Ropsten = 3,\n  Rinkeby = 4,\n  Goerli = 5,\n  Sepolia = 11155111,\n}\n\nexport enum Hardfork {\n  Chainstart = 'chainstart',\n  Homestead = 'homestead',\n  Dao = 'dao',\n  TangerineWhistle = 'tangerineWhistle',\n  SpuriousDragon = 'spuriousDragon',\n  Byzantium = 'byzantium',\n  Constantinople = 'constantinople',\n  Petersburg = 'petersburg',\n  Istanbul = 'istanbul',\n  MuirGlacier = 'muirGlacier',\n  Berlin = 'berlin',\n  London = 'london',\n  ArrowGlacier = 'arrowGlacier',\n  GrayGlacier = 'grayGlacier',\n  MergeForkIdTransition = 'mergeForkIdTransition',\n  Merge = 'merge',\n  Shanghai = 'shanghai',\n  ShardingForkDev = 'shardingFork',\n}\n\nexport enum ConsensusType {\n  ProofOfStake = 'pos',\n  ProofOfWork = 'pow',\n  ProofOfAuthority = 'poa',\n}\n\nexport enum ConsensusAlgorithm {\n  Ethash = 'ethash',\n  Clique = 'clique',\n  Casper = 'casper',\n}\n\nexport enum CustomChain {\n  /**\n   * Polygon (Matic) Mainnet\n   *\n   * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)\n   */\n  PolygonMainnet = 'polygon-mainnet',\n\n  /**\n   * Polygon (Matic) Mumbai Testnet\n   *\n   * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)\n   */\n  PolygonMumbai = 'polygon-mumbai',\n\n  /**\n   * Arbitrum Rinkeby Testnet\n   *\n   * - [Documentation](https://developer.offchainlabs.com/docs/public_testnet)\n   */\n  ArbitrumRinkebyTestnet = 'arbitrum-rinkeby-testnet',\n\n  /**\n   * Arbitrum One - mainnet for Arbitrum roll-up\n   *\n   * - [Documentation](https://developer.offchainlabs.com/public-chains)\n   */\n  ArbitrumOne = 'arbitrum-one',\n\n  /**\n   * xDai EVM sidechain with a native stable token\n   *\n   * - [Documentation](https://www.xdaichain.com/)\n   */\n  xDaiChain = 'x-dai-chain',\n\n  /**\n   * Optimistic Kovan - testnet for Optimism roll-up\n   *\n   * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)\n   */\n  OptimisticKovan = 'optimistic-kovan',\n\n  /**\n   * Optimistic Ethereum - mainnet for Optimism roll-up\n   *\n   * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)\n   */\n  OptimisticEthereum = 'optimistic-ethereum',\n}\n", "export const hardforks = {\n  chainstart: require('./chainstart.json'),\n  homestead: require('./homestead.json'),\n  dao: require('./dao.json'),\n  tangerineWhistle: require('./tangerineWhistle.json'),\n  spuriousDragon: require('./spuriousDragon.json'),\n  byzantium: require('./byzantium.json'),\n  constantinople: require('./constantinople.json'),\n  petersburg: require('./petersburg.json'),\n  istanbul: require('./istanbul.json'),\n  muirGlacier: require('./muirGlacier.json'),\n  berlin: require('./berlin.json'),\n  london: require('./london.json'),\n  shanghai: require('./shanghai.json'),\n  arrowGlacier: require('./arrowGlacier.json'),\n  grayGlacier: require('./grayGlacier.json'),\n  mergeForkIdTransition: require('./mergeForkIdTransition.json'),\n  merge: require('./merge.json'),\n  shardingFork: require('./sharding.json'),\n}\n", "import { intToHex, isHexPrefixed, stripHexPrefix } from '@ethereumjs/util'\n\nimport { Hardfork } from './enums'\n\ntype ConfigHardfork =\n  | { name: string; block: null; timestamp: number }\n  | { name: string; block: number; timestamp?: number }\n/**\n * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally\n * @param nonce string parsed from the Geth genesis file\n * @returns nonce as a 0x-prefixed 8 byte string\n */\nfunction formatNonce(nonce: string): string {\n  if (!nonce || nonce === '0x0') {\n    return '0x0000000000000000'\n  }\n  if (isHexPrefixed(nonce)) {\n    return '0x' + stripHexPrefix(nonce).padStart(16, '0')\n  }\n  return '0x' + nonce.padStart(16, '0')\n}\n\n/**\n * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object\n * @param json object representing the Geth genesis file\n * @param optional mergeForkIdPostMerge which clarifies the placement of MergeForkIdTransition\n * hardfork, which by default is post merge as with the merged eth networks but could also come\n * before merge like in kiln genesis\n * @returns genesis parameters in a `CommonOpts` compliant object\n */\nfunction parseGethParams(json: any, mergeForkIdPostMerge: boolean = true) {\n  const {\n    name,\n    config,\n    difficulty,\n    mixHash,\n    gasLimit,\n    coinbase,\n    baseFeePerGas,\n  }: {\n    name: string\n    config: any\n    difficulty: string\n    mixHash: string\n    gasLimit: string\n    coinbase: string\n    baseFeePerGas: string\n  } = json\n  let { extraData, timestamp, nonce }: { extraData: string; timestamp: string; nonce: string } =\n    json\n  const genesisTimestamp = Number(timestamp)\n  const { chainId }: { chainId: number } = config\n\n  // geth is not strictly putting empty fields with a 0x prefix\n  if (extraData === '') {\n    extraData = '0x'\n  }\n  // geth may use number for timestamp\n  if (!isHexPrefixed(timestamp)) {\n    timestamp = intToHex(parseInt(timestamp))\n  }\n  // geth may not give us a nonce strictly formatted to an 8 byte hex string\n  if (nonce.length !== 18) {\n    nonce = formatNonce(nonce)\n  }\n\n  // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time\n  // but have different configuration parameters in geth genesis parameters\n  if (config.eip155Block !== config.eip158Block) {\n    throw new Error(\n      'EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork'\n    )\n  }\n\n  const params = {\n    name,\n    chainId,\n    networkId: chainId,\n    genesis: {\n      timestamp,\n      gasLimit: parseInt(gasLimit), // geth gasLimit and difficulty are hex strings while ours are `number`s\n      difficulty: parseInt(difficulty),\n      nonce,\n      extraData,\n      mixHash,\n      coinbase,\n      baseFeePerGas,\n    },\n    hardfork: undefined as string | undefined,\n    hardforks: [] as ConfigHardfork[],\n    bootstrapNodes: [],\n    consensus:\n      config.clique !== undefined\n        ? {\n            type: 'poa',\n            algorithm: 'clique',\n            clique: {\n              // The recent geth genesis seems to be using blockperiodseconds\n              // and epochlength for clique specification\n              // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ\n              period: config.clique.period ?? config.clique.blockperiodseconds,\n              epoch: config.clique.epoch ?? config.clique.epochlength,\n            },\n          }\n        : {\n            type: 'pow',\n            algorithm: 'ethash',\n            ethash: {},\n          },\n  }\n\n  const forkMap: { [key: string]: { name: string; postMerge?: boolean; isTimestamp?: boolean } } = {\n    [Hardfork.Homestead]: { name: 'homesteadBlock' },\n    [Hardfork.Dao]: { name: 'daoForkBlock' },\n    [Hardfork.TangerineWhistle]: { name: 'eip150Block' },\n    [Hardfork.SpuriousDragon]: { name: 'eip155Block' },\n    [Hardfork.Byzantium]: { name: 'byzantiumBlock' },\n    [Hardfork.Constantinople]: { name: 'constantinopleBlock' },\n    [Hardfork.Petersburg]: { name: 'petersburgBlock' },\n    [Hardfork.Istanbul]: { name: 'istanbulBlock' },\n    [Hardfork.MuirGlacier]: { name: 'muirGlacierBlock' },\n    [Hardfork.Berlin]: { name: 'berlinBlock' },\n    [Hardfork.London]: { name: 'londonBlock' },\n    [Hardfork.MergeForkIdTransition]: { name: 'mergeForkBlock', postMerge: mergeForkIdPostMerge },\n    [Hardfork.Shanghai]: { name: 'shanghaiTime', postMerge: true, isTimestamp: true },\n    [Hardfork.ShardingForkDev]: { name: 'shardingForkTime', postMerge: true, isTimestamp: true },\n  }\n\n  // forkMapRev is the map from config field name to Hardfork\n  const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {\n    acc[forkMap[elem].name] = elem\n    return acc\n  }, {} as { [key: string]: string })\n  const configHardforkNames = Object.keys(config).filter(\n    (key) => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null\n  )\n\n  params.hardforks = configHardforkNames\n    .map((nameBlock) => ({\n      name: forkMapRev[nameBlock],\n      block:\n        forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== 'number'\n          ? null\n          : config[nameBlock],\n      timestamp:\n        forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === 'number'\n          ? config[nameBlock]\n          : undefined,\n    }))\n    .filter((fork) => fork.block !== null || fork.timestamp !== undefined) as ConfigHardfork[]\n\n  params.hardforks.sort(function (a: ConfigHardfork, b: ConfigHardfork) {\n    return (a.block ?? Infinity) - (b.block ?? Infinity)\n  })\n\n  params.hardforks.sort(function (a: ConfigHardfork, b: ConfigHardfork) {\n    return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp)\n  })\n\n  if (config.terminalTotalDifficulty !== undefined) {\n    // Following points need to be considered for placement of merge hf\n    // - Merge hardfork can't be placed at genesis\n    // - Place merge hf before any hardforks that require CL participation for e.g. withdrawals\n    // - Merge hardfork has to be placed just after genesis if any of the genesis hardforks make CL\n    //   necessary for e.g. withdrawals\n    const mergeConfig = {\n      name: Hardfork.Merge,\n      ttd: config.terminalTotalDifficulty,\n      block: null,\n    }\n\n    // Merge hardfork has to be placed before first hardfork that is dependent on merge\n    const postMergeIndex = params.hardforks.findIndex(\n      (hf: any) => forkMap[hf.name]?.postMerge === true\n    )\n    if (postMergeIndex !== -1) {\n      params.hardforks.splice(postMergeIndex, 0, mergeConfig as unknown as ConfigHardfork)\n    } else {\n      params.hardforks.push(mergeConfig as unknown as ConfigHardfork)\n    }\n  }\n\n  const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined\n  params.hardfork = latestHardfork?.name\n  params.hardforks.unshift({ name: Hardfork.Chainstart, block: 0 })\n\n  return params\n}\n\n/**\n * Parses a genesis.json exported from Geth into parameters for Common instance\n * @param json representing the Geth genesis file\n * @param name optional chain name\n * @returns parsed params\n */\nexport function parseGethGenesis(json: any, name?: string, mergeForkIdPostMerge?: boolean) {\n  try {\n    if (['config', 'difficulty', 'gasLimit', 'alloc'].some((field) => !(field in json))) {\n      throw new Error('Invalid format, expected geth genesis fields missing')\n    }\n    if (name !== undefined) {\n      json.name = name\n    }\n    return parseGethParams(json, mergeForkIdPostMerge)\n  } catch (e: any) {\n    throw new Error(`Error parsing parameters file: ${e.message}`)\n  }\n}\n", "import { TypeOutput, intToBuffer, toType } from '@ethereumjs/util'\nimport { buf as crc32Buffer } from 'crc-32'\nimport { EventEmitter } from 'events'\n\nimport * as goerli from './chains/goerli.json'\nimport * as mainnet from './chains/mainnet.json'\nimport * as rinkeby from './chains/rinkeby.json'\nimport * as ropsten from './chains/ropsten.json'\nimport * as sepolia from './chains/sepolia.json'\nimport { EIPs } from './eips'\nimport { Chain, CustomChain, Hardfork } from './enums'\nimport { hardforks as HARDFORK_SPECS } from './hardforks'\nimport { parseGethGenesis } from './utils'\n\nimport type { ConsensusAlgorithm, ConsensusType } from './enums'\nimport type {\n  BootstrapNodeConfig,\n  CasperConfig,\n  ChainConfig,\n  ChainName,\n  ChainsConfig,\n  CliqueConfig,\n  CommonOpts,\n  CustomCommonOpts,\n  EthashConfig,\n  GenesisBlockConfig,\n  GethConfigOpts,\n  HardforkConfig,\n} from './types'\nimport type { BigIntLike } from '@ethereumjs/util'\n\ntype HardforkSpecKeys = keyof typeof HARDFORK_SPECS\ntype HardforkSpecValues = typeof HARDFORK_SPECS[HardforkSpecKeys]\n/**\n * Common class to access chain and hardfork parameters and to provide\n * a unified and shared view on the network and hardfork state.\n *\n * Use the {@link Common.custom} static constructor for creating simple\n * custom chain {@link Common} objects (more complete custom chain setups\n * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).\n */\nexport class Common extends EventEmitter {\n  readonly DEFAULT_HARDFORK: string | Hardfork\n\n  private _chainParams: ChainConfig\n  private _hardfork: string | Hardfork\n  private _eips: number[] = []\n  private _customChains: ChainConfig[]\n\n  private HARDFORK_CHANGES: [HardforkSpecKeys, HardforkSpecValues][]\n\n  /**\n   * Creates a {@link Common} object for a custom chain, based on a standard one.\n   *\n   * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden\n   * in a provided {@link chainParamsOrName} dictionary. Some usage example:\n   *\n   * ```javascript\n   * Common.custom({chainId: 123})\n   * ```\n   *\n   * There are also selected supported custom chains which can be initialized by using one of the\n   * {@link CustomChains} for {@link chainParamsOrName}, e.g.:\n   *\n   * ```javascript\n   * Common.custom(CustomChains.MaticMumbai)\n   * ```\n   *\n   * Note that these supported custom chains only provide some base parameters (usually the chain and\n   * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with\n   * the `@ethereumjs/tx` library to a Layer-2 chain).\n   *\n   * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain\n   * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others\n   */\n  static custom(\n    chainParamsOrName: Partial<ChainConfig> | CustomChain,\n    opts: CustomCommonOpts = {}\n  ): Common {\n    const baseChain = opts.baseChain ?? 'mainnet'\n    const standardChainParams = { ...Common._getChainParams(baseChain) }\n    standardChainParams['name'] = 'custom-chain'\n\n    if (typeof chainParamsOrName !== 'string') {\n      return new Common({\n        chain: {\n          ...standardChainParams,\n          ...chainParamsOrName,\n        },\n        ...opts,\n      })\n    } else {\n      if (chainParamsOrName === CustomChain.PolygonMainnet) {\n        return Common.custom(\n          {\n            name: CustomChain.PolygonMainnet,\n            chainId: 137,\n            networkId: 137,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.PolygonMumbai) {\n        return Common.custom(\n          {\n            name: CustomChain.PolygonMumbai,\n            chainId: 80001,\n            networkId: 80001,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.ArbitrumRinkebyTestnet) {\n        return Common.custom(\n          {\n            name: CustomChain.ArbitrumRinkebyTestnet,\n            chainId: 421611,\n            networkId: 421611,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.ArbitrumOne) {\n        return Common.custom(\n          {\n            name: CustomChain.ArbitrumOne,\n            chainId: 42161,\n            networkId: 42161,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.xDaiChain) {\n        return Common.custom(\n          {\n            name: CustomChain.xDaiChain,\n            chainId: 100,\n            networkId: 100,\n          },\n          opts\n        )\n      }\n\n      if (chainParamsOrName === CustomChain.OptimisticKovan) {\n        return Common.custom(\n          {\n            name: CustomChain.OptimisticKovan,\n            chainId: 69,\n            networkId: 69,\n          },\n          // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n          { hardfork: Hardfork.Berlin, ...opts }\n        )\n      }\n\n      if (chainParamsOrName === CustomChain.OptimisticEthereum) {\n        return Common.custom(\n          {\n            name: CustomChain.OptimisticEthereum,\n            chainId: 10,\n            networkId: 10,\n          },\n          // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n          { hardfork: Hardfork.Berlin, ...opts }\n        )\n      }\n      throw new Error(`Custom chain ${chainParamsOrName} not supported`)\n    }\n  }\n\n  /**\n   * Static method to load and set common from a geth genesis json\n   * @param genesisJson json of geth configuration\n   * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance\n   * @returns Common\n   */\n  static fromGethGenesis(\n    genesisJson: any,\n    { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }: GethConfigOpts\n  ): Common {\n    const genesisParams = parseGethGenesis(genesisJson, chain, mergeForkIdPostMerge)\n    const common = new Common({\n      chain: genesisParams.name ?? 'custom',\n      customChains: [genesisParams],\n      eips,\n      hardfork: hardfork ?? genesisParams.hardfork,\n    })\n    if (genesisHash !== undefined) {\n      common.setForkHashes(genesisHash)\n    }\n    return common\n  }\n\n  /**\n   * Static method to determine if a {@link chainId} is supported as a standard chain\n   * @param chainId bigint id (`1`) of a standard chain\n   * @returns boolean\n   */\n  static isSupportedChainId(chainId: bigint): boolean {\n    const initializedChains = this._getInitializedChains()\n    return Boolean((initializedChains['names'] as ChainName)[chainId.toString()])\n  }\n\n  private static _getChainParams(\n    chain: string | number | Chain | bigint,\n    customChains?: ChainConfig[]\n  ): ChainConfig {\n    const initializedChains = this._getInitializedChains(customChains)\n    if (typeof chain === 'number' || typeof chain === 'bigint') {\n      chain = chain.toString()\n\n      if ((initializedChains['names'] as ChainName)[chain]) {\n        const name: string = (initializedChains['names'] as ChainName)[chain]\n        return initializedChains[name] as ChainConfig\n      }\n\n      throw new Error(`Chain with ID ${chain} not supported`)\n    }\n\n    if (initializedChains[chain] !== undefined) {\n      return initializedChains[chain] as ChainConfig\n    }\n\n    throw new Error(`Chain with name ${chain} not supported`)\n  }\n\n  constructor(opts: CommonOpts) {\n    super()\n    this._customChains = opts.customChains ?? []\n    this._chainParams = this.setChain(opts.chain)\n    this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? Hardfork.Merge\n    // Assign hardfork changes in the sequence of the applied hardforks\n    this.HARDFORK_CHANGES = this.hardforks().map((hf) => [\n      hf.name as HardforkSpecKeys,\n      HARDFORK_SPECS[hf.name as HardforkSpecKeys],\n    ])\n    this._hardfork = this.DEFAULT_HARDFORK\n    if (opts.hardfork !== undefined) {\n      this.setHardfork(opts.hardfork)\n    }\n    if (opts.eips) {\n      this.setEIPs(opts.eips)\n    }\n  }\n\n  /**\n   * Sets the chain\n   * @param chain String ('mainnet') or Number (1) chain representation.\n   *              Or, a Dictionary of chain parameters for a private network.\n   * @returns The dictionary with parameters set as chain\n   */\n  setChain(chain: string | number | Chain | bigint | object): ChainConfig {\n    if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {\n      this._chainParams = Common._getChainParams(chain, this._customChains)\n    } else if (typeof chain === 'object') {\n      if (this._customChains.length > 0) {\n        throw new Error(\n          'Chain must be a string, number, or bigint when initialized with customChains passed in'\n        )\n      }\n      const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes']\n      for (const param of required) {\n        if (!(param in chain)) {\n          throw new Error(`Missing required chain parameter: ${param}`)\n        }\n      }\n      this._chainParams = chain as ChainConfig\n    } else {\n      throw new Error('Wrong input format')\n    }\n    for (const hf of this.hardforks()) {\n      if (hf.block === undefined) {\n        throw new Error(`Hardfork cannot have undefined block number`)\n      }\n    }\n    return this._chainParams\n  }\n\n  /**\n   * Sets the hardfork to get params for\n   * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum\n   */\n  setHardfork(hardfork: string | Hardfork): void {\n    let existing = false\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if (hfChanges[0] === hardfork) {\n        if (this._hardfork !== hardfork) {\n          this._hardfork = hardfork\n          this.emit('hardforkChanged', hardfork)\n        }\n        existing = true\n      }\n    }\n    if (!existing) {\n      throw new Error(`Hardfork with name ${hardfork} not supported`)\n    }\n  }\n\n  /**\n   * Returns the hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)\n   * @param timestamp: timestamp in seconds at which block was/is to be minted\n   * @returns The name of the HF\n   */\n  getHardforkByBlockNumber(\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): string {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    td = toType(td, TypeOutput.BigInt)\n    timestamp = toType(timestamp, TypeOutput.Number)\n\n    // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)\n    const hfs = this.hardforks().filter(\n      (hf) =>\n        hf.block !== null || (hf.ttd !== null && hf.ttd !== undefined) || hf.timestamp !== undefined\n    )\n    const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n    const doubleTTDHF = hfs\n      .slice(mergeIndex + 1)\n      .findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n    if (doubleTTDHF >= 0) {\n      throw Error(`More than one merge hardforks found with ttd specified`)\n    }\n\n    // Find the first hardfork that has a block number greater than `blockNumber`\n    // (skips the merge hardfork since it cannot have a block number specified).\n    // If timestamp is not provided, it also skips timestamps hardforks to continue\n    // discovering/checking number hardforks.\n    let hfIndex = hfs.findIndex(\n      (hf) =>\n        (hf.block !== null && hf.block > blockNumber) ||\n        (timestamp !== undefined && Number(hf.timestamp) > timestamp)\n    )\n\n    if (hfIndex === -1) {\n      // all hardforks apply, set hfIndex to the last one as that's the candidate\n      hfIndex = hfs.length\n    } else if (hfIndex === 0) {\n      // cannot have a case where a block number is before all applied hardforks\n      // since the chain has to start with a hardfork\n      throw Error('Must have at least one hardfork at block 0')\n    }\n\n    // If timestamp is not provided, we need to rollback to the last hf with block or ttd\n    if (timestamp === undefined) {\n      const stepBack = hfs\n        .slice(0, hfIndex)\n        .reverse()\n        .findIndex((hf) => hf.block !== null || hf.ttd !== undefined)\n      hfIndex = hfIndex - stepBack\n    }\n    // Move hfIndex one back to arrive at candidate hardfork\n    hfIndex = hfIndex - 1\n\n    // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number\n    // hardforks. so it will now be needed to rollback\n    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {\n      // We're on the merge hardfork.  Let's check the TTD\n      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd!) > td) {\n        // Merge ttd greater than current td so we're on hardfork before merge\n        hfIndex -= 1\n      }\n    } else {\n      if (mergeIndex >= 0 && td !== undefined && td !== null) {\n        if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd!) > td) {\n          throw Error('Maximum HF determined by total difficulty is lower than the block number HF')\n        } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd!) <= td) {\n          throw Error('HF determined by block number is lower than the minimum total difficulty HF')\n        }\n      }\n    }\n\n    const hfStartIndex = hfIndex\n    // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp\n    // This won't anyway be the case with Merge hfs\n    for (; hfIndex < hfs.length - 1; hfIndex++) {\n      // break out if hfIndex + 1 is not scheduled at hfIndex\n      if (\n        hfs[hfIndex].block !== hfs[hfIndex + 1].block ||\n        hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp\n      ) {\n        break\n      }\n    }\n\n    if (timestamp) {\n      const minTimeStamp = hfs\n        .slice(0, hfStartIndex)\n        .reduce((acc: number, hf: HardforkConfig) => Math.max(Number(hf.timestamp ?? '0'), acc), 0)\n      if (minTimeStamp > timestamp) {\n        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`)\n      }\n\n      const maxTimeStamp = hfs\n        .slice(hfIndex + 1)\n        .reduce(\n          (acc: number, hf: HardforkConfig) => Math.min(Number(hf.timestamp ?? timestamp), acc),\n          timestamp\n        )\n      if (maxTimeStamp < timestamp) {\n        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`)\n      }\n    }\n    const hardfork = hfs[hfIndex]\n    return hardfork.name\n  }\n\n  /**\n   * Sets a new hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td\n   * @param timestamp\n   * @returns The name of the HF set\n   */\n  setHardforkByBlockNumber(\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): string {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp)\n    this.setHardfork(hardfork)\n    return hardfork\n  }\n\n  /**\n   * Internal helper function, returns the params for the given hardfork for the chain set\n   * @param hardfork Hardfork name\n   * @returns Dictionary with hardfork params or null if hardfork not on chain\n   */\n  _getHardfork(hardfork: string | Hardfork): HardforkConfig | null {\n    const hfs = this.hardforks()\n    for (const hf of hfs) {\n      if (hf['name'] === hardfork) return hf\n    }\n    return null\n  }\n\n  /**\n   * Sets the active EIPs\n   * @param eips\n   */\n  setEIPs(eips: number[] = []) {\n    for (const eip of eips) {\n      if (!(eip in EIPs)) {\n        throw new Error(`${eip} not supported`)\n      }\n      const minHF = this.gteHardfork(EIPs[eip]['minimumHardfork'])\n      if (!minHF) {\n        throw new Error(\n          `${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`\n        )\n      }\n      if (EIPs[eip].requiredEIPs !== undefined) {\n        for (const elem of EIPs[eip].requiredEIPs) {\n          if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {\n            throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`)\n          }\n        }\n      }\n    }\n    this._eips = eips\n  }\n\n  /**\n   * Returns a parameter for the current chain setup\n   *\n   * If the parameter is present in an EIP, the EIP always takes precedence.\n   * Otherwise the parameter if taken from the latest applied HF with\n   * a change on the respective parameter.\n   *\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  param(topic: string, name: string): bigint {\n    // TODO: consider the case that different active EIPs\n    // can change the same parameter\n    let value\n    for (const eip of this._eips) {\n      value = this.paramByEIP(topic, name, eip)\n      if (value !== undefined) return value\n    }\n    return this.paramByHardfork(topic, name, this._hardfork)\n  }\n\n  /**\n   * Returns the parameter corresponding to a hardfork\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param hardfork Hardfork name\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByHardfork(topic: string, name: string, hardfork: string | Hardfork): bigint {\n    let value = null\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF file (e.g. berlin.json)\n      if ('eips' in hfChanges[1]) {\n        const hfEIPs = hfChanges[1]['eips']\n        for (const eip of hfEIPs) {\n          const valueEIP = this.paramByEIP(topic, name, eip)\n          value = typeof valueEIP === 'bigint' ? valueEIP : value\n        }\n        // Parameter-inlining HF file (e.g. istanbul.json)\n      } else {\n        if (hfChanges[1][topic] === undefined) {\n          throw new Error(`Topic ${topic} not defined`)\n        }\n        if (hfChanges[1][topic][name] !== undefined) {\n          value = hfChanges[1][topic][name].v\n        }\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return BigInt(value ?? 0)\n  }\n\n  /**\n   * Returns a parameter corresponding to an EIP\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param eip Number of the EIP\n   * @returns The value requested or `undefined` if not found\n   */\n  paramByEIP(topic: string, name: string, eip: number): bigint | undefined {\n    if (!(eip in EIPs)) {\n      throw new Error(`${eip} not supported`)\n    }\n\n    const eipParams = EIPs[eip]\n    if (!(topic in eipParams)) {\n      throw new Error(`Topic ${topic} not defined`)\n    }\n    if (eipParams[topic][name] === undefined) {\n      return undefined\n    }\n    const value = eipParams[topic][name].v\n    return BigInt(value)\n  }\n\n  /**\n   * Returns a parameter for the hardfork active on block number or\n   * optional provided total difficulty (Merge HF)\n   * @param topic Parameter topic\n   * @param name Parameter name\n   * @param blockNumber Block number\n   * @param td Total difficulty\n   *    * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByBlock(\n    topic: string,\n    name: string,\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): bigint {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp)\n    return this.paramByHardfork(topic, name, hardfork)\n  }\n\n  /**\n   * Checks if an EIP is activated by either being included in the EIPs\n   * manually passed in with the {@link CommonOpts.eips} or in a\n   * hardfork currently being active\n   *\n   * Note: this method only works for EIPs being supported\n   * by the {@link CommonOpts.eips} constructor option\n   * @param eip\n   */\n  isActivatedEIP(eip: number): boolean {\n    if (this.eips().includes(eip)) {\n      return true\n    }\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1]\n      if (this.gteHardfork(hf['name']) && 'eips' in hf) {\n        if ((hf['eips'] as number[]).includes(eip)) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  /**\n   * Checks if set or provided hardfork is active on block number\n   * @param hardfork Hardfork name or null (for HF set)\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  hardforkIsActiveOnBlock(hardfork: string | Hardfork | null, blockNumber: BigIntLike): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const hfBlock = this.hardforkBlock(hardfork)\n    if (typeof hfBlock === 'bigint' && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Alias to hardforkIsActiveOnBlock when hardfork is set\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  activeOnBlock(blockNumber: BigIntLike): boolean {\n    return this.hardforkIsActiveOnBlock(null, blockNumber)\n  }\n\n  /**\n   * Sequence based check if given or set HF1 is greater than or equal HF2\n   * @param hardfork1 Hardfork name or null (if set)\n   * @param hardfork2 Hardfork name\n   * @param opts Hardfork options\n   * @returns True if HF1 gte HF2\n   */\n  hardforkGteHardfork(hardfork1: string | Hardfork | null, hardfork2: string | Hardfork): boolean {\n    hardfork1 = hardfork1 ?? this._hardfork\n    const hardforks = this.hardforks()\n\n    let posHf1 = -1,\n      posHf2 = -1\n    let index = 0\n    for (const hf of hardforks) {\n      if (hf['name'] === hardfork1) posHf1 = index\n      if (hf['name'] === hardfork2) posHf2 = index\n      index += 1\n    }\n    return posHf1 >= posHf2 && posHf2 !== -1\n  }\n\n  /**\n   * Alias to hardforkGteHardfork when hardfork is set\n   * @param hardfork Hardfork name\n   * @returns True if hardfork set is greater than hardfork provided\n   */\n  gteHardfork(hardfork: string | Hardfork): boolean {\n    return this.hardforkGteHardfork(null, hardfork)\n  }\n\n  /**\n   * Returns the hardfork change block for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if unscheduled\n   */\n  hardforkBlock(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const block = this._getHardfork(hardfork)?.['block']\n    if (block === undefined || block === null) {\n      return null\n    }\n    return BigInt(block)\n  }\n\n  hardforkTimestamp(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const timestamp = this._getHardfork(hardfork)?.['timestamp']\n    if (timestamp === undefined || timestamp === null) {\n      return null\n    }\n    return BigInt(timestamp)\n  }\n\n  /**\n   * Returns the hardfork change block for eip\n   * @param eip EIP number\n   * @returns Block number or null if unscheduled\n   */\n  eipBlock(eip: number): bigint | null {\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1]\n      if ('eips' in hf) {\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (hf['eips'].includes(eip)) {\n          return this.hardforkBlock(hfChanges[0])\n        }\n      }\n    }\n    return null\n  }\n\n  /**\n   * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Total difficulty or null if no set\n   */\n  hardforkTTD(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const ttd = this._getHardfork(hardfork)?.['ttd']\n    if (ttd === undefined || ttd === null) {\n      return null\n    }\n    return BigInt(ttd)\n  }\n\n  /**\n   * True if block number provided is the hardfork (given or set) change block\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isHardforkBlock(blockNumber: BigIntLike, hardfork?: string | Hardfork): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const block = this.hardforkBlock(hardfork)\n    return typeof block === 'bigint' && block !== BigInt(0) ? block === blockNumber : false\n  }\n\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block timestamp, number or null if not available\n   */\n  nextHardforkBlockOrTimestamp(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const hfs = this.hardforks()\n    let hfIndex = hfs.findIndex((hf) => hf.name === hardfork)\n    // If the current hardfork is merge, go one behind as merge hf is not part of these\n    // calcs even if the merge hf block is set\n    if (hardfork === Hardfork.Merge) {\n      hfIndex -= 1\n    }\n    // Hardfork not found\n    if (hfIndex < 0) {\n      return null\n    }\n\n    let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block\n    currHfTimeOrBlock =\n      currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined\n        ? Number(currHfTimeOrBlock)\n        : null\n\n    const nextHf = hfs.slice(hfIndex + 1).find((hf) => {\n      let hfTimeOrBlock = hf.timestamp ?? hf.block\n      hfTimeOrBlock =\n        hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null\n      return (\n        hf.name !== Hardfork.Merge &&\n        hfTimeOrBlock !== null &&\n        hfTimeOrBlock !== undefined &&\n        hfTimeOrBlock !== currHfTimeOrBlock\n      )\n    })\n    // If no next hf found with valid block or timestamp return null\n    if (nextHf === undefined) {\n      return null\n    }\n\n    const nextHfBlock = nextHf.timestamp ?? nextHf.block\n    if (nextHfBlock === null || nextHfBlock === undefined) {\n      return null\n    }\n\n    return BigInt(nextHfBlock)\n  }\n\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if not available\n   * @deprecated\n   */\n  nextHardforkBlock(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    let hfBlock = this.hardforkBlock(hardfork)\n    // If this is a merge hardfork with block not set, then we fallback to previous hardfork\n    // to find the nextHardforkBlock\n    if (hfBlock === null && hardfork === Hardfork.Merge) {\n      const hfs = this.hardforks()\n      const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n      if (mergeIndex < 0) {\n        throw Error(`Merge hardfork should have been found`)\n      }\n      hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name)\n    }\n    if (hfBlock === null) {\n      return null\n    }\n    // Next fork block number or null if none available\n    // Logic: if accumulator is still null and on the first occurrence of\n    // a block greater than the current hfBlock set the accumulator,\n    // pass on the accumulator as the final result from this time on\n    const nextHfBlock = this.hardforks().reduce((acc: bigint | null, hf: HardforkConfig) => {\n      // We need to ignore the merge block in our next hardfork calc\n      const block = BigInt(\n        hf.block === null || (hf.ttd !== undefined && hf.ttd !== null) ? 0 : hf.block\n      )\n      // Typescript can't seem to follow that the hfBlock is not null at this point\n      return block > hfBlock! && acc === null ? block : acc\n    }, null)\n    return nextHfBlock\n  }\n\n  /**\n   * True if block number provided is the hardfork change block following the hardfork given or set\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isNextHardforkBlock(blockNumber: BigIntLike, hardfork?: string | Hardfork): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const nextHardforkBlock = this.nextHardforkBlock(hardfork)\n\n    return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber\n  }\n\n  /**\n   * Internal helper function to calculate a fork hash\n   * @param hardfork Hardfork name\n   * @param genesisHash Genesis block hash of the chain\n   * @returns Fork hash as hex string\n   */\n  _calcForkHash(hardfork: string | Hardfork, genesisHash: Buffer) {\n    let hfBuffer = Buffer.alloc(0)\n    let prevBlockOrTime = 0\n    for (const hf of this.hardforks()) {\n      const { block, timestamp, name } = hf\n      // Timestamp to be used for timestamp based hfs even if we may bundle\n      // block number with them retrospectively\n      let blockOrTime = timestamp ?? block\n      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null\n\n      // Skip for chainstart (0), not applied HFs (null) and\n      // when already applied on same blockOrTime HFs\n      // and on the merge since forkhash doesn't change on merge hf\n      if (\n        typeof blockOrTime === 'number' &&\n        blockOrTime !== 0 &&\n        blockOrTime !== prevBlockOrTime &&\n        name !== Hardfork.Merge\n      ) {\n        const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, '0'), 'hex')\n        hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer])\n        prevBlockOrTime = blockOrTime\n      }\n\n      if (hf.name === hardfork) break\n    }\n    const inputBuffer = Buffer.concat([genesisHash, hfBuffer])\n\n    // CRC32 delivers result as signed (negative) 32-bit integer,\n    // convert to hex string\n    const forkhash = intToBuffer(crc32Buffer(inputBuffer) >>> 0).toString('hex')\n    return `0x${forkhash}`\n  }\n\n  /**\n   * Returns an eth/64 compliant fork hash (EIP-2124)\n   * @param hardfork Hardfork name, optional if HF set\n   * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated\n   */\n  forkHash(hardfork?: string | Hardfork, genesisHash?: Buffer): string {\n    hardfork = hardfork ?? this._hardfork\n    const data = this._getHardfork(hardfork)\n    if (\n      data === null ||\n      (data?.block === null && data?.timestamp === undefined && data?.ttd === undefined)\n    ) {\n      const msg = 'No fork hash calculation possible for future hardfork'\n      throw new Error(msg)\n    }\n    if (data?.forkHash !== null && data?.forkHash !== undefined) {\n      return data.forkHash\n    }\n    if (!genesisHash) throw new Error('genesisHash required for forkHash calculation')\n    return this._calcForkHash(hardfork, genesisHash)\n  }\n\n  /**\n   *\n   * @param forkHash Fork hash as a hex string\n   * @returns Array with hardfork data (name, block, forkHash)\n   */\n  hardforkForForkHash(forkHash: string): HardforkConfig | null {\n    const resArray = this.hardforks().filter((hf: HardforkConfig) => {\n      return hf.forkHash === forkHash\n    })\n    return resArray.length >= 1 ? resArray[resArray.length - 1] : null\n  }\n\n  /**\n   * Sets any missing forkHashes on the passed-in {@link Common} instance\n   * @param common The {@link Common} to set the forkHashes for\n   * @param genesisHash The genesis block hash\n   */\n  setForkHashes(genesisHash: Buffer) {\n    for (const hf of this.hardforks()) {\n      const blockOrTime = hf.timestamp ?? hf.block\n      if (\n        (hf.forkHash === null || hf.forkHash === undefined) &&\n        ((blockOrTime !== null && blockOrTime !== undefined) || typeof hf.ttd !== 'undefined')\n      ) {\n        hf.forkHash = this.forkHash(hf.name, genesisHash)\n      }\n    }\n  }\n\n  /**\n   * Returns the Genesis parameters of the current chain\n   * @returns Genesis dictionary\n   */\n  genesis(): GenesisBlockConfig {\n    return this._chainParams.genesis\n  }\n\n  /**\n   * Returns the hardforks for current chain\n   * @returns {Array} Array with arrays of hardforks\n   */\n  hardforks(): HardforkConfig[] {\n    return this._chainParams.hardforks\n  }\n\n  /**\n   * Returns bootstrap nodes for the current chain\n   * @returns {Dictionary} Dict with bootstrap nodes\n   */\n  bootstrapNodes(): BootstrapNodeConfig[] {\n    return this._chainParams.bootstrapNodes\n  }\n\n  /**\n   * Returns DNS networks for the current chain\n   * @returns {String[]} Array of DNS ENR urls\n   */\n  dnsNetworks(): string[] {\n    return this._chainParams.dnsNetworks!\n  }\n\n  /**\n   * Returns the hardfork set\n   * @returns Hardfork name\n   */\n  hardfork(): string | Hardfork {\n    return this._hardfork\n  }\n\n  /**\n   * Returns the Id of current chain\n   * @returns chain Id\n   */\n  chainId(): bigint {\n    return BigInt(this._chainParams.chainId)\n  }\n\n  /**\n   * Returns the name of current chain\n   * @returns chain name (lower case)\n   */\n  chainName(): string {\n    return this._chainParams.name\n  }\n\n  /**\n   * Returns the Id of current network\n   * @returns network Id\n   */\n  networkId(): bigint {\n    return BigInt(this._chainParams.networkId)\n  }\n\n  /**\n   * Returns the active EIPs\n   * @returns List of EIPs\n   */\n  eips(): number[] {\n    return this._eips\n  }\n\n  /**\n   * Returns the consensus type of the network\n   * Possible values: \"pow\"|\"poa\"|\"pos\"\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusType(): string | ConsensusType {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['type']\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return value ?? this._chainParams['consensus']['type']\n  }\n\n  /**\n   * Returns the concrete consensus implementation\n   * algorithm or protocol for the network\n   * e.g. \"ethash\" for \"pow\" consensus type,\n   * \"clique\" for \"poa\" consensus type or\n   * \"casper\" for \"pos\" consensus type.\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusAlgorithm(): string | ConsensusAlgorithm {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['algorithm']\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return value ?? (this._chainParams['consensus']['algorithm'] as ConsensusAlgorithm)\n  }\n\n  /**\n   * Returns a dictionary with consensus configuration\n   * parameters based on the consensus algorithm\n   *\n   * Expected returns (parameters must be present in\n   * the respective chain json files):\n   *\n   * ethash: empty object\n   * clique: period, epoch\n   * casper: empty object\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusConfig(): { [key: string]: CliqueConfig | EthashConfig | CasperConfig } {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // The config parameter is named after the respective consensus algorithm\n        value = hfChanges[1]['consensus'][hfChanges[1]['consensus']['algorithm']]\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return (\n      value ?? this._chainParams['consensus'][this.consensusAlgorithm() as ConsensusAlgorithm] ?? {}\n    )\n  }\n\n  /**\n   * Returns a deep copy of this {@link Common} instance.\n   */\n  copy(): Common {\n    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this)\n    copy.removeAllListeners()\n    return copy\n  }\n\n  static _getInitializedChains(customChains?: ChainConfig[]): ChainsConfig {\n    const names: ChainName = {}\n    for (const [name, id] of Object.entries(Chain)) {\n      names[id] = name.toLowerCase()\n    }\n    const chains = { mainnet, ropsten, rinkeby, goerli, sepolia } as ChainsConfig\n    if (customChains) {\n      for (const chain of customChains) {\n        const { name } = chain\n        names[chain.chainId.toString()] = name\n        chains[name] = chain\n      }\n    }\n    chains.names = names\n    return chains\n  }\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map", "export * from './common'\nexport * from './enums'\nexport * from './types'\nexport * from './utils'\n", "import type { FeeMarketEIP1559Transaction } from './eip1559Transaction'\nimport type { AccessListEIP2930Transaction } from './eip2930Transaction'\nimport type { Transaction } from './legacyTransaction'\nimport type { Common } from '@ethereumjs/common'\nimport type { AddressLike, BigIntLike, BufferLike, PrefixedHexString } from '@ethereumjs/util'\n\n/**\n * Can be used in conjunction with {@link Transaction.supports}\n * to query on tx capabilities\n */\nexport enum Capability {\n  /**\n   * Tx supports EIP-155 replay protection\n   * See: [155](https://eips.ethereum.org/EIPS/eip-155) Replay Attack Protection EIP\n   */\n  EIP155ReplayProtection = 155,\n\n  /**\n   * Tx supports EIP-1559 gas fee market mechanism\n   * See: [1559](https://eips.ethereum.org/EIPS/eip-1559) Fee Market EIP\n   */\n  EIP1559FeeMarket = 1559,\n\n  /**\n   * Tx is a typed transaction as defined in EIP-2718\n   * See: [2718](https://eips.ethereum.org/EIPS/eip-2718) Transaction Type EIP\n   */\n  EIP2718TypedTransaction = 2718,\n\n  /**\n   * Tx supports access list generation as defined in EIP-2930\n   * See: [2930](https://eips.ethereum.org/EIPS/eip-2930) Access Lists EIP\n   */\n  EIP2930AccessLists = 2930,\n}\n\n/**\n * The options for initializing a {@link Transaction}.\n */\nexport interface TxOptions {\n  /**\n   * A {@link Common} object defining the chain and hardfork for the transaction.\n   *\n   * Object will be internally copied so that tx behavior don't incidentally\n   * change on future HF changes.\n   *\n   * Default: {@link Common} object set to `mainnet` and the default hardfork as defined in the {@link Common} class.\n   *\n   * Current default hardfork: `istanbul`\n   */\n  common?: Common\n  /**\n   * A transaction object by default gets frozen along initialization. This gives you\n   * strong additional security guarantees on the consistency of the tx parameters.\n   * It also enables tx hash caching when the `hash()` method is called multiple times.\n   *\n   * If you need to deactivate the tx freeze - e.g. because you want to subclass tx and\n   * add additional properties - it is strongly encouraged that you do the freeze yourself\n   * within your code instead.\n   *\n   * Default: true\n   */\n  freeze?: boolean\n\n  /**\n   * Allows unlimited contract code-size init while debugging. This (partially) disables EIP-3860.\n   * Gas cost for initcode size analysis will still be charged. Use with caution.\n   */\n  allowUnlimitedInitCodeSize?: boolean\n}\n\n/*\n * Access List types\n */\n\nexport type AccessListItem = {\n  address: PrefixedHexString\n  storageKeys: PrefixedHexString[]\n}\n\n/*\n * An Access List as a tuple of [address: Buffer, storageKeys: Buffer[]]\n */\nexport type AccessListBufferItem = [Buffer, Buffer[]]\nexport type AccessListBuffer = AccessListBufferItem[]\nexport type AccessList = AccessListItem[]\n\nexport function isAccessListBuffer(\n  input: AccessListBuffer | AccessList\n): input is AccessListBuffer {\n  if (input.length === 0) {\n    return true\n  }\n  const firstItem = input[0]\n  if (Array.isArray(firstItem)) {\n    return true\n  }\n  return false\n}\n\nexport function isAccessList(input: AccessListBuffer | AccessList): input is AccessList {\n  return !isAccessListBuffer(input) // This is exactly the same method, except the output is negated.\n}\n\n/**\n * Encompassing type for all transaction types.\n *\n * Note that this also includes legacy txs which are\n * referenced as {@link Transaction} for compatibility reasons.\n */\nexport type TypedTransaction =\n  | Transaction\n  | AccessListEIP2930Transaction\n  | FeeMarketEIP1559Transaction\n\n/**\n * Legacy {@link Transaction} Data\n */\nexport type TxData = {\n  /**\n   * The transaction's nonce.\n   */\n  nonce?: BigIntLike\n\n  /**\n   * The transaction's gas price.\n   */\n  gasPrice?: BigIntLike | null\n\n  /**\n   * The transaction's gas limit.\n   */\n  gasLimit?: BigIntLike\n\n  /**\n   * The transaction's the address is sent to.\n   */\n  to?: AddressLike\n\n  /**\n   * The amount of Ether sent.\n   */\n  value?: BigIntLike\n\n  /**\n   * This will contain the data of the message or the init of a contract.\n   */\n  data?: BufferLike\n\n  /**\n   * EC recovery ID.\n   */\n  v?: BigIntLike\n\n  /**\n   * EC signature parameter.\n   */\n  r?: BigIntLike\n\n  /**\n   * EC signature parameter.\n   */\n  s?: BigIntLike\n\n  /**\n   * The transaction type\n   */\n\n  type?: BigIntLike\n}\n\n/**\n * {@link AccessListEIP2930Transaction} data.\n */\nexport interface AccessListEIP2930TxData extends TxData {\n  /**\n   * The transaction's chain ID\n   */\n  chainId?: BigIntLike\n\n  /**\n   * The access list which contains the addresses/storage slots which the transaction wishes to access\n   */\n  accessList?: AccessListBuffer | AccessList | null\n}\n\n/**\n * {@link FeeMarketEIP1559Transaction} data.\n */\nexport interface FeeMarketEIP1559TxData extends AccessListEIP2930TxData {\n  /**\n   * The transaction's gas price, inherited from {@link Transaction}.  This property is not used for EIP1559\n   * transactions and should always be undefined for this specific transaction type.\n   */\n  gasPrice?: never | null\n  /**\n   * The maximum inclusion fee per gas (this fee is given to the miner)\n   */\n  maxPriorityFeePerGas?: BigIntLike\n  /**\n   * The maximum total fee\n   */\n  maxFeePerGas?: BigIntLike\n}\n\n/**\n * Buffer values array for a legacy {@link Transaction}\n */\nexport type TxValuesArray = Buffer[]\n\n/**\n * Buffer values array for an {@link AccessListEIP2930Transaction}\n */\nexport type AccessListEIP2930ValuesArray = [\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  AccessListBuffer,\n  Buffer?,\n  Buffer?,\n  Buffer?\n]\n\n/**\n * Buffer values array for a {@link FeeMarketEIP1559Transaction}\n */\nexport type FeeMarketEIP1559ValuesArray = [\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  AccessListBuffer,\n  Buffer?,\n  Buffer?,\n  Buffer?\n]\n\ntype JsonAccessListItem = { address: string; storageKeys: string[] }\n\n/**\n * Generic interface for all tx types with a\n * JSON representation of a transaction.\n *\n * Note that all values are marked as optional\n * and not all the values are present on all tx types\n * (an EIP1559 tx e.g. lacks a `gasPrice`).\n */\nexport interface JsonTx {\n  nonce?: string\n  gasPrice?: string\n  gasLimit?: string\n  to?: string\n  data?: string\n  v?: string\n  r?: string\n  s?: string\n  value?: string\n  chainId?: string\n  accessList?: JsonAccessListItem[]\n  type?: string\n  maxPriorityFeePerGas?: string\n  maxFeePerGas?: string\n  maxFeePerDataGas?: string\n  versionedHashes?: string[]\n}\n\n/*\n * Based on https://ethereum.org/en/developers/docs/apis/json-rpc/\n */\nexport interface JsonRpcTx {\n  blockHash: string | null // DATA, 32 Bytes - hash of the block where this transaction was in. null when it's pending.\n  blockNumber: string | null // QUANTITY - block number where this transaction was in. null when it's pending.\n  from: string // DATA, 20 Bytes - address of the sender.\n  gas: string // QUANTITY - gas provided by the sender.\n  gasPrice: string // QUANTITY - gas price provided by the sender in wei. If EIP-1559 tx, defaults to maxFeePerGas.\n  maxFeePerGas?: string // QUANTITY - max total fee per gas provided by the sender in wei.\n  maxPriorityFeePerGas?: string // QUANTITY - max priority fee per gas provided by the sender in wei.\n  type: string // QUANTITY - EIP-2718 Typed Transaction type\n  accessList?: JsonTx['accessList'] // EIP-2930 access list\n  chainId?: string // Chain ID that this transaction is valid on.\n  hash: string // DATA, 32 Bytes - hash of the transaction.\n  input: string // DATA - the data send along with the transaction.\n  nonce: string // QUANTITY - the number of transactions made by the sender prior to this one.\n  to: string | null /// DATA, 20 Bytes - address of the receiver. null when it's a contract creation transaction.\n  transactionIndex: string | null // QUANTITY - integer of the transactions index position in the block. null when it's pending.\n  value: string // QUANTITY - value transferred in Wei.\n  v: string // QUANTITY - ECDSA recovery id\n  r: string // DATA, 32 Bytes - ECDSA signature r\n  s: string // DATA, 32 Bytes - ECDSA signature s\n  maxFeePerDataGas?: string // QUANTITY - max data fee for blob transactions\n  versionedHashes?: string[] // DATA - array of 32 byte versioned hashes for blob transactions\n}\n", "import { bufferToHex, setLengthLeft, toBuffer } from '@ethereumjs/util'\n\nimport { isAccessList } from './types'\n\nimport type { AccessList, AccessListBuffer, AccessListItem } from './types'\nimport type { Common } from '@ethereumjs/common'\n\nexport function checkMaxInitCodeSize(common: Common, length: number) {\n  const maxInitCodeSize = common.param('vm', 'maxInitCodeSize')\n  if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {\n    throw new Error(\n      `the initcode size of this transaction is too large: it is ${length} while the max is ${common.param(\n        'vm',\n        'maxInitCodeSize'\n      )}`\n    )\n  }\n}\n\nexport class AccessLists {\n  public static getAccessListData(accessList: AccessListBuffer | AccessList) {\n    let AccessListJSON\n    let bufferAccessList\n    if (isAccessList(accessList)) {\n      AccessListJSON = accessList\n      const newAccessList: AccessListBuffer = []\n\n      for (let i = 0; i < accessList.length; i++) {\n        const item: AccessListItem = accessList[i]\n        const addressBuffer = toBuffer(item.address)\n        const storageItems: Buffer[] = []\n        for (let index = 0; index < item.storageKeys.length; index++) {\n          storageItems.push(toBuffer(item.storageKeys[index]))\n        }\n        newAccessList.push([addressBuffer, storageItems])\n      }\n      bufferAccessList = newAccessList\n    } else {\n      bufferAccessList = accessList ?? []\n      // build the JSON\n      const json: AccessList = []\n      for (let i = 0; i < bufferAccessList.length; i++) {\n        const data = bufferAccessList[i]\n        const address = bufferToHex(data[0])\n        const storageKeys: string[] = []\n        for (let item = 0; item < data[1].length; item++) {\n          storageKeys.push(bufferToHex(data[1][item]))\n        }\n        const jsonItem: AccessListItem = {\n          address,\n          storageKeys,\n        }\n        json.push(jsonItem)\n      }\n      AccessListJSON = json\n    }\n\n    return {\n      AccessListJSON,\n      accessList: bufferAccessList,\n    }\n  }\n\n  public static verifyAccessList(accessList: AccessListBuffer) {\n    for (let key = 0; key < accessList.length; key++) {\n      const accessListItem = accessList[key]\n      const address = <Buffer>accessListItem[0]\n      const storageSlots = <Buffer[]>accessListItem[1]\n      if ((<any>accessListItem)[2] !== undefined) {\n        throw new Error(\n          'Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.'\n        )\n      }\n      if (address.length !== 20) {\n        throw new Error('Invalid EIP-2930 transaction: address length should be 20 bytes')\n      }\n      for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {\n        if (storageSlots[storageSlot].length !== 32) {\n          throw new Error('Invalid EIP-2930 transaction: storage slot length should be 32 bytes')\n        }\n      }\n    }\n  }\n\n  public static getAccessListJSON(accessList: AccessListBuffer) {\n    const accessListJSON = []\n    for (let index = 0; index < accessList.length; index++) {\n      const item: any = accessList[index]\n      const JSONItem: any = {\n        address: '0x' + setLengthLeft(<Buffer>item[0], 20).toString('hex'),\n        storageKeys: [],\n      }\n      const storageSlots: Buffer[] = item[1]\n      for (let slot = 0; slot < storageSlots.length; slot++) {\n        const storageSlot = storageSlots[slot]\n        JSONItem.storageKeys.push('0x' + setLengthLeft(storageSlot, 32).toString('hex'))\n      }\n      accessListJSON.push(JSONItem)\n    }\n    return accessListJSON\n  }\n\n  public static getDataFeeEIP2930(accessList: AccessListBuffer, common: Common): number {\n    const accessListStorageKeyCost = common.param('gasPrices', 'accessListStorageKeyCost')\n    const accessListAddressCost = common.param('gasPrices', 'accessListAddressCost')\n\n    let slots = 0\n    for (let index = 0; index < accessList.length; index++) {\n      const item = accessList[index]\n      const storageSlots = item[1]\n      slots += storageSlots.length\n    }\n\n    const addresses = accessList.length\n    return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost)\n  }\n}\n", "import { Chain, Common, Hardfork } from '@ethereumjs/common'\nimport {\n  Address,\n  MAX_INTEGER,\n  MAX_UINT64,\n  SECP256K1_ORDER_DIV_2,\n  bufferToBigInt,\n  bufferToHex,\n  ecsign,\n  publicToAddress,\n  toBuffer,\n  unpadBuffer,\n} from '@ethereumjs/util'\n\nimport { Capability } from './types'\nimport { checkMaxInitCodeSize } from './util'\n\nimport type {\n  AccessListEIP2930TxData,\n  AccessListEIP2930ValuesArray,\n  FeeMarketEIP1559TxData,\n  FeeMarketEIP1559ValuesArray,\n  JsonTx,\n  TxData,\n  TxOptions,\n  TxValuesArray,\n} from './types'\nimport type { BigIntLike } from '@ethereumjs/util'\n\ninterface TransactionCache {\n  hash: Buffer | undefined\n  dataFee?: {\n    value: bigint\n    hardfork: string | Hardfork\n  }\n}\n\n/**\n * This base class will likely be subject to further\n * refactoring along the introduction of additional tx types\n * on the Ethereum network.\n *\n * It is therefore not recommended to use directly.\n */\nexport abstract class BaseTransaction<TransactionObject> {\n  private readonly _type: number\n\n  public readonly nonce: bigint\n  public readonly gasLimit: bigint\n  public readonly to?: Address\n  public readonly value: bigint\n  public readonly data: Buffer\n\n  public readonly v?: bigint\n  public readonly r?: bigint\n  public readonly s?: bigint\n\n  public readonly common!: Common\n\n  protected cache: TransactionCache = {\n    hash: undefined,\n    dataFee: undefined,\n  }\n\n  protected readonly txOptions: TxOptions\n\n  /**\n   * List of tx type defining EIPs,\n   * e.g. 1559 (fee market) and 2930 (access lists)\n   * for FeeMarketEIP1559Transaction objects\n   */\n  protected activeCapabilities: number[] = []\n\n  /**\n   * The default chain the tx falls back to if no Common\n   * is provided and if the chain can't be derived from\n   * a passed in chainId (only EIP-2718 typed txs) or\n   * EIP-155 signature (legacy txs).\n   *\n   * @hidden\n   */\n  protected DEFAULT_CHAIN = Chain.Mainnet\n\n  /**\n   * The default HF if the tx type is active on that HF\n   * or the first greater HF where the tx is active.\n   *\n   * @hidden\n   */\n  protected DEFAULT_HARDFORK: string | Hardfork = Hardfork.Merge\n\n  constructor(txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData, opts: TxOptions) {\n    const { nonce, gasLimit, to, value, data, v, r, s, type } = txData\n    this._type = Number(bufferToBigInt(toBuffer(type)))\n\n    this.txOptions = opts\n\n    const toB = toBuffer(to === '' ? '0x' : to)\n    const vB = toBuffer(v === '' ? '0x' : v)\n    const rB = toBuffer(r === '' ? '0x' : r)\n    const sB = toBuffer(s === '' ? '0x' : s)\n\n    this.nonce = bufferToBigInt(toBuffer(nonce === '' ? '0x' : nonce))\n    this.gasLimit = bufferToBigInt(toBuffer(gasLimit === '' ? '0x' : gasLimit))\n    this.to = toB.length > 0 ? new Address(toB) : undefined\n    this.value = bufferToBigInt(toBuffer(value === '' ? '0x' : value))\n    this.data = toBuffer(data === '' ? '0x' : data)\n\n    this.v = vB.length > 0 ? bufferToBigInt(vB) : undefined\n    this.r = rB.length > 0 ? bufferToBigInt(rB) : undefined\n    this.s = sB.length > 0 ? bufferToBigInt(sB) : undefined\n\n    this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s })\n\n    // geth limits gasLimit to 2^64-1\n    this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64)\n\n    // EIP-2681 limits nonce to 2^64-1 (cannot equal 2^64-1)\n    this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true)\n\n    const createContract = this.to === undefined || this.to === null\n    const allowUnlimitedInitCodeSize = opts.allowUnlimitedInitCodeSize ?? false\n    const common = opts.common ?? this._getCommon()\n    if (createContract && common.isActivatedEIP(3860) && allowUnlimitedInitCodeSize === false) {\n      checkMaxInitCodeSize(common, this.data.length)\n    }\n  }\n\n  /**\n   * Returns the transaction type.\n   *\n   * Note: legacy txs will return tx type `0`.\n   */\n  get type() {\n    return this._type\n  }\n\n  /**\n   * Checks if a tx type defining capability is active\n   * on a tx, for example the EIP-1559 fee market mechanism\n   * or the EIP-2930 access list feature.\n   *\n   * Note that this is different from the tx type itself,\n   * so EIP-2930 access lists can very well be active\n   * on an EIP-1559 tx for example.\n   *\n   * This method can be useful for feature checks if the\n   * tx type is unknown (e.g. when instantiated with\n   * the tx factory).\n   *\n   * See `Capabilites` in the `types` module for a reference\n   * on all supported capabilities.\n   */\n  supports(capability: Capability) {\n    return this.activeCapabilities.includes(capability)\n  }\n\n  /**\n   * Checks if the transaction has the minimum amount of gas required\n   * (DataFee + TxFee + Creation Fee).\n   */\n  validate(): boolean\n  validate(stringError: false): boolean\n  validate(stringError: true): string[]\n  validate(stringError: boolean = false): boolean | string[] {\n    const errors = []\n\n    if (this.getBaseFee() > this.gasLimit) {\n      errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`)\n    }\n\n    if (this.isSigned() && !this.verifySignature()) {\n      errors.push('Invalid Signature')\n    }\n\n    return stringError ? errors : errors.length === 0\n  }\n\n  protected _validateYParity() {\n    const { v } = this\n    if (v !== undefined && v !== BigInt(0) && v !== BigInt(1)) {\n      const msg = this._errorMsg('The y-parity of the transaction should either be 0 or 1')\n      throw new Error(msg)\n    }\n  }\n\n  /**\n   * EIP-2: All transaction signatures whose s-value is greater than secp256k1n/2are considered invalid.\n   * Reasoning: https://ethereum.stackexchange.com/a/55728\n   */\n  protected _validateHighS() {\n    const { s } = this\n    if (this.common.gteHardfork('homestead') && s !== undefined && s > SECP256K1_ORDER_DIV_2) {\n      const msg = this._errorMsg(\n        'Invalid Signature: s-values greater than secp256k1n/2 are considered invalid'\n      )\n      throw new Error(msg)\n    }\n  }\n\n  /**\n   * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)\n   */\n  getBaseFee(): bigint {\n    const txFee = this.common.param('gasPrices', 'tx')\n    let fee = this.getDataFee()\n    if (txFee) fee += txFee\n    if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {\n      const txCreationFee = this.common.param('gasPrices', 'txCreation')\n      if (txCreationFee) fee += txCreationFee\n    }\n    return fee\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    const txDataZero = this.common.param('gasPrices', 'txDataZero')\n    const txDataNonZero = this.common.param('gasPrices', 'txDataNonZero')\n\n    let cost = BigInt(0)\n    for (let i = 0; i < this.data.length; i++) {\n      this.data[i] === 0 ? (cost += txDataZero) : (cost += txDataNonZero)\n    }\n\n    if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {\n      const dataLength = BigInt(Math.ceil(this.data.length / 32))\n      const initCodeCost = this.common.param('gasPrices', 'initCodeWordCost') * dataLength\n      cost += initCodeCost\n    }\n\n    return cost\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  abstract getUpfrontCost(): bigint\n\n  /**\n   * If the tx's `to` is to the creation address\n   */\n  toCreationAddress(): boolean {\n    return this.to === undefined || this.to.buf.length === 0\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of this transaction, in order.\n   *\n   * Use {@link BaseTransaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link BaseTransaction.getMessageToSign}.\n   */\n  abstract raw(): TxValuesArray | AccessListEIP2930ValuesArray | FeeMarketEIP1559ValuesArray\n\n  /**\n   * Returns the encoding of the transaction.\n   */\n  abstract serialize(): Buffer\n\n  // Returns the unsigned tx (hashed or raw), which is used to sign the transaction.\n  //\n  // Note: do not use code docs here since VS Studio is then not able to detect the\n  // comments from the inherited methods\n  abstract getMessageToSign(hashMessage: false): Buffer | Buffer[]\n  abstract getMessageToSign(hashMessage?: true): Buffer\n\n  abstract hash(): Buffer\n\n  abstract getMessageToVerifySignature(): Buffer\n\n  public isSigned(): boolean {\n    const { v, r, s } = this\n    if (v === undefined || r === undefined || s === undefined) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * Determines if the signature is valid\n   */\n  verifySignature(): boolean {\n    try {\n      // Main signature verification is done in `getSenderPublicKey()`\n      const publicKey = this.getSenderPublicKey()\n      return unpadBuffer(publicKey).length !== 0\n    } catch (e: any) {\n      return false\n    }\n  }\n\n  /**\n   * Returns the sender's address\n   */\n  getSenderAddress(): Address {\n    return new Address(publicToAddress(this.getSenderPublicKey()))\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  abstract getSenderPublicKey(): Buffer\n\n  /**\n   * Signs a transaction.\n   *\n   * Note that the signed tx is returned as a new object,\n   * use as follows:\n   * ```javascript\n   * const signedTx = tx.sign(privateKey)\n   * ```\n   */\n  sign(privateKey: Buffer): TransactionObject {\n    if (privateKey.length !== 32) {\n      const msg = this._errorMsg('Private key must be 32 bytes in length.')\n      throw new Error(msg)\n    }\n\n    // Hack for the constellation that we have got a legacy tx after spuriousDragon with a non-EIP155 conforming signature\n    // and want to recreate a signature (where EIP155 should be applied)\n    // Leaving this hack lets the legacy.spec.ts -> sign(), verifySignature() test fail\n    // 2021-06-23\n    let hackApplied = false\n    if (\n      this.type === 0 &&\n      this.common.gteHardfork('spuriousDragon') &&\n      !this.supports(Capability.EIP155ReplayProtection)\n    ) {\n      this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n      hackApplied = true\n    }\n\n    const msgHash = this.getMessageToSign(true)\n    const { v, r, s } = ecsign(msgHash, privateKey)\n    const tx = this._processSignature(v, r, s)\n\n    // Hack part 2\n    if (hackApplied) {\n      const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection)\n      if (index > -1) {\n        this.activeCapabilities.splice(index, 1)\n      }\n    }\n\n    return tx\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  abstract toJSON(): JsonTx\n\n  // Accept the v,r,s values from the `sign` method, and convert this into a TransactionObject\n  protected abstract _processSignature(v: bigint, r: Buffer, s: Buffer): TransactionObject\n\n  /**\n   * Does chain ID checks on common and returns a common\n   * to be used on instantiation\n   * @hidden\n   *\n   * @param common - {@link Common} instance from tx options\n   * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)\n   */\n  protected _getCommon(common?: Common, chainId?: BigIntLike) {\n    // Chain ID provided\n    if (chainId !== undefined) {\n      const chainIdBigInt = bufferToBigInt(toBuffer(chainId))\n      if (common) {\n        if (common.chainId() !== chainIdBigInt) {\n          const msg = this._errorMsg('The chain ID does not match the chain ID of Common')\n          throw new Error(msg)\n        }\n        // Common provided, chain ID does match\n        // -> Return provided Common\n        return common.copy()\n      } else {\n        if (Common.isSupportedChainId(chainIdBigInt)) {\n          // No Common, chain ID supported by Common\n          // -> Instantiate Common with chain ID\n          return new Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK })\n        } else {\n          // No Common, chain ID not supported by Common\n          // -> Instantiate custom Common derived from DEFAULT_CHAIN\n          return Common.custom(\n            {\n              name: 'custom-chain',\n              networkId: chainIdBigInt,\n              chainId: chainIdBigInt,\n            },\n            { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK }\n          )\n        }\n      }\n    } else {\n      // No chain ID provided\n      // -> return Common provided or create new default Common\n      return (\n        common?.copy() ?? new Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK })\n      )\n    }\n  }\n\n  /**\n   * Validates that an object with BigInt values cannot exceed the specified bit limit.\n   * @param values Object containing string keys and BigInt values\n   * @param bits Number of bits to check (64 or 256)\n   * @param cannotEqual Pass true if the number also cannot equal one less the maximum value\n   */\n  protected _validateCannotExceedMaxInteger(\n    values: { [key: string]: bigint | undefined },\n    bits = 256,\n    cannotEqual = false\n  ) {\n    for (const [key, value] of Object.entries(values)) {\n      switch (bits) {\n        case 64:\n          if (cannotEqual) {\n            if (value !== undefined && value >= MAX_UINT64) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value !== undefined && value > MAX_UINT64) {\n              const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`)\n              throw new Error(msg)\n            }\n          }\n          break\n        case 256:\n          if (cannotEqual) {\n            if (value !== undefined && value >= MAX_INTEGER) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value !== undefined && value > MAX_INTEGER) {\n              const msg = this._errorMsg(\n                `${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          }\n          break\n        default: {\n          const msg = this._errorMsg('unimplemented bits value')\n          throw new Error(msg)\n        }\n      }\n    }\n  }\n\n  protected static _validateNotArray(values: { [key: string]: any }) {\n    const txDataKeys = [\n      'nonce',\n      'gasPrice',\n      'gasLimit',\n      'to',\n      'value',\n      'data',\n      'v',\n      'r',\n      's',\n      'type',\n      'baseFee',\n      'maxFeePerGas',\n      'chainId',\n    ]\n    for (const [key, value] of Object.entries(values)) {\n      if (txDataKeys.includes(key)) {\n        if (Array.isArray(value)) {\n          throw new Error(`${key} cannot be an array`)\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public abstract errorStr(): string\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected abstract _errorMsg(msg: string): string\n\n  /**\n   * Returns the shared error postfix part for _error() method\n   * tx type implementations.\n   */\n  protected _getSharedErrorPostfix() {\n    let hash = ''\n    try {\n      hash = this.isSigned() ? bufferToHex(this.hash()) : 'not available (unsigned)'\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let isSigned = ''\n    try {\n      isSigned = this.isSigned().toString()\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let hf = ''\n    try {\n      hf = this.common.hardfork()\n    } catch (e: any) {\n      hf = 'error'\n    }\n\n    let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `\n    postfix += `signed=${isSigned} hf=${hf}`\n\n    return postfix\n  }\n}\n", "import { RLP } from '@ethereumjs/rlp'\nimport {\n  MAX_INTEGER,\n  arrToBufArr,\n  bigIntToHex,\n  bigIntToUnpaddedBuffer,\n  bufArrToArr,\n  bufferToBigInt,\n  ecrecover,\n  toBuffer,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak'\n\nimport { BaseTransaction } from './baseTransaction'\nimport { AccessLists } from './util'\n\nimport type {\n  AccessList,\n  AccessListBuffer,\n  FeeMarketEIP1559TxData,\n  FeeMarketEIP1559ValuesArray,\n  JsonTx,\n  TxOptions,\n} from './types'\nimport type { Common } from '@ethereumjs/common'\n\nconst TRANSACTION_TYPE = 2\nconst TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex')\n\n/**\n * Typed transaction with a new gas fee market mechanism\n *\n * - TransactionType: 2\n * - EIP: [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)\n */\nexport class FeeMarketEIP1559Transaction extends BaseTransaction<FeeMarketEIP1559Transaction> {\n  public readonly chainId: bigint\n  public readonly accessList: AccessListBuffer\n  public readonly AccessListJSON: AccessList\n  public readonly maxPriorityFeePerGas: bigint\n  public readonly maxFeePerGas: bigint\n\n  public readonly common: Common\n\n  /**\n   * The default HF if the tx type is active on that HF\n   * or the first greater HF where the tx is active.\n   *\n   * @hidden\n   */\n  protected DEFAULT_HARDFORK = 'london'\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, v, r, s }\n   *\n   * Notes:\n   * - `chainId` will be set automatically if not provided\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: FeeMarketEIP1559TxData, opts: TxOptions = {}) {\n    return new FeeMarketEIP1559Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS])`\n   */\n  public static fromSerializedTx(serialized: Buffer, opts: TxOptions = {}) {\n    if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized\n          .slice(0, 1)\n          .toString('hex')}`\n      )\n    }\n\n    const values = arrToBufArr(RLP.decode(serialized.slice(1)))\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array')\n    }\n\n    return FeeMarketEIP1559Transaction.fromValuesArray(values as any, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS]`\n   */\n  public static fromValuesArray(values: FeeMarketEIP1559ValuesArray, opts: TxOptions = {}) {\n    if (values.length !== 9 && values.length !== 12) {\n      throw new Error(\n        'Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).'\n      )\n    }\n\n    const [\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gasLimit,\n      to,\n      value,\n      data,\n      accessList,\n      v,\n      r,\n      s,\n    ] = values\n\n    this._validateNotArray({ chainId, v })\n    validateNoLeadingZeroes({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s })\n\n    return new FeeMarketEIP1559Transaction(\n      {\n        chainId: bufferToBigInt(chainId),\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gasLimit,\n        to,\n        value,\n        data,\n        accessList: accessList ?? [],\n        v: v !== undefined ? bufferToBigInt(v) : undefined, // EIP2930 supports v's with value 0 (empty Buffer)\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: FeeMarketEIP1559TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TRANSACTION_TYPE }, opts)\n    const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData\n\n    this.common = this._getCommon(opts.common, chainId)\n    this.chainId = this.common.chainId()\n\n    if (this.common.isActivatedEIP(1559) === false) {\n      throw new Error('EIP-1559 not enabled on Common')\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930])\n\n    // Populate the access list fields\n    const accessListData = AccessLists.getAccessListData(accessList ?? [])\n    this.accessList = accessListData.accessList\n    this.AccessListJSON = accessListData.AccessListJSON\n    // Verify the access list format.\n    AccessLists.verifyAccessList(this.accessList)\n\n    this.maxFeePerGas = bufferToBigInt(toBuffer(maxFeePerGas === '' ? '0x' : maxFeePerGas))\n    this.maxPriorityFeePerGas = bufferToBigInt(\n      toBuffer(maxPriorityFeePerGas === '' ? '0x' : maxPriorityFeePerGas)\n    )\n\n    this._validateCannotExceedMaxInteger({\n      maxFeePerGas: this.maxFeePerGas,\n      maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n    })\n\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)')\n      throw new Error(msg)\n    }\n\n    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\n      const msg = this._errorMsg(\n        'maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)'\n      )\n      throw new Error(msg)\n    }\n\n    this._validateYParity()\n    this._validateHighS()\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {\n      return this.cache.dataFee.value\n    }\n\n    let cost = super.getDataFee()\n    cost += BigInt(AccessLists.getDataFeeEIP2930(this.accessList, this.common))\n\n    if (Object.isFrozen(this)) {\n      this.cache.dataFee = {\n        value: cost,\n        hardfork: this.common.hardfork(),\n      }\n    }\n\n    return cost\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   * @param baseFee The base fee of the block (will be set to 0 if not provided)\n   */\n  getUpfrontCost(baseFee: bigint = BigInt(0)): bigint {\n    const prio = this.maxPriorityFeePerGas\n    const maxBase = this.maxFeePerGas - baseFee\n    const inclusionFeePerGas = prio < maxBase ? prio : maxBase\n    const gasPrice = inclusionFeePerGas + baseFee\n    return this.gasLimit * gasPrice + this.value\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of the EIP-1559 transaction, in order.\n   *\n   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS]`\n   *\n   * Use {@link FeeMarketEIP1559Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link FeeMarketEIP1559Transaction.getMessageToSign}.\n   */\n  raw(): FeeMarketEIP1559ValuesArray {\n    return [\n      bigIntToUnpaddedBuffer(this.chainId),\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.maxPriorityFeePerGas),\n      bigIntToUnpaddedBuffer(this.maxFeePerGas),\n      bigIntToUnpaddedBuffer(this.gasLimit),\n      this.to !== undefined ? this.to.buf : Buffer.from([]),\n      bigIntToUnpaddedBuffer(this.value),\n      this.data,\n      this.accessList,\n      this.v !== undefined ? bigIntToUnpaddedBuffer(this.v) : Buffer.from([]),\n      this.r !== undefined ? bigIntToUnpaddedBuffer(this.r) : Buffer.from([]),\n      this.s !== undefined ? bigIntToUnpaddedBuffer(this.s) : Buffer.from([]),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the EIP-1559 transaction.\n   *\n   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS])`\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize(): Buffer {\n    const base = this.raw()\n    return Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n  }\n\n  /**\n   * Returns the serialized unsigned tx (hashed or raw), which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input\n   * ```\n   *\n   * @param hashMessage - Return hashed message if set to true (default: true)\n   */\n  getMessageToSign(hashMessage = true): Buffer {\n    const base = this.raw().slice(0, 9)\n    const message = Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n    if (hashMessage) {\n      return Buffer.from(keccak256(message))\n    } else {\n      return message\n    }\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link FeeMarketEIP1559Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  public hash(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call hash method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    if (Object.isFrozen(this)) {\n      if (!this.cache.hash) {\n        this.cache.hash = Buffer.from(keccak256(this.serialize()))\n      }\n      return this.cache.hash\n    }\n\n    return Buffer.from(keccak256(this.serialize()))\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  public getMessageToVerifySignature(): Buffer {\n    return this.getMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  public getSenderPublicKey(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call this method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    const msgHash = this.getMessageToVerifySignature()\n    const { v, r, s } = this\n\n    this._validateHighS()\n\n    try {\n      return ecrecover(\n        msgHash,\n        v! + BigInt(27), // Recover the 27 which was stripped from ecsign\n        bigIntToUnpaddedBuffer(r!),\n        bigIntToUnpaddedBuffer(s!)\n      )\n    } catch (e: any) {\n      const msg = this._errorMsg('Invalid Signature')\n      throw new Error(msg)\n    }\n  }\n\n  _processSignature(v: bigint, r: Buffer, s: Buffer) {\n    const opts = { ...this.txOptions, common: this.common }\n\n    return FeeMarketEIP1559Transaction.fromTxData(\n      {\n        chainId: this.chainId,\n        nonce: this.nonce,\n        maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n        maxFeePerGas: this.maxFeePerGas,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList,\n        v: v - BigInt(27), // This looks extremely hacky: @ethereumjs/util actually adds 27 to the value, the recovery bit is either 0 or 1.\n        r: bufferToBigInt(r),\n        s: bufferToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON(): JsonTx {\n    const accessListJSON = AccessLists.getAccessListJSON(this.accessList)\n\n    return {\n      chainId: bigIntToHex(this.chainId),\n      nonce: bigIntToHex(this.nonce),\n      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),\n      maxFeePerGas: bigIntToHex(this.maxFeePerGas),\n      gasLimit: bigIntToHex(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: bigIntToHex(this.value),\n      data: '0x' + this.data.toString('hex'),\n      accessList: accessListJSON,\n      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,\n      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,\n      s: this.s !== undefined ? bigIntToHex(this.s) : undefined,\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return `${msg} (${this.errorStr()})`\n  }\n}\n", "import { RLP } from '@ethereumjs/rlp'\nimport {\n  MAX_INTEGER,\n  arrToBufArr,\n  bigIntToHex,\n  bigIntToUnpaddedBuffer,\n  bufArrToArr,\n  bufferToBigInt,\n  ecrecover,\n  toBuffer,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak'\n\nimport { BaseTransaction } from './baseTransaction'\nimport { AccessLists } from './util'\n\nimport type {\n  AccessList,\n  AccessListBuffer,\n  AccessListEIP2930TxData,\n  AccessListEIP2930ValuesArray,\n  JsonTx,\n  TxOptions,\n} from './types'\nimport type { Common } from '@ethereumjs/common'\n\nconst TRANSACTION_TYPE = 1\nconst TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex')\n\n/**\n * Typed transaction with optional access lists\n *\n * - TransactionType: 1\n * - EIP: [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930)\n */\nexport class AccessListEIP2930Transaction extends BaseTransaction<AccessListEIP2930Transaction> {\n  public readonly chainId: bigint\n  public readonly accessList: AccessListBuffer\n  public readonly AccessListJSON: AccessList\n  public readonly gasPrice: bigint\n\n  public readonly common: Common\n\n  /**\n   * The default HF if the tx type is active on that HF\n   * or the first greater HF where the tx is active.\n   *\n   * @hidden\n   */\n  protected DEFAULT_HARDFORK = 'berlin'\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * v, r, s }\n   *\n   * Notes:\n   * - `chainId` will be set automatically if not provided\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: AccessListEIP2930TxData, opts: TxOptions = {}) {\n    return new AccessListEIP2930Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   */\n  public static fromSerializedTx(serialized: Buffer, opts: TxOptions = {}) {\n    if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized\n          .slice(0, 1)\n          .toString('hex')}`\n      )\n    }\n\n    const values = arrToBufArr(RLP.decode(Uint8Array.from(serialized.slice(1))))\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array')\n    }\n\n    return AccessListEIP2930Transaction.fromValuesArray(values as any, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   */\n  public static fromValuesArray(values: AccessListEIP2930ValuesArray, opts: TxOptions = {}) {\n    if (values.length !== 8 && values.length !== 11) {\n      throw new Error(\n        'Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).'\n      )\n    }\n\n    const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values\n\n    this._validateNotArray({ chainId, v })\n    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s })\n\n    const emptyAccessList: AccessList = []\n\n    return new AccessListEIP2930Transaction(\n      {\n        chainId: bufferToBigInt(chainId),\n        nonce,\n        gasPrice,\n        gasLimit,\n        to,\n        value,\n        data,\n        accessList: accessList ?? emptyAccessList,\n        v: v !== undefined ? bufferToBigInt(v) : undefined, // EIP2930 supports v's with value 0 (empty Buffer)\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: AccessListEIP2930TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TRANSACTION_TYPE }, opts)\n    const { chainId, accessList, gasPrice } = txData\n\n    this.common = this._getCommon(opts.common, chainId)\n    this.chainId = this.common.chainId()\n\n    // EIP-2718 check is done in Common\n    if (!this.common.isActivatedEIP(2930)) {\n      throw new Error('EIP-2930 not enabled on Common')\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930])\n\n    // Populate the access list fields\n    const accessListData = AccessLists.getAccessListData(accessList ?? [])\n    this.accessList = accessListData.accessList\n    this.AccessListJSON = accessListData.AccessListJSON\n    // Verify the access list format.\n    AccessLists.verifyAccessList(this.accessList)\n\n    this.gasPrice = bufferToBigInt(toBuffer(gasPrice === '' ? '0x' : gasPrice))\n\n    this._validateCannotExceedMaxInteger({\n      gasPrice: this.gasPrice,\n    })\n\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * gasPrice cannot exceed MAX_INTEGER')\n      throw new Error(msg)\n    }\n\n    this._validateYParity()\n    this._validateHighS()\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {\n      return this.cache.dataFee.value\n    }\n\n    let cost = super.getDataFee()\n    cost += BigInt(AccessLists.getDataFeeEIP2930(this.accessList, this.common))\n\n    if (Object.isFrozen(this)) {\n      this.cache.dataFee = {\n        value: cost,\n        hardfork: this.common.hardfork(),\n      }\n    }\n\n    return cost\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  getUpfrontCost(): bigint {\n    return this.gasLimit * this.gasPrice + this.value\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of the EIP-2930 transaction, in order.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   *\n   * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.\n   */\n  raw(): AccessListEIP2930ValuesArray {\n    return [\n      bigIntToUnpaddedBuffer(this.chainId),\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.gasPrice),\n      bigIntToUnpaddedBuffer(this.gasLimit),\n      this.to !== undefined ? this.to.buf : Buffer.from([]),\n      bigIntToUnpaddedBuffer(this.value),\n      this.data,\n      this.accessList,\n      this.v !== undefined ? bigIntToUnpaddedBuffer(this.v) : Buffer.from([]),\n      this.r !== undefined ? bigIntToUnpaddedBuffer(this.r) : Buffer.from([]),\n      this.s !== undefined ? bigIntToUnpaddedBuffer(this.s) : Buffer.from([]),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the EIP-2930 transaction.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize(): Buffer {\n    const base = this.raw()\n    return Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n  }\n\n  /**\n   * Returns the serialized unsigned tx (hashed or raw), which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input\n   * ```\n   *\n   * @param hashMessage - Return hashed message if set to true (default: true)\n   */\n  getMessageToSign(hashMessage = true): Buffer {\n    const base = this.raw().slice(0, 8)\n    const message = Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n    if (hashMessage) {\n      return Buffer.from(keccak256(message))\n    } else {\n      return message\n    }\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  public hash(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call hash method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    if (Object.isFrozen(this)) {\n      if (!this.cache.hash) {\n        this.cache.hash = Buffer.from(keccak256(this.serialize()))\n      }\n      return this.cache.hash\n    }\n\n    return Buffer.from(keccak256(this.serialize()))\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  public getMessageToVerifySignature(): Buffer {\n    return this.getMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  public getSenderPublicKey(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call this method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    const msgHash = this.getMessageToVerifySignature()\n    const { v, r, s } = this\n\n    this._validateHighS()\n\n    try {\n      return ecrecover(\n        msgHash,\n        v! + BigInt(27), // Recover the 27 which was stripped from ecsign\n        bigIntToUnpaddedBuffer(r!),\n        bigIntToUnpaddedBuffer(s!)\n      )\n    } catch (e: any) {\n      const msg = this._errorMsg('Invalid Signature')\n      throw new Error(msg)\n    }\n  }\n\n  _processSignature(v: bigint, r: Buffer, s: Buffer) {\n    const opts = { ...this.txOptions, common: this.common }\n\n    return AccessListEIP2930Transaction.fromTxData(\n      {\n        chainId: this.chainId,\n        nonce: this.nonce,\n        gasPrice: this.gasPrice,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList,\n        v: v - BigInt(27), // This looks extremely hacky: @ethereumjs/util actually adds 27 to the value, the recovery bit is either 0 or 1.\n        r: bufferToBigInt(r),\n        s: bufferToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON(): JsonTx {\n    const accessListJSON = AccessLists.getAccessListJSON(this.accessList)\n\n    return {\n      chainId: bigIntToHex(this.chainId),\n      nonce: bigIntToHex(this.nonce),\n      gasPrice: bigIntToHex(this.gasPrice),\n      gasLimit: bigIntToHex(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: bigIntToHex(this.value),\n      data: '0x' + this.data.toString('hex'),\n      accessList: accessListJSON,\n      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,\n      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,\n      s: this.s !== undefined ? bigIntToHex(this.s) : undefined,\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    // Keep ? for this.accessList since this otherwise causes Hardhat E2E tests to fail\n    errorStr += ` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length ?? 0}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return `${msg} (${this.errorStr()})`\n  }\n}\n", "import { RLP } from '@ethereumjs/rlp'\nimport {\n  MAX_INTEGER,\n  arrToBufArr,\n  bigIntToHex,\n  bigIntToUnpaddedBuffer,\n  bufArrToArr,\n  bufferToBigInt,\n  ecrecover,\n  toBuffer,\n  unpadBuffer,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak'\n\nimport { BaseTransaction } from './baseTransaction'\nimport { Capability } from './types'\n\nimport type { JsonTx, TxData, TxOptions, TxValuesArray } from './types'\nimport type { Common } from '@ethereumjs/common'\n\nconst TRANSACTION_TYPE = 0\n\nfunction meetsEIP155(_v: bigint, chainId: bigint) {\n  const v = Number(_v)\n  const chainIdDoubled = Number(chainId) * 2\n  return v === chainIdDoubled + 35 || v === chainIdDoubled + 36\n}\n\n/**\n * An Ethereum non-typed (legacy) transaction\n */\nexport class Transaction extends BaseTransaction<Transaction> {\n  public readonly gasPrice: bigint\n\n  public readonly common: Common\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { nonce, gasPrice, gasLimit, to, value, data, v, r, s }\n   *\n   * Notes:\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: TxData, opts: TxOptions = {}) {\n    return new Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`\n   */\n  public static fromSerializedTx(serialized: Buffer, opts: TxOptions = {}) {\n    const values = arrToBufArr(RLP.decode(Uint8Array.from(serialized))) as Buffer[]\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input. Must be array')\n    }\n\n    return this.fromValuesArray(values, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`\n   */\n  public static fromValuesArray(values: TxValuesArray, opts: TxOptions = {}) {\n    // If length is not 6, it has length 9. If v/r/s are empty Buffers, it is still an unsigned transaction\n    // This happens if you get the RLP data from `raw()`\n    if (values.length !== 6 && values.length !== 9) {\n      throw new Error(\n        'Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).'\n      )\n    }\n\n    const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values\n\n    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s })\n\n    return new Transaction(\n      {\n        nonce,\n        gasPrice,\n        gasLimit,\n        to,\n        value,\n        data,\n        v,\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TRANSACTION_TYPE }, opts)\n\n    this.common = this._validateTxV(this.v, opts.common)\n\n    this.gasPrice = bufferToBigInt(toBuffer(txData.gasPrice === '' ? '0x' : txData.gasPrice))\n\n    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {\n      const msg = this._errorMsg('gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)')\n      throw new Error(msg)\n    }\n    this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice })\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.common.gteHardfork('spuriousDragon')) {\n      if (!this.isSigned()) {\n        this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n      } else {\n        // EIP155 spec:\n        // If block.number >= 2,675,000 and v = CHAIN_ID * 2 + 35 or v = CHAIN_ID * 2 + 36\n        // then when computing the hash of a transaction for purposes of signing or recovering\n        // instead of hashing only the first six elements (i.e. nonce, gasprice, startgas, to, value, data)\n        // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0.\n        // v and chain ID meet EIP-155 conditions\n        if (meetsEIP155(this.v!, this.common.chainId())) {\n          this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n        }\n      }\n    }\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of the legacy transaction, in order.\n   *\n   * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`\n   *\n   * For legacy txs this is also the correct format to add transactions\n   * to a block with {@link Block.fromValuesArray} (use the `serialize()` method\n   * for typed txs).\n   *\n   * For an unsigned tx this method returns the empty Buffer values\n   * for the signature parameters `v`, `r` and `s`. For an EIP-155 compliant\n   * representation have a look at {@link Transaction.getMessageToSign}.\n   */\n  raw(): TxValuesArray {\n    return [\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.gasPrice),\n      bigIntToUnpaddedBuffer(this.gasLimit),\n      this.to !== undefined ? this.to.buf : Buffer.from([]),\n      bigIntToUnpaddedBuffer(this.value),\n      this.data,\n      this.v !== undefined ? bigIntToUnpaddedBuffer(this.v) : Buffer.from([]),\n      this.r !== undefined ? bigIntToUnpaddedBuffer(this.r) : Buffer.from([]),\n      this.s !== undefined ? bigIntToUnpaddedBuffer(this.s) : Buffer.from([]),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the legacy transaction.\n   *\n   * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link Transaction.getMessageToSign}.\n   */\n  serialize(): Buffer {\n    return Buffer.from(RLP.encode(bufArrToArr(this.raw())))\n  }\n\n  private _getMessageToSign() {\n    const values = [\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.gasPrice),\n      bigIntToUnpaddedBuffer(this.gasLimit),\n      this.to !== undefined ? this.to.buf : Buffer.from([]),\n      bigIntToUnpaddedBuffer(this.value),\n      this.data,\n    ]\n\n    if (this.supports(Capability.EIP155ReplayProtection)) {\n      values.push(bigIntToUnpaddedBuffer(this.common.chainId()))\n      values.push(unpadBuffer(toBuffer(0)))\n      values.push(unpadBuffer(toBuffer(0)))\n    }\n\n    return values\n  }\n\n  /**\n   * Returns the unsigned tx (hashed or raw), which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: the raw message message format for the legacy tx is not RLP encoded\n   * and you might need to do yourself with:\n   *\n   * ```javascript\n   * import { bufArrToArr } from '@ethereumjs/util'\n   * import { RLP } from '@ethereumjs/rlp'\n   * const message = tx.getMessageToSign(false)\n   * const serializedMessage = Buffer.from(RLP.encode(bufArrToArr(message))) // use this for the HW wallet input\n   * ```\n   *\n   * @param hashMessage - Return hashed message if set to true (default: true)\n   */\n  getMessageToSign(hashMessage: false): Buffer[]\n  getMessageToSign(hashMessage?: true): Buffer\n  getMessageToSign(hashMessage = true) {\n    const message = this._getMessageToSign()\n    if (hashMessage) {\n      return Buffer.from(keccak256(RLP.encode(bufArrToArr(message))))\n    } else {\n      return message\n    }\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {\n      return this.cache.dataFee.value\n    }\n\n    if (Object.isFrozen(this)) {\n      this.cache.dataFee = {\n        value: super.getDataFee(),\n        hardfork: this.common.hardfork(),\n      }\n    }\n\n    return super.getDataFee()\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  getUpfrontCost(): bigint {\n    return this.gasLimit * this.gasPrice + this.value\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  hash(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call hash method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    if (Object.isFrozen(this)) {\n      if (!this.cache.hash) {\n        this.cache.hash = Buffer.from(keccak256(RLP.encode(bufArrToArr(this.raw()))))\n      }\n      return this.cache.hash\n    }\n\n    return Buffer.from(keccak256(RLP.encode(bufArrToArr(this.raw()))))\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  getMessageToVerifySignature() {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('This transaction is not signed')\n      throw new Error(msg)\n    }\n    const message = this._getMessageToSign()\n    return Buffer.from(keccak256(RLP.encode(bufArrToArr(message))))\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  getSenderPublicKey(): Buffer {\n    const msgHash = this.getMessageToVerifySignature()\n\n    const { v, r, s } = this\n\n    this._validateHighS()\n\n    try {\n      return ecrecover(\n        msgHash,\n        v!,\n        bigIntToUnpaddedBuffer(r!),\n        bigIntToUnpaddedBuffer(s!),\n        this.supports(Capability.EIP155ReplayProtection) ? this.common.chainId() : undefined\n      )\n    } catch (e: any) {\n      const msg = this._errorMsg('Invalid Signature')\n      throw new Error(msg)\n    }\n  }\n\n  /**\n   * Process the v, r, s values from the `sign` method of the base transaction.\n   */\n  protected _processSignature(v: bigint, r: Buffer, s: Buffer) {\n    if (this.supports(Capability.EIP155ReplayProtection)) {\n      v += this.common.chainId() * BigInt(2) + BigInt(8)\n    }\n\n    const opts = { ...this.txOptions, common: this.common }\n\n    return Transaction.fromTxData(\n      {\n        nonce: this.nonce,\n        gasPrice: this.gasPrice,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        v,\n        r: bufferToBigInt(r),\n        s: bufferToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction.\n   */\n  toJSON(): JsonTx {\n    return {\n      nonce: bigIntToHex(this.nonce),\n      gasPrice: bigIntToHex(this.gasPrice),\n      gasLimit: bigIntToHex(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: bigIntToHex(this.value),\n      data: '0x' + this.data.toString('hex'),\n      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,\n      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,\n      s: this.s !== undefined ? bigIntToHex(this.s) : undefined,\n    }\n  }\n\n  /**\n   * Validates tx's `v` value\n   */\n  private _validateTxV(_v?: bigint, common?: Common): Common {\n    let chainIdBigInt\n    const v = _v !== undefined ? Number(_v) : undefined\n    // Check for valid v values in the scope of a signed legacy tx\n    if (v !== undefined) {\n      // v is 1. not matching the EIP-155 chainId included case and...\n      // v is 2. not matching the classic v=27 or v=28 case\n      if (v < 37 && v !== 27 && v !== 28) {\n        throw new Error(\n          `Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`\n        )\n      }\n    }\n\n    // No unsigned tx and EIP-155 activated and chain ID included\n    if (\n      v !== undefined &&\n      v !== 0 &&\n      (!common || common.gteHardfork('spuriousDragon')) &&\n      v !== 27 &&\n      v !== 28\n    ) {\n      if (common) {\n        if (!meetsEIP155(BigInt(v), common.chainId())) {\n          throw new Error(\n            `Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`\n          )\n        }\n      } else {\n        // Derive the original chain ID\n        let numSub\n        if ((v - 35) % 2 === 0) {\n          numSub = 35\n        } else {\n          numSub = 36\n        }\n        // Use derived chain ID to create a proper Common\n        chainIdBigInt = BigInt(v - numSub) / BigInt(2)\n      }\n    }\n    return this._getCommon(common, chainIdBigInt)\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    errorStr += ` gasPrice=${this.gasPrice}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return `${msg} (${this.errorStr()})`\n  }\n}\n", "import { TypeOutput, setLengthLeft, toBuffer, toType } from '@ethereumjs/util'\n\nimport type { TxData } from './types'\n\nexport const normalizeTxParams = (_txParams: any): TxData => {\n  const txParams = Object.assign({}, _txParams)\n\n  txParams.gasLimit = toType(txParams.gasLimit ?? txParams.gas, TypeOutput.BigInt)\n  txParams.data = txParams.data === undefined ? txParams.input : txParams.data\n\n  // check and convert gasPrice and value params\n  txParams.gasPrice = txParams.gasPrice !== undefined ? BigInt(txParams.gasPrice) : undefined\n  txParams.value = txParams.value !== undefined ? BigInt(txParams.value) : undefined\n\n  // strict byte length checking\n  txParams.to =\n    txParams.to !== null && txParams.to !== undefined\n      ? setLengthLeft(toBuffer(txParams.to), 20)\n      : null\n\n  // Normalize the v/r/s values. If RPC returns '0x0', ensure v/r/s are set to `undefined` in the tx.\n  // If this is not done, then the transaction creation will throw, because `v` is `0`.\n  // Note: this still means that `isSigned` will return `false`.\n  // v/r/s values are `0x0` on networks like Optimism, where the tx is a system tx.\n  // For instance: https://optimistic.etherscan.io/tx/0xf4304cb09b3f58a8e5d20fec5f393c96ccffe0269aaf632cb2be7a8a0f0c91cc\n\n  txParams.v = txParams.v === '0x0' ? '0x' : txParams.v\n  txParams.r = txParams.r === '0x0' ? '0x' : txParams.r\n  txParams.s = txParams.s === '0x0' ? '0x' : txParams.s\n\n  if (txParams.v !== '0x') {\n    txParams.v = toType(txParams.v, TypeOutput.BigInt)\n  }\n\n  return txParams\n}\n", "import { bufferToBigInt, fetchFromProvider, getProvider, toBuffer } from '@ethereumjs/util'\n\nimport { FeeMarketEIP1559Transaction } from './eip1559Transaction'\nimport { AccessListEIP2930Transaction } from './eip2930Transaction'\nimport { normalizeTxParams } from './fromRpc'\nimport { Transaction } from './legacyTransaction'\n\nimport type {\n  AccessListEIP2930TxData,\n  FeeMarketEIP1559TxData,\n  TxData,\n  TxOptions,\n  TypedTransaction,\n} from './types'\n\nexport class TransactionFactory {\n  // It is not possible to instantiate a TransactionFactory object.\n  private constructor() {}\n\n  /**\n   * Create a transaction from a `txData` object\n   *\n   * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n   * @param txOptions - Options to pass on to the constructor of the transaction\n   */\n  public static fromTxData(\n    txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData,\n    txOptions: TxOptions = {}\n  ): TypedTransaction {\n    if (!('type' in txData) || txData.type === undefined) {\n      // Assume legacy transaction\n      return Transaction.fromTxData(<TxData>txData, txOptions)\n    } else {\n      const txType = Number(bufferToBigInt(toBuffer(txData.type)))\n      if (txType === 0) {\n        return Transaction.fromTxData(<TxData>txData, txOptions)\n      } else if (txType === 1) {\n        return AccessListEIP2930Transaction.fromTxData(<AccessListEIP2930TxData>txData, txOptions)\n      } else if (txType === 2) {\n        return FeeMarketEIP1559Transaction.fromTxData(<FeeMarketEIP1559TxData>txData, txOptions)\n      } else {\n        throw new Error(`Tx instantiation with type ${txType} not supported`)\n      }\n    }\n  }\n\n  /**\n   * This method tries to decode serialized data.\n   *\n   * @param data - The data Buffer\n   * @param txOptions - The transaction options\n   */\n  public static fromSerializedData(data: Buffer, txOptions: TxOptions = {}): TypedTransaction {\n    if (data[0] <= 0x7f) {\n      // Determine the type.\n      switch (data[0]) {\n        case 1:\n          return AccessListEIP2930Transaction.fromSerializedTx(data, txOptions)\n        case 2:\n          return FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions)\n        default:\n          throw new Error(`TypedTransaction with ID ${data[0]} unknown`)\n      }\n    } else {\n      return Transaction.fromSerializedTx(data, txOptions)\n    }\n  }\n\n  /**\n   * When decoding a BlockBody, in the transactions field, a field is either:\n   * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n   * A Buffer[] (Legacy Transaction)\n   * This method returns the right transaction.\n   *\n   * @param data - A Buffer or Buffer[]\n   * @param txOptions - The transaction options\n   */\n  public static fromBlockBodyData(data: Buffer | Buffer[], txOptions: TxOptions = {}) {\n    if (Buffer.isBuffer(data)) {\n      return this.fromSerializedData(data, txOptions)\n    } else if (Array.isArray(data)) {\n      // It is a legacy transaction\n      return Transaction.fromValuesArray(data, txOptions)\n    } else {\n      throw new Error('Cannot decode transaction: unknown type input')\n    }\n  }\n\n  /**\n   *  Method to retrieve a transaction from the provider\n   * @param provider - An Ethers JsonRPCProvider\n   * @param txHash - Transaction hash\n   * @param txOptions - The transaction options\n   * @returns the transaction specified by `txHash`\n   */\n  public static async fromEthersProvider(\n    provider: string | any,\n    txHash: string,\n    txOptions?: TxOptions\n  ) {\n    const prov = getProvider(provider)\n    const txData = await fetchFromProvider(prov, {\n      method: 'eth_getTransactionByHash',\n      params: [txHash],\n    })\n    if (txData === null) {\n      throw new Error('No data returned from provider')\n    }\n    return TransactionFactory.fromRPCTx(txData, txOptions)\n  }\n\n  /**\n   * Method to decode data retrieved from RPC, such as `eth_getTransactionByHash`\n   * Note that this normalizes some of the parameters\n   * @param txData The RPC-encoded data\n   * @param txOptions The transaction options\n   * @returns\n   */\n  public static async fromRPCTx(\n    txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData,\n    txOptions: TxOptions = {}\n  ) {\n    return TransactionFactory.fromTxData(normalizeTxParams(txData), txOptions)\n  }\n}\n", "export { FeeMarketEIP1559Transaction } from './eip1559Transaction'\nexport { AccessListEIP2930Transaction } from './eip2930Transaction'\nexport { Transaction } from './legacyTransaction'\nexport { TransactionFactory } from './transactionFactory'\nexport * from './types'\n"],
  "mappings": "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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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",
  "names": ["module", "CRC32", "Chain", "Hardfork", "ConsensusType", "ConsensusAlgorithm", "CustomChain", "Capability"]
}
