import {
  Keypair,
  PublicKey,
  SYSVAR_RENT_PUBKEY,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  require_Layout,
  require_browser,
  sendAndConfirmTransaction
} from "./chunk-NTRUGUU7.js";
import {
  bignumber_default
} from "./chunk-OKCYEHW4.js";
import "./chunk-WN444VHT.js";
import "./chunk-IXJJAVWB.js";
import "./chunk-GEJW2VKU.js";
import "./chunk-XBOBPJUC.js";
import "./chunk-ZNXRVEFR.js";
import "./chunk-7Z7TKVC7.js";
import "./chunk-23C3UYPC.js";
import {
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/@solana/spl-token/lib/esm/instructions/types.mjs
var TokenInstruction;
(function(TokenInstruction2) {
  TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
  TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
  TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
  TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
  TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
  TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
  TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
  TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
  TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
  TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
  TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
  TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
  TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
  TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
  TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
  TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
  TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
  TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
  TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
  TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
  TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
})(TokenInstruction || (TokenInstruction = {}));

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMint.mjs
var import_buffer_layout4 = __toESM(require_Layout(), 1);

// node_modules/@solana/buffer-layout-utils/lib/esm/base.mjs
var encodeDecode = (layout) => {
  const decode = layout.decode.bind(layout);
  const encode = layout.encode.bind(layout);
  return { decode, encode };
};

// node_modules/@solana/buffer-layout-utils/lib/esm/bigint.mjs
var import_buffer_layout = __toESM(require_Layout(), 1);
var import_bigint_buffer = __toESM(require_browser(), 1);
var bigInt = (length) => (property) => {
  const layout = (0, import_buffer_layout.blob)(length, property);
  const { encode, decode } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset) => {
    const src = decode(buffer, offset);
    return (0, import_bigint_buffer.toBigIntLE)(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer, offset) => {
    const src = (0, import_bigint_buffer.toBufferLE)(bigInt2, length);
    return encode(src, buffer, offset);
  };
  return bigIntLayout;
};
var bigIntBE = (length) => (property) => {
  const layout = (0, import_buffer_layout.blob)(length, property);
  const { encode, decode } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset) => {
    const src = decode(buffer, offset);
    return (0, import_bigint_buffer.toBigIntBE)(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer, offset) => {
    const src = (0, import_bigint_buffer.toBufferBE)(bigInt2, length);
    return encode(src, buffer, offset);
  };
  return bigIntLayout;
};
var u64 = bigInt(8);
var u64be = bigIntBE(8);
var u128 = bigInt(16);
var u128be = bigIntBE(16);
var u192 = bigInt(24);
var u192be = bigIntBE(24);
var u256 = bigInt(32);
var u256be = bigIntBE(32);

// node_modules/@solana/buffer-layout-utils/lib/esm/decimal.mjs
var WAD = new bignumber_default("1e+18");

// node_modules/@solana/buffer-layout-utils/lib/esm/native.mjs
var import_buffer_layout2 = __toESM(require_Layout(), 1);
var bool = (property) => {
  const layout = (0, import_buffer_layout2.u8)(property);
  const { encode, decode } = encodeDecode(layout);
  const boolLayout = layout;
  boolLayout.decode = (buffer, offset) => {
    const src = decode(buffer, offset);
    return !!src;
  };
  boolLayout.encode = (bool2, buffer, offset) => {
    const src = Number(bool2);
    return encode(src, buffer, offset);
  };
  return boolLayout;
};

// node_modules/@solana/buffer-layout-utils/lib/esm/web3.mjs
var import_buffer_layout3 = __toESM(require_Layout(), 1);
var publicKey = (property) => {
  const layout = (0, import_buffer_layout3.blob)(32, property);
  const { encode, decode } = encodeDecode(layout);
  const publicKeyLayout = layout;
  publicKeyLayout.decode = (buffer, offset) => {
    const src = decode(buffer, offset);
    return new PublicKey(src);
  };
  publicKeyLayout.encode = (publicKey2, buffer, offset) => {
    const src = publicKey2.toBuffer();
    return encode(src, buffer, offset);
  };
  return publicKeyLayout;
};

// node_modules/@solana/spl-token/lib/esm/constants.mjs
var TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var NATIVE_MINT = new PublicKey("So11111111111111111111111111111111111111112");

// node_modules/@solana/spl-token/lib/esm/errors.mjs
var TokenError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var TokenAccountNotFoundError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenAccountNotFoundError";
  }
};
var TokenInvalidAccountOwnerError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountOwnerError";
  }
};
var TokenInvalidAccountSizeError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountSizeError";
  }
};
var TokenInvalidMintError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidMintError";
  }
};
var TokenInvalidOwnerError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidOwnerError";
  }
};
var TokenOwnerOffCurveError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenOwnerOffCurveError";
  }
};
var TokenInvalidInstructionProgramError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidInstructionProgramError";
  }
};
var TokenInvalidInstructionKeysError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidInstructionKeysError";
  }
};
var TokenInvalidInstructionDataError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidInstructionDataError";
  }
};
var TokenInvalidInstructionTypeError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidInstructionTypeError";
  }
};

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMint.mjs
var initializeMintInstructionData = (0, import_buffer_layout4.struct)([
  (0, import_buffer_layout4.u8)("instruction"),
  (0, import_buffer_layout4.u8)("decimals"),
  publicKey("mintAuthority"),
  (0, import_buffer_layout4.u8)("freezeAuthorityOption"),
  publicKey("freezeAuthority")
]);
function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(initializeMintInstructionData.span);
  initializeMintInstructionData.encode({
    instruction: TokenInstruction.InitializeMint,
    decimals,
    mintAuthority,
    freezeAuthorityOption: freezeAuthority ? 1 : 0,
    freezeAuthority: freezeAuthority || new PublicKey(0)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeInitializeMintInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeMintInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, rent }, data } = decodeInitializeMintInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeMint)
    throw new TokenInvalidInstructionTypeError();
  if (!mint || !rent)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      rent
    },
    data
  };
}
function decodeInitializeMintInstructionUnchecked({ programId, keys: [mint, rent], data }) {
  const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } = initializeMintInstructionData.decode(data);
  return {
    programId,
    keys: {
      mint,
      rent
    },
    data: {
      instruction,
      decimals,
      mintAuthority,
      freezeAuthority: freezeAuthorityOption ? freezeAuthority : null
    }
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount.mjs
var import_buffer_layout5 = __toESM(require_Layout(), 1);
var initializeAccountInstructionData = (0, import_buffer_layout5.struct)([(0, import_buffer_layout5.u8)("instruction")]);
function createInitializeAccountInstruction(account, mint, owner, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(initializeAccountInstructionData.span);
  initializeAccountInstructionData.encode({ instruction: TokenInstruction.InitializeAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeInitializeAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeAccountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, owner, rent }, data } = decodeInitializeAccountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeAccount)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !owner || !rent)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      rent
    },
    data
  };
}
function decodeInitializeAccountInstructionUnchecked({ programId, keys: [account, mint, owner, rent], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      rent
    },
    data: initializeAccountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMultisig.mjs
var import_buffer_layout6 = __toESM(require_Layout(), 1);
var initializeMultisigInstructionData = (0, import_buffer_layout6.struct)([
  (0, import_buffer_layout6.u8)("instruction"),
  (0, import_buffer_layout6.u8)("m")
]);
function createInitializeMultisigInstruction(account, signers, m, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  for (const signer of signers) {
    keys.push({ pubkey: signer, isSigner: false, isWritable: false });
  }
  const data = Buffer.alloc(initializeMultisigInstructionData.span);
  initializeMultisigInstructionData.encode({
    instruction: TokenInstruction.InitializeMultisig,
    m
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeInitializeMultisigInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeMultisigInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, rent, signers }, data } = decodeInitializeMultisigInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeMultisig)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !rent || !signers.length)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      rent,
      signers
    },
    data
  };
}
function decodeInitializeMultisigInstructionUnchecked({ programId, keys: [account, rent, ...signers], data }) {
  return {
    programId,
    keys: {
      account,
      rent,
      signers
    },
    data: initializeMultisigInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/transfer.mjs
var import_buffer_layout7 = __toESM(require_Layout(), 1);

// node_modules/@solana/spl-token/lib/esm/instructions/internal.mjs
function addSigners(keys, ownerOrAuthority, multiSigners) {
  if (multiSigners.length) {
    keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
    for (const signer of multiSigners) {
      keys.push({ pubkey: signer.publicKey, isSigner: true, isWritable: false });
    }
  } else {
    keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
  }
  return keys;
}

// node_modules/@solana/spl-token/lib/esm/instructions/transfer.mjs
var transferInstructionData = (0, import_buffer_layout7.struct)([(0, import_buffer_layout7.u8)("instruction"), u64("amount")]);
function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(transferInstructionData.span);
  transferInstructionData.encode({
    instruction: TokenInstruction.Transfer,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeTransferInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== transferInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { source, destination, owner, multiSigners }, data } = decodeTransferInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.Transfer)
    throw new TokenInvalidInstructionTypeError();
  if (!source || !destination || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      source,
      destination,
      owner,
      multiSigners
    },
    data
  };
}
function decodeTransferInstructionUnchecked({ programId, keys: [source, destination, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      source,
      destination,
      owner,
      multiSigners
    },
    data: transferInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/approve.mjs
var import_buffer_layout8 = __toESM(require_Layout(), 1);
var approveInstructionData = (0, import_buffer_layout8.struct)([(0, import_buffer_layout8.u8)("instruction"), u64("amount")]);
function createApproveInstruction(account, delegate, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: delegate, isSigner: false, isWritable: false }
  ], owner, multiSigners);
  const data = Buffer.alloc(approveInstructionData.span);
  approveInstructionData.encode({
    instruction: TokenInstruction.Approve,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeApproveInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== approveInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, delegate, owner, multiSigners }, data } = decodeApproveInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.Approve)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !delegate || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      delegate,
      owner,
      multiSigners
    },
    data
  };
}
function decodeApproveInstructionUnchecked({ programId, keys: [account, delegate, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      delegate,
      owner,
      multiSigners
    },
    data: approveInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/revoke.mjs
var import_buffer_layout9 = __toESM(require_Layout(), 1);
var revokeInstructionData = (0, import_buffer_layout9.struct)([(0, import_buffer_layout9.u8)("instruction")]);
function createRevokeInstruction(account, owner, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);
  const data = Buffer.alloc(revokeInstructionData.span);
  revokeInstructionData.encode({ instruction: TokenInstruction.Revoke }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeRevokeInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== revokeInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, owner, multiSigners }, data } = decodeRevokeInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.Revoke)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      owner,
      multiSigners
    },
    data
  };
}
function decodeRevokeInstructionUnchecked({ programId, keys: [account, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      owner,
      multiSigners
    },
    data: revokeInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/setAuthority.mjs
var import_buffer_layout10 = __toESM(require_Layout(), 1);
var AuthorityType;
(function(AuthorityType2) {
  AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
  AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
  AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
  AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
})(AuthorityType || (AuthorityType = {}));
var setAuthorityInstructionData = (0, import_buffer_layout10.struct)([
  (0, import_buffer_layout10.u8)("instruction"),
  (0, import_buffer_layout10.u8)("authorityType"),
  (0, import_buffer_layout10.u8)("newAuthorityOption"),
  publicKey("newAuthority")
]);
function createSetAuthorityInstruction(account, currentAuthority, authorityType, newAuthority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);
  const data = Buffer.alloc(setAuthorityInstructionData.span);
  setAuthorityInstructionData.encode({
    instruction: TokenInstruction.SetAuthority,
    authorityType,
    newAuthorityOption: newAuthority ? 1 : 0,
    newAuthority: newAuthority || new PublicKey(0)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeSetAuthorityInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== setAuthorityInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, currentAuthority, multiSigners }, data } = decodeSetAuthorityInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.SetAuthority)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !currentAuthority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      currentAuthority,
      multiSigners
    },
    data
  };
}
function decodeSetAuthorityInstructionUnchecked({ programId, keys: [account, currentAuthority, ...multiSigners], data }) {
  const { instruction, authorityType, newAuthorityOption, newAuthority } = setAuthorityInstructionData.decode(data);
  return {
    programId,
    keys: {
      account,
      currentAuthority,
      multiSigners
    },
    data: {
      instruction,
      authorityType,
      newAuthority: newAuthorityOption ? newAuthority : null
    }
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/mintTo.mjs
var import_buffer_layout11 = __toESM(require_Layout(), 1);
var mintToInstructionData = (0, import_buffer_layout11.struct)([(0, import_buffer_layout11.u8)("instruction"), u64("amount")]);
function createMintToInstruction(mint, destination, authority, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  const data = Buffer.alloc(mintToInstructionData.span);
  mintToInstructionData.encode({
    instruction: TokenInstruction.MintTo,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeMintToInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== mintToInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.MintTo)
    throw new TokenInvalidInstructionTypeError();
  if (!mint || !destination || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      multiSigners
    },
    data
  };
}
function decodeMintToInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      multiSigners
    },
    data: mintToInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/burn.mjs
var import_buffer_layout12 = __toESM(require_Layout(), 1);
var burnInstructionData = (0, import_buffer_layout12.struct)([(0, import_buffer_layout12.u8)("instruction"), u64("amount")]);
function createBurnInstruction(account, mint, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(burnInstructionData.span);
  burnInstructionData.encode({
    instruction: TokenInstruction.Burn,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeBurnInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== burnInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.Burn)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      multiSigners
    },
    data
  };
}
function decodeBurnInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      multiSigners
    },
    data: burnInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/closeAccount.mjs
var import_buffer_layout13 = __toESM(require_Layout(), 1);
var closeAccountInstructionData = (0, import_buffer_layout13.struct)([(0, import_buffer_layout13.u8)("instruction")]);
function createCloseAccountInstruction(account, destination, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  const data = Buffer.alloc(closeAccountInstructionData.span);
  closeAccountInstructionData.encode({ instruction: TokenInstruction.CloseAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeCloseAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== closeAccountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, destination, authority, multiSigners }, data } = decodeCloseAccountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.CloseAccount)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !destination || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      destination,
      authority,
      multiSigners
    },
    data
  };
}
function decodeCloseAccountInstructionUnchecked({ programId, keys: [account, destination, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      destination,
      authority,
      multiSigners
    },
    data: closeAccountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/freezeAccount.mjs
var import_buffer_layout14 = __toESM(require_Layout(), 1);
var freezeAccountInstructionData = (0, import_buffer_layout14.struct)([(0, import_buffer_layout14.u8)("instruction")]);
function createFreezeAccountInstruction(account, mint, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false }
  ], authority, multiSigners);
  const data = Buffer.alloc(freezeAccountInstructionData.span);
  freezeAccountInstructionData.encode({ instruction: TokenInstruction.FreezeAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeFreezeAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== freezeAccountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, authority, multiSigners }, data } = decodeFreezeAccountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.FreezeAccount)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      authority,
      multiSigners
    },
    data
  };
}
function decodeFreezeAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      authority,
      multiSigners
    },
    data: freezeAccountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/thawAccount.mjs
var import_buffer_layout15 = __toESM(require_Layout(), 1);
var thawAccountInstructionData = (0, import_buffer_layout15.struct)([(0, import_buffer_layout15.u8)("instruction")]);
function createThawAccountInstruction(account, mint, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false }
  ], authority, multiSigners);
  const data = Buffer.alloc(thawAccountInstructionData.span);
  thawAccountInstructionData.encode({ instruction: TokenInstruction.ThawAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeThawAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== thawAccountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, authority, multiSigners }, data } = decodeThawAccountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.ThawAccount)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      authority,
      multiSigners
    },
    data
  };
}
function decodeThawAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      authority,
      multiSigners
    },
    data: thawAccountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/transferChecked.mjs
var import_buffer_layout16 = __toESM(require_Layout(), 1);
var transferCheckedInstructionData = (0, import_buffer_layout16.struct)([
  (0, import_buffer_layout16.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout16.u8)("decimals")
]);
function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(transferCheckedInstructionData.span);
  transferCheckedInstructionData.encode({
    instruction: TokenInstruction.TransferChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeTransferCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== transferCheckedInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { source, mint, destination, owner, multiSigners }, data } = decodeTransferCheckedInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.TransferChecked)
    throw new TokenInvalidInstructionTypeError();
  if (!source || !mint || !destination || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      source,
      mint,
      destination,
      owner,
      multiSigners
    },
    data
  };
}
function decodeTransferCheckedInstructionUnchecked({ programId, keys: [source, mint, destination, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      source,
      mint,
      destination,
      owner,
      multiSigners
    },
    data: transferCheckedInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/approveChecked.mjs
var import_buffer_layout17 = __toESM(require_Layout(), 1);
var approveCheckedInstructionData = (0, import_buffer_layout17.struct)([
  (0, import_buffer_layout17.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout17.u8)("decimals")
]);
function createApproveCheckedInstruction(account, mint, delegate, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: delegate, isSigner: false, isWritable: false }
  ], owner, multiSigners);
  const data = Buffer.alloc(approveCheckedInstructionData.span);
  approveCheckedInstructionData.encode({
    instruction: TokenInstruction.ApproveChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeApproveCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== approveCheckedInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, delegate, owner, multiSigners }, data } = decodeApproveCheckedInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.ApproveChecked)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !delegate || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      delegate,
      owner,
      multiSigners
    },
    data
  };
}
function decodeApproveCheckedInstructionUnchecked({ programId, keys: [account, mint, delegate, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      delegate,
      owner,
      multiSigners
    },
    data: approveCheckedInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/mintToChecked.mjs
var import_buffer_layout18 = __toESM(require_Layout(), 1);
var mintToCheckedInstructionData = (0, import_buffer_layout18.struct)([
  (0, import_buffer_layout18.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout18.u8)("decimals")
]);
function createMintToCheckedInstruction(mint, destination, authority, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  const data = Buffer.alloc(mintToCheckedInstructionData.span);
  mintToCheckedInstructionData.encode({
    instruction: TokenInstruction.MintToChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeMintToCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== mintToCheckedInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToCheckedInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.MintToChecked)
    throw new TokenInvalidInstructionTypeError();
  if (!mint || !destination || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      multiSigners
    },
    data
  };
}
function decodeMintToCheckedInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      multiSigners
    },
    data: mintToCheckedInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/burnChecked.mjs
var import_buffer_layout19 = __toESM(require_Layout(), 1);
var burnCheckedInstructionData = (0, import_buffer_layout19.struct)([
  (0, import_buffer_layout19.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout19.u8)("decimals")
]);
function createBurnCheckedInstruction(account, mint, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(burnCheckedInstructionData.span);
  burnCheckedInstructionData.encode({
    instruction: TokenInstruction.BurnChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeBurnCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== burnCheckedInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnCheckedInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.BurnChecked)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      multiSigners
    },
    data
  };
}
function decodeBurnCheckedInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      multiSigners
    },
    data: burnCheckedInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/syncNative.mjs
var import_buffer_layout20 = __toESM(require_Layout(), 1);
var syncNativeInstructionData = (0, import_buffer_layout20.struct)([(0, import_buffer_layout20.u8)("instruction")]);
function createSyncNativeInstruction(account, programId = TOKEN_PROGRAM_ID) {
  const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(syncNativeInstructionData.span);
  syncNativeInstructionData.encode({ instruction: TokenInstruction.SyncNative }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeSyncNativeInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== syncNativeInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account }, data } = decodeSyncNativeInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.SyncNative)
    throw new TokenInvalidInstructionTypeError();
  if (!account)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account
    },
    data
  };
}
function decodeSyncNativeInstructionUnchecked({ programId, keys: [account], data }) {
  return {
    programId,
    keys: {
      account
    },
    data: syncNativeInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/decode.mjs
var import_buffer_layout21 = __toESM(require_Layout(), 1);
function decodeInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.data.length)
    throw new TokenInvalidInstructionDataError();
  const type = (0, import_buffer_layout21.u8)().decode(instruction.data);
  if (type === TokenInstruction.InitializeMint)
    return decodeInitializeMintInstruction(instruction, programId);
  if (type === TokenInstruction.InitializeAccount)
    return decodeInitializeAccountInstruction(instruction, programId);
  if (type === TokenInstruction.InitializeMultisig)
    return decodeInitializeMultisigInstruction(instruction, programId);
  if (type === TokenInstruction.Transfer)
    return decodeTransferInstruction(instruction, programId);
  if (type === TokenInstruction.Approve)
    return decodeApproveInstruction(instruction, programId);
  if (type === TokenInstruction.Revoke)
    return decodeRevokeInstruction(instruction, programId);
  if (type === TokenInstruction.SetAuthority)
    return decodeSetAuthorityInstruction(instruction, programId);
  if (type === TokenInstruction.MintTo)
    return decodeMintToInstruction(instruction, programId);
  if (type === TokenInstruction.Burn)
    return decodeBurnInstruction(instruction, programId);
  if (type === TokenInstruction.CloseAccount)
    return decodeCloseAccountInstruction(instruction, programId);
  if (type === TokenInstruction.FreezeAccount)
    return decodeFreezeAccountInstruction(instruction, programId);
  if (type === TokenInstruction.ThawAccount)
    return decodeThawAccountInstruction(instruction, programId);
  if (type === TokenInstruction.TransferChecked)
    return decodeTransferCheckedInstruction(instruction, programId);
  if (type === TokenInstruction.ApproveChecked)
    return decodeApproveCheckedInstruction(instruction, programId);
  if (type === TokenInstruction.MintToChecked)
    return decodeMintToCheckedInstruction(instruction, programId);
  if (type === TokenInstruction.BurnChecked)
    return decodeBurnCheckedInstruction(instruction, programId);
  if (type === TokenInstruction.InitializeAccount2)
    throw new TokenInvalidInstructionTypeError();
  if (type === TokenInstruction.SyncNative)
    return decodeSyncNativeInstruction(instruction, programId);
  if (type === TokenInstruction.InitializeAccount3)
    throw new TokenInvalidInstructionTypeError();
  if (type === TokenInstruction.InitializeMultisig2)
    throw new TokenInvalidInstructionTypeError();
  if (type === TokenInstruction.InitializeMint2)
    throw new TokenInvalidInstructionTypeError();
  throw new TokenInvalidInstructionTypeError();
}
function isInitializeMintInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.InitializeMint;
}
function isInitializeAccountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.InitializeAccount;
}
function isInitializeMultisigInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.InitializeMultisig;
}
function isTransferInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.Transfer;
}
function isApproveInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.Approve;
}
function isRevokeInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.Revoke;
}
function isSetAuthorityInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.SetAuthority;
}
function isMintToInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.MintTo;
}
function isBurnInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.Burn;
}
function isCloseAccountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.CloseAccount;
}
function isFreezeAccountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.FreezeAccount;
}
function isThawAccountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.ThawAccount;
}
function isTransferCheckedInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.TransferChecked;
}
function isApproveCheckedInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.ApproveChecked;
}
function isMintToCheckedInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.MintToChecked;
}
function isBurnCheckedInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.BurnChecked;
}
function isSyncNativeInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.SyncNative;
}

// node_modules/@solana/spl-token/lib/esm/instructions/associatedTokenAccount.mjs
function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedToken, isSigner: false, isWritable: true },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: programId, isSigner: false, isWritable: false },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  return new TransactionInstruction({
    keys,
    programId: associatedTokenProgramId,
    data: Buffer.alloc(0)
  });
}

// node_modules/@solana/spl-token/lib/esm/state/account.mjs
var import_buffer_layout22 = __toESM(require_Layout(), 1);
var AccountState;
(function(AccountState2) {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));
var AccountLayout = (0, import_buffer_layout22.struct)([
  publicKey("mint"),
  publicKey("owner"),
  u64("amount"),
  (0, import_buffer_layout22.u32)("delegateOption"),
  publicKey("delegate"),
  (0, import_buffer_layout22.u8)("state"),
  (0, import_buffer_layout22.u32)("isNativeOption"),
  u64("isNative"),
  u64("delegatedAmount"),
  (0, import_buffer_layout22.u32)("closeAuthorityOption"),
  publicKey("closeAuthority")
]);
var ACCOUNT_SIZE = AccountLayout.span;
async function getAccount(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address, commitment);
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length != ACCOUNT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const rawAccount = AccountLayout.decode(info.data);
  return {
    address,
    mint: rawAccount.mint,
    owner: rawAccount.owner,
    amount: rawAccount.amount,
    delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
    delegatedAmount: rawAccount.delegatedAmount,
    isInitialized: rawAccount.state !== AccountState.Uninitialized,
    isFrozen: rawAccount.state === AccountState.Frozen,
    isNative: !!rawAccount.isNativeOption,
    rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
    closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null
  };
}
async function getMinimumBalanceForRentExemptAccount(connection, commitment) {
  return await connection.getMinimumBalanceForRentExemption(ACCOUNT_SIZE, commitment);
}

// node_modules/@solana/spl-token/lib/esm/state/mint.mjs
var import_buffer_layout23 = __toESM(require_Layout(), 1);
var MintLayout = (0, import_buffer_layout23.struct)([
  (0, import_buffer_layout23.u32)("mintAuthorityOption"),
  publicKey("mintAuthority"),
  u64("supply"),
  (0, import_buffer_layout23.u8)("decimals"),
  bool("isInitialized"),
  (0, import_buffer_layout23.u32)("freezeAuthorityOption"),
  publicKey("freezeAuthority")
]);
var MINT_SIZE = MintLayout.span;
async function getMint(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address, commitment);
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length != MINT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const rawMint = MintLayout.decode(info.data);
  return {
    address,
    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
    supply: rawMint.supply,
    decimals: rawMint.decimals,
    isInitialized: rawMint.isInitialized,
    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null
  };
}
async function getMinimumBalanceForRentExemptMint(connection, commitment) {
  return await connection.getMinimumBalanceForRentExemption(MINT_SIZE, commitment);
}
async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))
    throw new TokenOwnerOffCurveError();
  const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
  return address;
}

// node_modules/@solana/spl-token/lib/esm/state/multisig.mjs
var import_buffer_layout24 = __toESM(require_Layout(), 1);
var MultisigLayout = (0, import_buffer_layout24.struct)([
  (0, import_buffer_layout24.u8)("m"),
  (0, import_buffer_layout24.u8)("n"),
  bool("isInitialized"),
  publicKey("signer1"),
  publicKey("signer2"),
  publicKey("signer3"),
  publicKey("signer4"),
  publicKey("signer5"),
  publicKey("signer6"),
  publicKey("signer7"),
  publicKey("signer8"),
  publicKey("signer9"),
  publicKey("signer10"),
  publicKey("signer11")
]);
var MULTISIG_SIZE = MultisigLayout.span;
async function getMultisig(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address, commitment);
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length != MULTISIG_SIZE)
    throw new TokenInvalidAccountSizeError();
  return { address, ...MultisigLayout.decode(info.data) };
}
async function getMinimumBalanceForRentExemptMultisig(connection, commitment) {
  return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);
}

// node_modules/@solana/spl-token/lib/esm/actions/createMint.mjs
async function createMint(connection, payer, mintAuthority, freezeAuthority, decimals, keypair = Keypair.generate(), confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const lamports = await getMinimumBalanceForRentExemptMint(connection);
  const transaction = new Transaction().add(SystemProgram.createAccount({
    fromPubkey: payer.publicKey,
    newAccountPubkey: keypair.publicKey,
    space: MINT_SIZE,
    lamports,
    programId
  }), createInitializeMintInstruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);
  return keypair.publicKey;
}

// node_modules/@solana/spl-token/lib/esm/actions/createAssociatedTokenAccount.mjs
async function createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const associatedToken = await getAssociatedTokenAddress(mint, owner, false, programId, associatedTokenProgramId);
  const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
  await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
  return associatedToken;
}

// node_modules/@solana/spl-token/lib/esm/actions/createAccount.mjs
async function createAccount(connection, payer, mint, owner, keypair, confirmOptions, programId = TOKEN_PROGRAM_ID) {
  if (!keypair)
    return await createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId);
  const lamports = await getMinimumBalanceForRentExemptAccount(connection);
  const transaction = new Transaction().add(SystemProgram.createAccount({
    fromPubkey: payer.publicKey,
    newAccountPubkey: keypair.publicKey,
    space: ACCOUNT_SIZE,
    lamports,
    programId
  }), createInitializeAccountInstruction(keypair.publicKey, mint, owner, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);
  return keypair.publicKey;
}

// node_modules/@solana/spl-token/lib/esm/actions/createWrappedNativeAccount.mjs
async function createWrappedNativeAccount(connection, payer, owner, amount, keypair, confirmOptions, programId = TOKEN_PROGRAM_ID) {
  if (!amount)
    return await createAccount(connection, payer, NATIVE_MINT, owner, keypair, confirmOptions, programId);
  if (!keypair) {
    const associatedToken = await getAssociatedTokenAddress(NATIVE_MINT, owner, false, programId, ASSOCIATED_TOKEN_PROGRAM_ID);
    const transaction2 = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, NATIVE_MINT, programId, ASSOCIATED_TOKEN_PROGRAM_ID), SystemProgram.transfer({
      fromPubkey: payer.publicKey,
      toPubkey: associatedToken,
      lamports: amount
    }), createSyncNativeInstruction(associatedToken, programId));
    await sendAndConfirmTransaction(connection, transaction2, [payer], confirmOptions);
    return associatedToken;
  }
  const lamports = await getMinimumBalanceForRentExemptAccount(connection);
  const transaction = new Transaction().add(SystemProgram.createAccount({
    fromPubkey: payer.publicKey,
    newAccountPubkey: keypair.publicKey,
    space: ACCOUNT_SIZE,
    lamports,
    programId
  }), SystemProgram.transfer({
    fromPubkey: payer.publicKey,
    toPubkey: keypair.publicKey,
    lamports: amount
  }), createInitializeAccountInstruction(keypair.publicKey, NATIVE_MINT, owner, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);
  return keypair.publicKey;
}

// node_modules/@solana/spl-token/lib/esm/actions/createMultisig.mjs
async function createMultisig(connection, payer, signers, m, keypair = Keypair.generate(), confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const lamports = await getMinimumBalanceForRentExemptMultisig(connection);
  const transaction = new Transaction().add(SystemProgram.createAccount({
    fromPubkey: payer.publicKey,
    newAccountPubkey: keypair.publicKey,
    space: MULTISIG_SIZE,
    lamports,
    programId
  }), createInitializeMultisigInstruction(keypair.publicKey, signers, m, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);
  return keypair.publicKey;
}

// node_modules/@solana/spl-token/lib/esm/actions/internal.mjs
function getSigners(signerOrMultisig, multiSigners) {
  return signerOrMultisig instanceof PublicKey ? [signerOrMultisig, multiSigners] : [signerOrMultisig.publicKey, [signerOrMultisig]];
}

// node_modules/@solana/spl-token/lib/esm/actions/transfer.mjs
async function transfer(connection, payer, source, destination, owner, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createTransferInstruction(source, destination, ownerPublicKey, amount, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/approve.mjs
async function approve(connection, payer, account, delegate, owner, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createApproveInstruction(account, delegate, ownerPublicKey, amount, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/revoke.mjs
async function revoke(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createRevokeInstruction(account, ownerPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/setAuthority.mjs
async function setAuthority(connection, payer, account, currentAuthority, authorityType, newAuthority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [currentAuthorityPublicKey, signers] = getSigners(currentAuthority, multiSigners);
  const transaction = new Transaction().add(createSetAuthorityInstruction(account, currentAuthorityPublicKey, authorityType, newAuthority, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/mintTo.mjs
async function mintTo(connection, payer, mint, destination, authority, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createMintToInstruction(mint, destination, authorityPublicKey, amount, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/burn.mjs
async function burn(connection, payer, account, mint, owner, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createBurnInstruction(account, mint, ownerPublicKey, amount, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/closeAccount.mjs
async function closeAccount(connection, payer, account, destination, authority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createCloseAccountInstruction(account, destination, authorityPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/freezeAccount.mjs
async function freezeAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createFreezeAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/thawAccount.mjs
async function thawAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createThawAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/transferChecked.mjs
async function transferChecked(connection, payer, source, mint, destination, owner, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createTransferCheckedInstruction(source, mint, destination, ownerPublicKey, amount, decimals, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/approveChecked.mjs
async function approveChecked(connection, payer, mint, account, delegate, owner, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createApproveCheckedInstruction(account, mint, delegate, ownerPublicKey, amount, decimals, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/mintToChecked.mjs
async function mintToChecked(connection, payer, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createMintToCheckedInstruction(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/burnChecked.mjs
async function burnChecked(connection, payer, account, mint, owner, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createBurnCheckedInstruction(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/syncNative.mjs
async function syncNative(connection, payer, account, confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const transaction = new Transaction().add(createSyncNativeInstruction(account, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/getOrCreateAssociatedTokenAccount.mjs
async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const associatedToken = await getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
  let account;
  try {
    account = await getAccount(connection, associatedToken, commitment, programId);
  } catch (error) {
    if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {
      try {
        const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
      } catch (error2) {
      }
      account = await getAccount(connection, associatedToken, commitment, programId);
    } else {
      throw error;
    }
  }
  if (!account.mint.equals(mint))
    throw new TokenInvalidMintError();
  if (!account.owner.equals(owner))
    throw new TokenInvalidOwnerError();
  return account;
}
export {
  ACCOUNT_SIZE,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  AccountLayout,
  AccountState,
  AuthorityType,
  MINT_SIZE,
  MULTISIG_SIZE,
  MintLayout,
  MultisigLayout,
  NATIVE_MINT,
  TOKEN_PROGRAM_ID,
  TokenAccountNotFoundError,
  TokenError,
  TokenInstruction,
  TokenInvalidAccountOwnerError,
  TokenInvalidAccountSizeError,
  TokenInvalidInstructionDataError,
  TokenInvalidInstructionKeysError,
  TokenInvalidInstructionProgramError,
  TokenInvalidInstructionTypeError,
  TokenInvalidMintError,
  TokenInvalidOwnerError,
  TokenOwnerOffCurveError,
  approve,
  approveChecked,
  approveCheckedInstructionData,
  approveInstructionData,
  burn,
  burnChecked,
  burnCheckedInstructionData,
  burnInstructionData,
  closeAccount,
  closeAccountInstructionData,
  createAccount,
  createApproveCheckedInstruction,
  createApproveInstruction,
  createAssociatedTokenAccount,
  createAssociatedTokenAccountInstruction,
  createBurnCheckedInstruction,
  createBurnInstruction,
  createCloseAccountInstruction,
  createFreezeAccountInstruction,
  createInitializeAccountInstruction,
  createInitializeMintInstruction,
  createInitializeMultisigInstruction,
  createMint,
  createMintToCheckedInstruction,
  createMintToInstruction,
  createMultisig,
  createRevokeInstruction,
  createSetAuthorityInstruction,
  createSyncNativeInstruction,
  createThawAccountInstruction,
  createTransferCheckedInstruction,
  createTransferInstruction,
  createWrappedNativeAccount,
  decodeApproveCheckedInstruction,
  decodeApproveCheckedInstructionUnchecked,
  decodeApproveInstruction,
  decodeApproveInstructionUnchecked,
  decodeBurnCheckedInstruction,
  decodeBurnCheckedInstructionUnchecked,
  decodeBurnInstruction,
  decodeBurnInstructionUnchecked,
  decodeCloseAccountInstruction,
  decodeCloseAccountInstructionUnchecked,
  decodeFreezeAccountInstruction,
  decodeFreezeAccountInstructionUnchecked,
  decodeInitializeAccountInstruction,
  decodeInitializeAccountInstructionUnchecked,
  decodeInitializeMintInstruction,
  decodeInitializeMintInstructionUnchecked,
  decodeInitializeMultisigInstruction,
  decodeInitializeMultisigInstructionUnchecked,
  decodeInstruction,
  decodeMintToCheckedInstruction,
  decodeMintToCheckedInstructionUnchecked,
  decodeMintToInstruction,
  decodeMintToInstructionUnchecked,
  decodeRevokeInstruction,
  decodeRevokeInstructionUnchecked,
  decodeSetAuthorityInstruction,
  decodeSetAuthorityInstructionUnchecked,
  decodeSyncNativeInstruction,
  decodeSyncNativeInstructionUnchecked,
  decodeThawAccountInstruction,
  decodeThawAccountInstructionUnchecked,
  decodeTransferCheckedInstruction,
  decodeTransferCheckedInstructionUnchecked,
  decodeTransferInstruction,
  decodeTransferInstructionUnchecked,
  freezeAccount,
  freezeAccountInstructionData,
  getAccount,
  getAssociatedTokenAddress,
  getMinimumBalanceForRentExemptAccount,
  getMinimumBalanceForRentExemptMint,
  getMinimumBalanceForRentExemptMultisig,
  getMint,
  getMultisig,
  getOrCreateAssociatedTokenAccount,
  initializeAccountInstructionData,
  initializeMintInstructionData,
  initializeMultisigInstructionData,
  isApproveCheckedInstruction,
  isApproveInstruction,
  isBurnCheckedInstruction,
  isBurnInstruction,
  isCloseAccountInstruction,
  isFreezeAccountInstruction,
  isInitializeAccountInstruction,
  isInitializeMintInstruction,
  isInitializeMultisigInstruction,
  isMintToCheckedInstruction,
  isMintToInstruction,
  isRevokeInstruction,
  isSetAuthorityInstruction,
  isSyncNativeInstruction,
  isThawAccountInstruction,
  isTransferCheckedInstruction,
  isTransferInstruction,
  mintTo,
  mintToChecked,
  mintToCheckedInstructionData,
  mintToInstructionData,
  revoke,
  revokeInstructionData,
  setAuthority,
  setAuthorityInstructionData,
  syncNative,
  syncNativeInstructionData,
  thawAccount,
  thawAccountInstructionData,
  transfer,
  transferChecked,
  transferCheckedInstructionData,
  transferInstructionData
};
//# sourceMappingURL=esm-VGTMTMXN.js.map
