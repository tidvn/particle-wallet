{
  "version": 3,
  "sources": ["../../@solana/spl-token/src/instructions/types.ts", "../../@solana/spl-token/src/instructions/initializeMint.ts", "../../@solana/buffer-layout-utils/src/base.ts", "../../@solana/buffer-layout-utils/src/bigint.ts", "../../@solana/buffer-layout-utils/src/decimal.ts", "../../@solana/buffer-layout-utils/src/native.ts", "../../@solana/buffer-layout-utils/src/web3.ts", "../../@solana/spl-token/src/constants.ts", "../../@solana/spl-token/src/errors.ts", "../../@solana/spl-token/src/instructions/initializeAccount.ts", "../../@solana/spl-token/src/instructions/initializeMultisig.ts", "../../@solana/spl-token/src/instructions/transfer.ts", "../../@solana/spl-token/src/instructions/internal.ts", "../../@solana/spl-token/src/instructions/approve.ts", "../../@solana/spl-token/src/instructions/revoke.ts", "../../@solana/spl-token/src/instructions/setAuthority.ts", "../../@solana/spl-token/src/instructions/mintTo.ts", "../../@solana/spl-token/src/instructions/burn.ts", "../../@solana/spl-token/src/instructions/closeAccount.ts", "../../@solana/spl-token/src/instructions/freezeAccount.ts", "../../@solana/spl-token/src/instructions/thawAccount.ts", "../../@solana/spl-token/src/instructions/transferChecked.ts", "../../@solana/spl-token/src/instructions/approveChecked.ts", "../../@solana/spl-token/src/instructions/mintToChecked.ts", "../../@solana/spl-token/src/instructions/burnChecked.ts", "../../@solana/spl-token/src/instructions/syncNative.ts", "../../@solana/spl-token/src/instructions/decode.ts", "../../@solana/spl-token/src/instructions/associatedTokenAccount.ts", "../../@solana/spl-token/src/state/account.ts", "../../@solana/spl-token/src/state/mint.ts", "../../@solana/spl-token/src/state/multisig.ts", "../../@solana/spl-token/src/actions/createMint.ts", "../../@solana/spl-token/src/actions/createAssociatedTokenAccount.ts", "../../@solana/spl-token/src/actions/createAccount.ts", "../../@solana/spl-token/src/actions/createWrappedNativeAccount.ts", "../../@solana/spl-token/src/actions/createMultisig.ts", "../../@solana/spl-token/src/actions/internal.ts", "../../@solana/spl-token/src/actions/transfer.ts", "../../@solana/spl-token/src/actions/approve.ts", "../../@solana/spl-token/src/actions/revoke.ts", "../../@solana/spl-token/src/actions/setAuthority.ts", "../../@solana/spl-token/src/actions/mintTo.ts", "../../@solana/spl-token/src/actions/burn.ts", "../../@solana/spl-token/src/actions/closeAccount.ts", "../../@solana/spl-token/src/actions/freezeAccount.ts", "../../@solana/spl-token/src/actions/thawAccount.ts", "../../@solana/spl-token/src/actions/transferChecked.ts", "../../@solana/spl-token/src/actions/approveChecked.ts", "../../@solana/spl-token/src/actions/mintToChecked.ts", "../../@solana/spl-token/src/actions/burnChecked.ts", "../../@solana/spl-token/src/actions/syncNative.ts", "../../@solana/spl-token/src/actions/getOrCreateAssociatedTokenAccount.ts"],
  "sourcesContent": ["/** Instructions defined by the program */\nexport enum TokenInstruction {\n    InitializeMint = 0,\n    InitializeAccount = 1,\n    InitializeMultisig = 2,\n    Transfer = 3,\n    Approve = 4,\n    Revoke = 5,\n    SetAuthority = 6,\n    MintTo = 7,\n    Burn = 8,\n    CloseAccount = 9,\n    FreezeAccount = 10,\n    ThawAccount = 11,\n    TransferChecked = 12,\n    ApproveChecked = 13,\n    MintToChecked = 14,\n    BurnChecked = 15,\n    InitializeAccount2 = 16,\n    SyncNative = 17,\n    InitializeAccount3 = 18,\n    InitializeMultisig2 = 19,\n    InitializeMint2 = 20,\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface InitializeMintInstructionData {\n    instruction: TokenInstruction.InitializeMint;\n    decimals: number;\n    mintAuthority: PublicKey;\n    freezeAuthorityOption: 1 | 0;\n    freezeAuthority: PublicKey;\n}\n\n/** TODO: docs */\nexport const initializeMintInstructionData = struct<InitializeMintInstructionData>([\n    u8('instruction'),\n    u8('decimals'),\n    publicKey('mintAuthority'),\n    u8('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n\n/**\n * Construct an InitializeMint instruction\n *\n * @param mint            Token mint account\n * @param decimals        Number of decimals in token account amounts\n * @param mintAuthority   Minting authority\n * @param freezeAuthority Optional authority that can freeze token accounts\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMintInstruction(\n    mint: PublicKey,\n    decimals: number,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n\n    const data = Buffer.alloc(initializeMintInstructionData.span);\n    initializeMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMint,\n            decimals,\n            mintAuthority,\n            freezeAuthorityOption: freezeAuthority ? 1 : 0,\n            freezeAuthority: freezeAuthority || new PublicKey(0),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeMint instruction */\nexport interface DecodedInitializeMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        rent: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMint;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMintInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedInitializeMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMintInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, rent },\n        data,\n    } = decodeInitializeMintInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMint) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !rent) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            rent,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMint instruction */\nexport interface DecodedInitializeMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMintInstructionUnchecked({\n    programId,\n    keys: [mint, rent],\n    data,\n}: TransactionInstruction): DecodedInitializeMintInstructionUnchecked {\n    const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } =\n        initializeMintInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            rent,\n        },\n        data: {\n            instruction,\n            decimals,\n            mintAuthority,\n            freezeAuthority: freezeAuthorityOption ? freezeAuthority : null,\n        },\n    };\n}\n", "import { Layout } from '@solana/buffer-layout';\n\nexport interface EncodeDecode<T> {\n    decode(buffer: Buffer, offset?: number): T;\n    encode(src: T, buffer: Buffer, offset?: number): number;\n}\n\nexport const encodeDecode = <T>(layout: Layout<T>): EncodeDecode<T> => {\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return { decode, encode };\n};\n", "import { blob, Layout } from '@solana/buffer-layout';\nimport { toBigIntBE, toBigIntLE, toBufferBE, toBufferLE } from 'bigint-buffer';\nimport { encodeDecode } from './base';\n\nexport const bigInt =\n    (length: number) =>\n    (property?: string): Layout<bigint> => {\n        const layout = blob(length, property);\n        const { encode, decode } = encodeDecode(layout);\n\n        const bigIntLayout = layout as Layout<unknown> as Layout<bigint>;\n\n        bigIntLayout.decode = (buffer: Buffer, offset: number) => {\n            const src = decode(buffer, offset);\n            return toBigIntLE(Buffer.from(src));\n        };\n\n        bigIntLayout.encode = (bigInt: bigint, buffer: Buffer, offset: number) => {\n            const src = toBufferLE(bigInt, length);\n            return encode(src, buffer, offset);\n        };\n\n        return bigIntLayout;\n    };\n\nexport const bigIntBE =\n    (length: number) =>\n    (property?: string): Layout<bigint> => {\n        const layout = blob(length, property);\n        const { encode, decode } = encodeDecode(layout);\n\n        const bigIntLayout = layout as Layout<unknown> as Layout<bigint>;\n\n        bigIntLayout.decode = (buffer: Buffer, offset: number) => {\n            const src = decode(buffer, offset);\n            return toBigIntBE(Buffer.from(src));\n        };\n\n        bigIntLayout.encode = (bigInt: bigint, buffer: Buffer, offset: number) => {\n            const src = toBufferBE(bigInt, length);\n            return encode(src, buffer, offset);\n        };\n\n        return bigIntLayout;\n    };\n\nexport const u64 = bigInt(8);\n\nexport const u64be = bigIntBE(8);\n\nexport const u128 = bigInt(16);\n\nexport const u128be = bigIntBE(16);\n\nexport const u192 = bigInt(24);\n\nexport const u192be = bigIntBE(24);\n\nexport const u256 = bigInt(32);\n\nexport const u256be = bigIntBE(32);\n", "import { Layout } from '@solana/buffer-layout';\nimport BigNumber from 'bignumber.js';\nimport { encodeDecode } from './base';\nimport { u128 } from './bigint';\n\nexport const WAD = new BigNumber('1e+18');\n\nexport const decimal = (property?: string): Layout<BigNumber> => {\n    const layout = u128(property);\n    const { encode, decode } = encodeDecode(layout);\n\n    const decimalLayout = layout as Layout<unknown> as Layout<BigNumber>;\n\n    decimalLayout.decode = (buffer: Buffer, offset: number) => {\n        const src = decode(buffer, offset).toString();\n        return new BigNumber(src).div(WAD);\n    };\n\n    decimalLayout.encode = (decimal: BigNumber, buffer: Buffer, offset: number) => {\n        const src = BigInt(decimal.times(WAD).integerValue().toString());\n        return encode(src, buffer, offset);\n    };\n\n    return decimalLayout;\n};\n", "import { Layout, u8 } from '@solana/buffer-layout';\nimport { encodeDecode } from './base';\n\nexport const bool = (property?: string): Layout<boolean> => {\n    const layout = u8(property);\n    const { encode, decode } = encodeDecode(layout);\n\n    const boolLayout = layout as Layout<unknown> as Layout<boolean>;\n\n    boolLayout.decode = (buffer: Buffer, offset: number) => {\n        const src = decode(buffer, offset);\n        return !!src;\n    };\n\n    boolLayout.encode = (bool: boolean, buffer: Buffer, offset: number) => {\n        const src = Number(bool);\n        return encode(src, buffer, offset);\n    };\n\n    return boolLayout;\n};\n", "import { blob, Layout } from '@solana/buffer-layout';\nimport { PublicKey } from '@solana/web3.js';\nimport { encodeDecode } from './base';\n\nexport const publicKey = (property?: string): Layout<PublicKey> => {\n    const layout = blob(32, property);\n    const { encode, decode } = encodeDecode(layout);\n\n    const publicKeyLayout = layout as Layout<unknown> as Layout<PublicKey>;\n\n    publicKeyLayout.decode = (buffer: Buffer, offset: number) => {\n        const src = decode(buffer, offset);\n        return new PublicKey(src);\n    };\n\n    publicKeyLayout.encode = (publicKey: PublicKey, buffer: Buffer, offset: number) => {\n        const src = publicKey.toBuffer();\n        return encode(src, buffer, offset);\n    };\n\n    return publicKeyLayout;\n};\n", "import { PublicKey } from '@solana/web3.js';\n\n/** Address of the SPL Token program */\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\n/** Address of the SPL Associated Token Account program */\nexport const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\n/** Address of the special mint for wrapped native SOL */\nexport const NATIVE_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n", "/** Base class for errors */\nexport abstract class TokenError extends Error {\n    constructor(message?: string) {\n        super(message);\n    }\n}\n\n/** Thrown if an account is not found at the expected address */\nexport class TokenAccountNotFoundError extends TokenError {\n    name = 'TokenAccountNotFoundError';\n}\n\n/** Thrown if a program state account is not owned by the expected token program */\nexport class TokenInvalidAccountOwnerError extends TokenError {\n    name = 'TokenInvalidAccountOwnerError';\n}\n\n/** Thrown if the byte length of an program state account doesn't match the expected size */\nexport class TokenInvalidAccountSizeError extends TokenError {\n    name = 'TokenInvalidAccountSizeError';\n}\n\n/** Thrown if the mint of a token account doesn't match the expected mint */\nexport class TokenInvalidMintError extends TokenError {\n    name = 'TokenInvalidMintError';\n}\n\n/** Thrown if the owner of a token account doesn't match the expected owner */\nexport class TokenInvalidOwnerError extends TokenError {\n    name = 'TokenInvalidOwnerError';\n}\n\n/** Thrown if the owner of a token account is a PDA (Program Derived Address) */\nexport class TokenOwnerOffCurveError extends TokenError {\n    name = 'TokenOwnerOffCurveError';\n}\n\n/** Thrown if an instruction's program is invalid */\nexport class TokenInvalidInstructionProgramError extends TokenError {\n    name = 'TokenInvalidInstructionProgramError';\n}\n\n/** Thrown if an instruction's keys are invalid */\nexport class TokenInvalidInstructionKeysError extends TokenError {\n    name = 'TokenInvalidInstructionKeysError';\n}\n\n/** Thrown if an instruction's data is invalid */\nexport class TokenInvalidInstructionDataError extends TokenError {\n    name = 'TokenInvalidInstructionDataError';\n}\n\n/** Thrown if an instruction's type is invalid */\nexport class TokenInvalidInstructionTypeError extends TokenError {\n    name = 'TokenInvalidInstructionTypeError';\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { AccountMeta, PublicKey, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface InitializeAccountInstructionData {\n    instruction: TokenInstruction.InitializeAccount;\n}\n\n/** TODO: docs */\nexport const initializeAccountInstructionData = struct<InitializeAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct an InitializeAccount instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     Owner of the new account\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccountInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: owner, isSigner: false, isWritable: false },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n\n    const data = Buffer.alloc(initializeAccountInstructionData.span);\n    initializeAccountInstructionData.encode({ instruction: TokenInstruction.InitializeAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeAccount instruction */\nexport interface DecodedInitializeAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        rent: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeAccount;\n    };\n}\n\n/**\n * Decode an InitializeAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedInitializeAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, rent },\n        data,\n    } = decodeInitializeAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner || !rent) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            rent,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeAccount instruction */\nexport interface DecodedInitializeAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode an InitializeAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccountInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, rent],\n    data,\n}: TransactionInstruction): DecodedInitializeAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            rent,\n        },\n        data: initializeAccountInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { AccountMeta, PublicKey, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface InitializeMultisigInstructionData {\n    instruction: TokenInstruction.InitializeMultisig;\n    m: number;\n}\n\n/** TODO: docs */\nexport const initializeMultisigInstructionData = struct<InitializeMultisigInstructionData>([\n    u8('instruction'),\n    u8('m'),\n]);\n\n/**\n * Construct an InitializeMultisig instruction\n *\n * @param account   Multisig account\n * @param signers   Full set of signers\n * @param m         Number of required signatures\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMultisigInstruction(\n    account: PublicKey,\n    signers: PublicKey[],\n    m: number,\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    for (const signer of signers) {\n        keys.push({ pubkey: signer, isSigner: false, isWritable: false });\n    }\n\n    const data = Buffer.alloc(initializeMultisigInstructionData.span);\n    initializeMultisigInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMultisig,\n            m,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeMultisig instruction */\nexport interface DecodedInitializeMultisigInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        rent: AccountMeta;\n        signers: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMultisig;\n        m: number;\n    };\n}\n\n/**\n * Decode an InitializeMultisig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMultisigInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedInitializeMultisigInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMultisigInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, rent, signers },\n        data,\n    } = decodeInitializeMultisigInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMultisig) throw new TokenInvalidInstructionTypeError();\n    if (!account || !rent || !signers.length) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMultisig instruction */\nexport interface DecodedInitializeMultisigInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n        signers: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        m: number;\n    };\n}\n\n/**\n * Decode an InitializeMultisig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMultisigInstructionUnchecked({\n    programId,\n    keys: [account, rent, ...signers],\n    data,\n}: TransactionInstruction): DecodedInitializeMultisigInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data: initializeMultisigInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface TransferInstructionData {\n    instruction: TokenInstruction.Transfer;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const transferInstructionData = struct<TransferInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a Transfer instruction\n *\n * @param source       Source account\n * @param destination  Destination account\n * @param owner        Owner of the source account\n * @param amount       Number of tokens to transfer\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferInstruction(\n    source: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(transferInstructionData.span);\n    transferInstructionData.encode(\n        {\n            instruction: TokenInstruction.Transfer,\n            amount: BigInt(amount),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Transfer instruction */\nexport interface DecodedTransferInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        destination: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Transfer;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Transfer instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedTransferInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, destination, owner, multiSigners },\n        data,\n    } = decodeTransferInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Transfer) throw new TokenInvalidInstructionTypeError();\n    if (!source || !destination || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            source,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Transfer instruction */\nexport interface DecodedTransferInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Transfer instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferInstructionUnchecked({\n    programId,\n    keys: [source, destination, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedTransferInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            source,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data: transferInstructionData.decode(data),\n    };\n}\n", "import { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\n\n/** @internal */\nexport function addSigners(keys: AccountMeta[], ownerOrAuthority: PublicKey, multiSigners: Signer[]): AccountMeta[] {\n    if (multiSigners.length) {\n        keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });\n        for (const signer of multiSigners) {\n            keys.push({ pubkey: signer.publicKey, isSigner: true, isWritable: false });\n        }\n    } else {\n        keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });\n    }\n    return keys;\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface ApproveInstructionData {\n    instruction: TokenInstruction.Approve;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const approveInstructionData = struct<ApproveInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct an Approve instruction\n *\n * @param account      Account to set the delegate for\n * @param delegate     Account authorized to transfer tokens from the account\n * @param owner        Owner of the account\n * @param amount       Maximum number of tokens the delegate may transfer\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createApproveInstruction(\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: delegate, isSigner: false, isWritable: false },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(approveInstructionData.span);\n    approveInstructionData.encode(\n        {\n            instruction: TokenInstruction.Approve,\n            amount: BigInt(amount),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Approve instruction */\nexport interface DecodedApproveInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        delegate: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Approve;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode an Approve instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeApproveInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedApproveInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== approveInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, delegate, owner, multiSigners },\n        data,\n    } = decodeApproveInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Approve) throw new TokenInvalidInstructionTypeError();\n    if (!account || !delegate || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Approve instruction */\nexport interface DecodedApproveInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        delegate: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode an Approve instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeApproveInstructionUnchecked({\n    programId,\n    keys: [account, delegate, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedApproveInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data: approveInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface RevokeInstructionData {\n    instruction: TokenInstruction.Revoke;\n}\n\n/** TODO: docs */\nexport const revokeInstructionData = struct<RevokeInstructionData>([u8('instruction')]);\n\n/**\n * Construct a Revoke instruction\n *\n * @param account      Address of the token account\n * @param owner        Owner of the account\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createRevokeInstruction(\n    account: PublicKey,\n    owner: PublicKey,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);\n\n    const data = Buffer.alloc(revokeInstructionData.span);\n    revokeInstructionData.encode({ instruction: TokenInstruction.Revoke }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Revoke instruction */\nexport interface DecodedRevokeInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Revoke;\n    };\n}\n\n/**\n * Decode a Revoke instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeRevokeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedRevokeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== revokeInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, owner, multiSigners },\n        data,\n    } = decodeRevokeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Revoke) throw new TokenInvalidInstructionTypeError();\n    if (!account || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Revoke instruction */\nexport interface DecodedRevokeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a Revoke instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeRevokeInstructionUnchecked({\n    programId,\n    keys: [account, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedRevokeInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            owner,\n            multiSigners,\n        },\n        data: revokeInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** Authority types defined by the program */\nexport enum AuthorityType {\n    MintTokens = 0,\n    FreezeAccount = 1,\n    AccountOwner = 2,\n    CloseAccount = 3,\n}\n\n/** TODO: docs */\nexport interface SetAuthorityInstructionData {\n    instruction: TokenInstruction.SetAuthority;\n    authorityType: AuthorityType;\n    newAuthorityOption: 1 | 0;\n    newAuthority: PublicKey;\n}\n\n/** TODO: docs */\nexport const setAuthorityInstructionData = struct<SetAuthorityInstructionData>([\n    u8('instruction'),\n    u8('authorityType'),\n    u8('newAuthorityOption'),\n    publicKey('newAuthority'),\n]);\n\n/**\n * Construct a SetAuthority instruction\n *\n * @param account          Address of the token account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param programId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSetAuthorityInstruction(\n    account: PublicKey,\n    currentAuthority: PublicKey,\n    authorityType: AuthorityType,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);\n\n    const data = Buffer.alloc(setAuthorityInstructionData.span);\n    setAuthorityInstructionData.encode(\n        {\n            instruction: TokenInstruction.SetAuthority,\n            authorityType,\n            newAuthorityOption: newAuthority ? 1 : 0,\n            newAuthority: newAuthority || new PublicKey(0),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid SetAuthority instruction */\nexport interface DecodedSetAuthorityInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        currentAuthority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.SetAuthority;\n        authorityType: AuthorityType;\n        newAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode a SetAuthority instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSetAuthorityInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedSetAuthorityInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== setAuthorityInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, currentAuthority, multiSigners },\n        data,\n    } = decodeSetAuthorityInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.SetAuthority) throw new TokenInvalidInstructionTypeError();\n    if (!account || !currentAuthority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated SetAuthority instruction */\nexport interface DecodedSetAuthorityInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        currentAuthority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        authorityType: AuthorityType;\n        newAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode a SetAuthority instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSetAuthorityInstructionUnchecked({\n    programId,\n    keys: [account, currentAuthority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedSetAuthorityInstructionUnchecked {\n    const { instruction, authorityType, newAuthorityOption, newAuthority } = setAuthorityInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data: {\n            instruction,\n            authorityType,\n            newAuthority: newAuthorityOption ? newAuthority : null,\n        },\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface MintToInstructionData {\n    instruction: TokenInstruction.MintTo;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const mintToInstructionData = struct<MintToInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a MintTo instruction\n *\n * @param mint         Public key of the mint\n * @param destination  Address of the token account to mint to\n * @param authority    The mint authority\n * @param amount       Amount to mint\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createMintToInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(mintToInstructionData.span);\n    mintToInstructionData.encode(\n        {\n            instruction: TokenInstruction.MintTo,\n            amount: BigInt(amount),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid MintTo instruction */\nexport interface DecodedMintToInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.MintTo;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a MintTo instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeMintToInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedMintToInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== mintToInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, multiSigners },\n        data,\n    } = decodeMintToInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.MintTo) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated MintTo instruction */\nexport interface DecodedMintToInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a MintTo instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeMintToInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedMintToInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: mintToInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface BurnInstructionData {\n    instruction: TokenInstruction.Burn;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const burnInstructionData = struct<BurnInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a Burn instruction\n *\n * @param account      Account to burn tokens from\n * @param mint         Mint for the account\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(burnInstructionData.span);\n    burnInstructionData.encode(\n        {\n            instruction: TokenInstruction.Burn,\n            amount: BigInt(amount),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Burn instruction */\nexport interface DecodedBurnInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Burn;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Burn instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedBurnInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, multiSigners },\n        data,\n    } = decodeBurnInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Burn) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Burn instruction */\nexport interface DecodedBurnInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Burn instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedBurnInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface CloseAccountInstructionData {\n    instruction: TokenInstruction.CloseAccount;\n}\n\n/** TODO: docs */\nexport const closeAccountInstructionData = struct<CloseAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a CloseAccount instruction\n *\n * @param account      Account to close\n * @param destination  Account to receive the remaining balance of the closed account\n * @param authority    Account close authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createCloseAccountInstruction(\n    account: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(closeAccountInstructionData.span);\n    closeAccountInstructionData.encode({ instruction: TokenInstruction.CloseAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid CloseAccount instruction */\nexport interface DecodedCloseAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.CloseAccount;\n    };\n}\n\n/**\n * Decode a CloseAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeCloseAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedCloseAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== closeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, destination, authority, multiSigners },\n        data,\n    } = decodeCloseAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.CloseAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated CloseAccount instruction */\nexport interface DecodedCloseAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a CloseAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeCloseAccountInstructionUnchecked({\n    programId,\n    keys: [account, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedCloseAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: closeAccountInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface FreezeAccountInstructionData {\n    instruction: TokenInstruction.FreezeAccount;\n}\n\n/** TODO: docs */\nexport const freezeAccountInstructionData = struct<FreezeAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a FreezeAccount instruction\n *\n * @param account      Account to freeze\n * @param mint         Mint account\n * @param authority    Mint freeze authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createFreezeAccountInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n        ],\n        authority,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(freezeAccountInstructionData.span);\n    freezeAccountInstructionData.encode({ instruction: TokenInstruction.FreezeAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid FreezeAccount instruction */\nexport interface DecodedFreezeAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.FreezeAccount;\n    };\n}\n\n/**\n * Decode a FreezeAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeFreezeAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedFreezeAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== freezeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, authority, multiSigners },\n        data,\n    } = decodeFreezeAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.FreezeAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated FreezeAccount instruction */\nexport interface DecodedFreezeAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a FreezeAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeFreezeAccountInstructionUnchecked({\n    programId,\n    keys: [account, mint, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedFreezeAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data: freezeAccountInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface ThawAccountInstructionData {\n    instruction: TokenInstruction.ThawAccount;\n}\n\n/** TODO: docs */\nexport const thawAccountInstructionData = struct<ThawAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a ThawAccount instruction\n *\n * @param account      Account to thaw\n * @param mint         Mint account\n * @param authority    Mint freeze authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createThawAccountInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n        ],\n        authority,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(thawAccountInstructionData.span);\n    thawAccountInstructionData.encode({ instruction: TokenInstruction.ThawAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid ThawAccount instruction */\nexport interface DecodedThawAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.ThawAccount;\n    };\n}\n\n/**\n * Decode a ThawAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeThawAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedThawAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== thawAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, authority, multiSigners },\n        data,\n    } = decodeThawAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.ThawAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated ThawAccount instruction */\nexport interface DecodedThawAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a ThawAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeThawAccountInstructionUnchecked({\n    programId,\n    keys: [account, mint, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedThawAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data: thawAccountInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface TransferCheckedInstructionData {\n    instruction: TokenInstruction.TransferChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const transferCheckedInstructionData = struct<TransferCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a TransferChecked instruction\n *\n * @param source       Source account\n * @param mint         Mint account\n * @param destination  Destination account\n * @param owner        Owner of the source account\n * @param amount       Number of tokens to transfer\n * @param decimals     Number of decimals in transfer amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedInstruction(\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(transferCheckedInstructionData.span);\n    transferCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid TransferChecked instruction */\nexport interface DecodedTransferCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.TransferChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a TransferChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedTransferCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, mint, destination, owner, multiSigners },\n        data,\n    } = decodeTransferCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferChecked) throw new TokenInvalidInstructionTypeError();\n    if (!source || !mint || !destination || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated TransferChecked instruction */\nexport interface DecodedTransferCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a TransferChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedInstructionUnchecked({\n    programId,\n    keys: [source, mint, destination, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedTransferCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data: transferCheckedInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface ApproveCheckedInstructionData {\n    instruction: TokenInstruction.ApproveChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const approveCheckedInstructionData = struct<ApproveCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct an ApproveChecked instruction\n *\n * @param account      Account to set the delegate for\n * @param mint         Mint account\n * @param delegate     Account authorized to transfer of tokens from the account\n * @param owner        Owner of the account\n * @param amount       Maximum number of tokens the delegate may transfer\n * @param decimals     Number of decimals in approve amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createApproveCheckedInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: delegate, isSigner: false, isWritable: false },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(approveCheckedInstructionData.span);\n    approveCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.ApproveChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid ApproveChecked instruction */\nexport interface DecodedApproveCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        delegate: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.ApproveChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode an ApproveChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeApproveCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedApproveCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== approveCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, delegate, owner, multiSigners },\n        data,\n    } = decodeApproveCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.ApproveChecked) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !delegate || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated ApproveChecked instruction */\nexport interface DecodedApproveCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        delegate: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode an ApproveChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeApproveCheckedInstructionUnchecked({\n    programId,\n    keys: [account, mint, delegate, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedApproveCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data: approveCheckedInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface MintToCheckedInstructionData {\n    instruction: TokenInstruction.MintToChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const mintToCheckedInstructionData = struct<MintToCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a MintToChecked instruction\n *\n * @param mint         Public key of the mint\n * @param destination  Address of the token account to mint to\n * @param authority    The mint authority\n * @param amount       Amount to mint\n * @param decimals     Number of decimals in amount to mint\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createMintToCheckedInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(mintToCheckedInstructionData.span);\n    mintToCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.MintToChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid MintToChecked instruction */\nexport interface DecodedMintToCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.MintToChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a MintToChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeMintToCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedMintToCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== mintToCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, multiSigners },\n        data,\n    } = decodeMintToCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.MintToChecked) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated MintToChecked instruction */\nexport interface DecodedMintToCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a MintToChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeMintToCheckedInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedMintToCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: mintToCheckedInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { AccountMeta, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { addSigners } from './internal';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface BurnCheckedInstructionData {\n    instruction: TokenInstruction.BurnChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const burnCheckedInstructionData = struct<BurnCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a BurnChecked instruction\n *\n * @param mint         Mint for the account\n * @param account      Account to burn tokens from\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param decimals     Number of decimals in burn amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnCheckedInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(burnCheckedInstructionData.span);\n    burnCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.BurnChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid BurnChecked instruction */\nexport interface DecodedBurnCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.BurnChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a BurnChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedBurnCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, multiSigners },\n        data,\n    } = decodeBurnCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.BurnChecked) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated BurnChecked instruction */\nexport interface DecodedBurnCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a BurnChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnCheckedInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedBurnCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnCheckedInstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { AccountMeta, PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport interface SyncNativeInstructionData {\n    instruction: TokenInstruction.SyncNative;\n}\n\n/** TODO: docs */\nexport const syncNativeInstructionData = struct<SyncNativeInstructionData>([u8('instruction')]);\n\n/**\n * Construct a SyncNative instruction\n *\n * @param account   Native account to sync lamports from\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSyncNativeInstruction(account: PublicKey, programId = TOKEN_PROGRAM_ID): TransactionInstruction {\n    const keys = [{ pubkey: account, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(syncNativeInstructionData.span);\n    syncNativeInstructionData.encode({ instruction: TokenInstruction.SyncNative }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid SyncNative instruction */\nexport interface DecodedSyncNativeInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.SyncNative;\n    };\n}\n\n/**\n * Decode a SyncNative instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSyncNativeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedSyncNativeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== syncNativeInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account },\n        data,\n    } = decodeSyncNativeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.SyncNative) throw new TokenInvalidInstructionTypeError();\n    if (!account) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated SyncNative instruction */\nexport interface DecodedSyncNativeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a SyncNative instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSyncNativeInstructionUnchecked({\n    programId,\n    keys: [account],\n    data,\n}: TransactionInstruction): DecodedSyncNativeInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data: syncNativeInstructionData.decode(data),\n    };\n}\n", "import { u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionTypeError } from '../errors';\nimport { decodeApproveInstruction, DecodedApproveInstruction } from './approve';\nimport { decodeApproveCheckedInstruction, DecodedApproveCheckedInstruction } from './approveChecked';\nimport { decodeBurnInstruction, DecodedBurnInstruction } from './burn';\nimport { decodeBurnCheckedInstruction, DecodedBurnCheckedInstruction } from './burnChecked';\nimport { decodeCloseAccountInstruction, DecodedCloseAccountInstruction } from './closeAccount';\nimport { DecodedFreezeAccountInstruction, decodeFreezeAccountInstruction } from './freezeAccount';\nimport { DecodedInitializeAccountInstruction, decodeInitializeAccountInstruction } from './initializeAccount';\nimport { DecodedInitializeMintInstruction, decodeInitializeMintInstruction } from './initializeMint';\nimport { DecodedInitializeMultisigInstruction, decodeInitializeMultisigInstruction } from './initializeMultisig';\nimport { DecodedMintToInstruction, decodeMintToInstruction } from './mintTo';\nimport { DecodedMintToCheckedInstruction, decodeMintToCheckedInstruction } from './mintToChecked';\nimport { DecodedRevokeInstruction, decodeRevokeInstruction } from './revoke';\nimport { DecodedSetAuthorityInstruction, decodeSetAuthorityInstruction } from './setAuthority';\nimport { DecodedSyncNativeInstruction, decodeSyncNativeInstruction } from './syncNative';\nimport { DecodedThawAccountInstruction, decodeThawAccountInstruction } from './thawAccount';\nimport { DecodedTransferInstruction, decodeTransferInstruction } from './transfer';\nimport { DecodedTransferCheckedInstruction, decodeTransferCheckedInstruction } from './transferChecked';\nimport { TokenInstruction } from './types';\n\n/** TODO: docs */\nexport type DecodedInstruction =\n    | DecodedInitializeMintInstruction\n    | DecodedInitializeAccountInstruction\n    | DecodedInitializeMultisigInstruction\n    | DecodedTransferInstruction\n    | DecodedApproveInstruction\n    | DecodedRevokeInstruction\n    | DecodedSetAuthorityInstruction\n    | DecodedMintToInstruction\n    | DecodedBurnInstruction\n    | DecodedCloseAccountInstruction\n    | DecodedFreezeAccountInstruction\n    | DecodedThawAccountInstruction\n    | DecodedTransferCheckedInstruction\n    | DecodedApproveCheckedInstruction\n    | DecodedMintToCheckedInstruction\n    | DecodedBurnCheckedInstruction\n    // | DecodedInitializeAccount2Instruction\n    | DecodedSyncNativeInstruction\n    // | DecodedInitializeAccount3Instruction\n    // | DecodedInitializeMultisig2Instruction\n    // | DecodedInitializeMint2Instruction\n    // TODO: implement ^ and remove `never`\n    | never;\n\n/** TODO: docs */\nexport function decodeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedInstruction {\n    if (!instruction.data.length) throw new TokenInvalidInstructionDataError();\n\n    const type = u8().decode(instruction.data);\n    if (type === TokenInstruction.InitializeMint) return decodeInitializeMintInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount) return decodeInitializeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeMultisig)\n        return decodeInitializeMultisigInstruction(instruction, programId);\n    if (type === TokenInstruction.Transfer) return decodeTransferInstruction(instruction, programId);\n    if (type === TokenInstruction.Approve) return decodeApproveInstruction(instruction, programId);\n    if (type === TokenInstruction.Revoke) return decodeRevokeInstruction(instruction, programId);\n    if (type === TokenInstruction.SetAuthority) return decodeSetAuthorityInstruction(instruction, programId);\n    if (type === TokenInstruction.MintTo) return decodeMintToInstruction(instruction, programId);\n    if (type === TokenInstruction.Burn) return decodeBurnInstruction(instruction, programId);\n    if (type === TokenInstruction.CloseAccount) return decodeCloseAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.FreezeAccount) return decodeFreezeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.ThawAccount) return decodeThawAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.TransferChecked) return decodeTransferCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.ApproveChecked) return decodeApproveCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.MintToChecked) return decodeMintToCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.BurnChecked) return decodeBurnCheckedInstruction(instruction, programId);\n    // TODO: implement\n    if (type === TokenInstruction.InitializeAccount2) throw new TokenInvalidInstructionTypeError();\n    if (type === TokenInstruction.SyncNative) return decodeSyncNativeInstruction(instruction, programId);\n    // TODO: implement\n    if (type === TokenInstruction.InitializeAccount3) throw new TokenInvalidInstructionTypeError();\n    // TODO: implement\n    if (type === TokenInstruction.InitializeMultisig2) throw new TokenInvalidInstructionTypeError();\n    // TODO: implement\n    if (type === TokenInstruction.InitializeMint2) throw new TokenInvalidInstructionTypeError();\n\n    throw new TokenInvalidInstructionTypeError();\n}\n\n/** TODO: docs */\nexport function isInitializeMintInstruction(decoded: DecodedInstruction): decoded is DecodedInitializeMintInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMint;\n}\n\n/** TODO: docs */\nexport function isInitializeAccountInstruction(\n    decoded: DecodedInstruction\n): decoded is DecodedInitializeAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount;\n}\n\n/** TODO: docs */\nexport function isInitializeMultisigInstruction(\n    decoded: DecodedInstruction\n): decoded is DecodedInitializeMultisigInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMultisig;\n}\n\n/** TODO: docs */\nexport function isTransferInstruction(decoded: DecodedInstruction): decoded is DecodedTransferInstruction {\n    return decoded.data.instruction === TokenInstruction.Transfer;\n}\n\n/** TODO: docs */\nexport function isApproveInstruction(decoded: DecodedInstruction): decoded is DecodedApproveInstruction {\n    return decoded.data.instruction === TokenInstruction.Approve;\n}\n\n/** TODO: docs */\nexport function isRevokeInstruction(decoded: DecodedInstruction): decoded is DecodedRevokeInstruction {\n    return decoded.data.instruction === TokenInstruction.Revoke;\n}\n\n/** TODO: docs */\nexport function isSetAuthorityInstruction(decoded: DecodedInstruction): decoded is DecodedSetAuthorityInstruction {\n    return decoded.data.instruction === TokenInstruction.SetAuthority;\n}\n\n/** TODO: docs */\nexport function isMintToInstruction(decoded: DecodedInstruction): decoded is DecodedMintToInstruction {\n    return decoded.data.instruction === TokenInstruction.MintTo;\n}\n\n/** TODO: docs */\nexport function isBurnInstruction(decoded: DecodedInstruction): decoded is DecodedBurnInstruction {\n    return decoded.data.instruction === TokenInstruction.Burn;\n}\n\n/** TODO: docs */\nexport function isCloseAccountInstruction(decoded: DecodedInstruction): decoded is DecodedCloseAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.CloseAccount;\n}\n\n/** TODO: docs */\nexport function isFreezeAccountInstruction(decoded: DecodedInstruction): decoded is DecodedFreezeAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.FreezeAccount;\n}\n\n/** TODO: docs */\nexport function isThawAccountInstruction(decoded: DecodedInstruction): decoded is DecodedThawAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.ThawAccount;\n}\n\n/** TODO: docs */\nexport function isTransferCheckedInstruction(\n    decoded: DecodedInstruction\n): decoded is DecodedTransferCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.TransferChecked;\n}\n\n/** TODO: docs */\nexport function isApproveCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedApproveCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.ApproveChecked;\n}\n\n/** TODO: docs */\nexport function isMintToCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedMintToCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.MintToChecked;\n}\n\n/** TODO: docs */\nexport function isBurnCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedBurnCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.BurnChecked;\n}\n\n/** TODO: docs, implement */\n// export function isInitializeAccount2Instruction(\n//     decoded: DecodedInstruction\n// ): decoded is DecodedInitializeAccount2Instruction {\n//     return decoded.data.instruction === TokenInstruction.InitializeAccount2;\n// }\n\n/** TODO: docs */\nexport function isSyncNativeInstruction(decoded: DecodedInstruction): decoded is DecodedSyncNativeInstruction {\n    return decoded.data.instruction === TokenInstruction.SyncNative;\n}\n\n/** TODO: docs, implement */\n// export function isInitializeAccount3Instruction(\n//     decoded: DecodedInstruction\n// ): decoded is DecodedInitializeAccount3Instruction {\n//     return decoded.data.instruction === TokenInstruction.InitializeAccount3;\n// }\n\n/** TODO: docs, implement */\n// export function isInitializeMultisig2Instruction(\n//     decoded: DecodedInstruction\n// ): decoded is DecodedInitializeMultisig2Instruction {\n//     return decoded.data.instruction === TokenInstruction.InitializeMultisig2;\n// }\n\n/** TODO: docs, implement */\n// export function isInitializeMint2Instruction(\n//     decoded: DecodedInstruction\n// ): decoded is DecodedInitializeMint2Instruction {\n//     return decoded.data.instruction === TokenInstruction.InitializeMint2;\n// }\n", "import { PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants';\n\n/**\n * Construct an AssociatedTokenAccount instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param associatedToken          New associated token account\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountInstruction(\n    payer: PublicKey,\n    associatedToken: PublicKey,\n    owner: PublicKey,\n    mint: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: associatedToken, isSigner: false, isWritable: true },\n        { pubkey: owner, isSigner: false, isWritable: false },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n        { pubkey: programId, isSigner: false, isWritable: false },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n\n    return new TransactionInstruction({\n        keys,\n        programId: associatedTokenProgramId,\n        data: Buffer.alloc(0),\n    });\n}\n", "import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors';\n\n/** Information about a token account */\nexport interface Account {\n    /** Address of the account */\n    address: PublicKey;\n    /** Mint associated with the account */\n    mint: PublicKey;\n    /** Owner of the account */\n    owner: PublicKey;\n    /** Number of tokens the account holds */\n    amount: bigint;\n    /** Authority that can transfer tokens from the account */\n    delegate: PublicKey | null;\n    /** Number of tokens the delegate is authorized to transfer */\n    delegatedAmount: bigint;\n    /** True if the account is initialized */\n    isInitialized: boolean;\n    /** True if the account is frozen */\n    isFrozen: boolean;\n    /** True if the account is a native token account */\n    isNative: boolean;\n    /**\n     * If the account is a native token account, it must be rent-exempt. The rent-exempt reserve is the amount that must\n     * remain in the balance until the account is closed.\n     */\n    rentExemptReserve: bigint | null;\n    /** Optional authority to close the account */\n    closeAuthority: PublicKey | null;\n}\n\n/** Token account state as stored by the program */\nexport enum AccountState {\n    Uninitialized = 0,\n    Initialized = 1,\n    Frozen = 2,\n}\n\n/** Token account as stored by the program */\nexport interface RawAccount {\n    mint: PublicKey;\n    owner: PublicKey;\n    amount: bigint;\n    delegateOption: 1 | 0;\n    delegate: PublicKey;\n    state: AccountState;\n    isNativeOption: 1 | 0;\n    isNative: bigint;\n    delegatedAmount: bigint;\n    closeAuthorityOption: 1 | 0;\n    closeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a token account */\nexport const AccountLayout = struct<RawAccount>([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    u32('delegateOption'),\n    publicKey('delegate'),\n    u8('state'),\n    u32('isNativeOption'),\n    u64('isNative'),\n    u64('delegatedAmount'),\n    u32('closeAuthorityOption'),\n    publicKey('closeAuthority'),\n]);\n\n/** Byte length of a token account */\nexport const ACCOUNT_SIZE = AccountLayout.span;\n\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getAccount(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const info = await connection.getAccountInfo(address, commitment);\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawAccount = AccountLayout.decode(info.data);\n\n    return {\n        address,\n        mint: rawAccount.mint,\n        owner: rawAccount.owner,\n        amount: rawAccount.amount,\n        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n        delegatedAmount: rawAccount.delegatedAmount,\n        isInitialized: rawAccount.state !== AccountState.Uninitialized,\n        isFrozen: rawAccount.state === AccountState.Frozen,\n        isNative: !!rawAccount.isNativeOption,\n        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n    };\n}\n\n/** Get the minimum lamport balance for a token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccount(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(ACCOUNT_SIZE, commitment);\n}\n", "import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidAccountSizeError,\n    TokenOwnerOffCurveError,\n} from '../errors';\n\n/** Information about a mint */\nexport interface Mint {\n    /** Address of the mint */\n    address: PublicKey;\n    /**\n     * Optional authority used to mint new tokens. The mint authority may only be provided during mint creation.\n     * If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.\n     */\n    mintAuthority: PublicKey | null;\n    /** Total supply of tokens */\n    supply: bigint;\n    /** Number of base 10 digits to the right of the decimal place */\n    decimals: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Optional authority to freeze token accounts */\n    freezeAuthority: PublicKey | null;\n}\n\n/** Mint as stored by the program */\nexport interface RawMint {\n    mintAuthorityOption: 1 | 0;\n    mintAuthority: PublicKey;\n    supply: bigint;\n    decimals: number;\n    isInitialized: boolean;\n    freezeAuthorityOption: 1 | 0;\n    freezeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct<RawMint>([\n    u32('mintAuthorityOption'),\n    publicKey('mintAuthority'),\n    u64('supply'),\n    u8('decimals'),\n    bool('isInitialized'),\n    u32('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nexport async function getMint(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Mint> {\n    const info = await connection.getAccountInfo(address, commitment);\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MINT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawMint = MintLayout.decode(info.data);\n\n    return {\n        address,\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n        supply: rawMint.supply,\n        decimals: rawMint.decimals,\n        isInitialized: rawMint.isInitialized,\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n    };\n}\n\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMint(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MINT_SIZE, commitment);\n}\n\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nexport async function getAssociatedTokenAddress(\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n\n    const [address] = await PublicKey.findProgramAddress(\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\n        associatedTokenProgramId\n    );\n\n    return address;\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors';\n\n/** Information about a multisig */\nexport interface Multisig {\n    /** Address of the multisig */\n    address: PublicKey;\n    /** Number of signers required */\n    m: number;\n    /** Number of possible signers, corresponds to the number of `signers` that are valid */\n    n: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Full set of signers, of which `n` are valid */\n    signer1: PublicKey;\n    signer2: PublicKey;\n    signer3: PublicKey;\n    signer4: PublicKey;\n    signer5: PublicKey;\n    signer6: PublicKey;\n    signer7: PublicKey;\n    signer8: PublicKey;\n    signer9: PublicKey;\n    signer10: PublicKey;\n    signer11: PublicKey;\n}\n\n/** Multisig as stored by the program */\nexport type RawMultisig = Omit<Multisig, 'address'>;\n\n/** Buffer layout for de/serializing a multisig */\nexport const MultisigLayout = struct<RawMultisig>([\n    u8('m'),\n    u8('n'),\n    bool('isInitialized'),\n    publicKey('signer1'),\n    publicKey('signer2'),\n    publicKey('signer3'),\n    publicKey('signer4'),\n    publicKey('signer5'),\n    publicKey('signer6'),\n    publicKey('signer7'),\n    publicKey('signer8'),\n    publicKey('signer9'),\n    publicKey('signer10'),\n    publicKey('signer11'),\n]);\n\n/** Byte length of a multisig */\nexport const MULTISIG_SIZE = MultisigLayout.span;\n\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\nexport async function getMultisig(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Multisig> {\n    const info = await connection.getAccountInfo(address, commitment);\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n\n    return { address, ...MultisigLayout.decode(info.data) };\n}\n\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMultisig(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    Keypair,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    SystemProgram,\n    Transaction,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createInitializeMintInstruction } from '../instructions/index';\nimport { getMinimumBalanceForRentExemptMint, MINT_SIZE } from '../state/index';\n\n/**\n * Create and initialize a new mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction and initialization fees\n * @param mintAuthority   Account or multisig that will control minting\n * @param freezeAuthority Optional account or multisig that can freeze token accounts\n * @param decimals        Location of the decimal place\n * @param keypair         Optional keypair, defaulting to a new random one\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Address of the new mint\n */\nexport async function createMint(\n    connection: Connection,\n    payer: Signer,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    decimals: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    const lamports = await getMinimumBalanceForRentExemptMint(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: MINT_SIZE,\n            lamports,\n            programId,\n        }),\n        createInitializeMintInstruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId)\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n", "import { ConfirmOptions, Connection, PublicKey, sendAndConfirmTransaction, Signer, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/index';\nimport { getAssociatedTokenAddress } from '../state/index';\n\n/**\n * Create and initialize a new associated token account\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint for the account\n * @param owner                    Owner of the new account\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function createAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    const associatedToken = await getAssociatedTokenAddress(mint, owner, false, programId, associatedTokenProgramId);\n\n    const transaction = new Transaction().add(\n        createAssociatedTokenAccountInstruction(\n            payer.publicKey,\n            associatedToken,\n            owner,\n            mint,\n            programId,\n            associatedTokenProgramId\n        )\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n    return associatedToken;\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    Keypair,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    SystemProgram,\n    Transaction,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createInitializeAccountInstruction } from '../instructions/index';\nimport { ACCOUNT_SIZE, getMinimumBalanceForRentExemptAccount } from '../state/index';\nimport { createAssociatedTokenAccount } from './createAssociatedTokenAccount';\n\n/**\n * Create and initialize a new token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param mint           Mint for the account\n * @param owner          Owner of the new account\n * @param keypair        Optional keypair, defaulting to the associated token account for the `mint` and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new token account\n */\nexport async function createAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    keypair?: Keypair,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    // If a keypair isn't provided, create the associated token account and return its address\n    if (!keypair) return await createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId);\n\n    // Otherwise, create the account with the provided keypair and return its public key\n    const lamports = await getMinimumBalanceForRentExemptAccount(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: ACCOUNT_SIZE,\n            lamports,\n            programId,\n        }),\n        createInitializeAccountInstruction(keypair.publicKey, mint, owner, programId)\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    Keypair,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    SystemProgram,\n    Transaction,\n} from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT, TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    createAssociatedTokenAccountInstruction,\n    createInitializeAccountInstruction,\n    createSyncNativeInstruction,\n} from '../instructions/index';\nimport { ACCOUNT_SIZE, getAssociatedTokenAddress, getMinimumBalanceForRentExemptAccount } from '../state/index';\nimport { createAccount } from './createAccount';\n\n/**\n * Create, initialize, and fund a new wrapped native SOL account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param owner          Owner of the new token account\n * @param amount         Number of lamports to wrap\n * @param keypair        Optional keypair, defaulting to the associated token account for the native mint and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new wrapped native SOL account\n */\nexport async function createWrappedNativeAccount(\n    connection: Connection,\n    payer: Signer,\n    owner: PublicKey,\n    amount: number,\n    keypair?: Keypair,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    // If the amount provided is explicitly 0 or NaN, just create the account without funding it\n    if (!amount) return await createAccount(connection, payer, NATIVE_MINT, owner, keypair, confirmOptions, programId);\n\n    // If a keypair isn't provided, create the account at the owner's ATA for the native mint and return its address\n    if (!keypair) {\n        const associatedToken = await getAssociatedTokenAddress(\n            NATIVE_MINT,\n            owner,\n            false,\n            programId,\n            ASSOCIATED_TOKEN_PROGRAM_ID\n        );\n\n        const transaction = new Transaction().add(\n            createAssociatedTokenAccountInstruction(\n                payer.publicKey,\n                associatedToken,\n                owner,\n                NATIVE_MINT,\n                programId,\n                ASSOCIATED_TOKEN_PROGRAM_ID\n            ),\n            SystemProgram.transfer({\n                fromPubkey: payer.publicKey,\n                toPubkey: associatedToken,\n                lamports: amount,\n            }),\n            createSyncNativeInstruction(associatedToken, programId)\n        );\n\n        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n        return associatedToken;\n    }\n\n    // Otherwise, create the account with the provided keypair and return its public key\n    const lamports = await getMinimumBalanceForRentExemptAccount(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: ACCOUNT_SIZE,\n            lamports,\n            programId,\n        }),\n        SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: keypair.publicKey,\n            lamports: amount,\n        }),\n        createInitializeAccountInstruction(keypair.publicKey, NATIVE_MINT, owner, programId)\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    Keypair,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    SystemProgram,\n    Transaction,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createInitializeMultisigInstruction } from '../instructions/index';\nimport { getMinimumBalanceForRentExemptMultisig, MULTISIG_SIZE } from '../state/index';\n\n/**\n * Create and initialize a new multisig\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param signers        Full set of signers\n * @param m              Number of required signatures\n * @param keypair        Optional keypair, defaulting to a new random one\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new multisig\n */\nexport async function createMultisig(\n    connection: Connection,\n    payer: Signer,\n    signers: PublicKey[],\n    m: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    const lamports = await getMinimumBalanceForRentExemptMultisig(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: MULTISIG_SIZE,\n            lamports,\n            programId,\n        }),\n        createInitializeMultisigInstruction(keypair.publicKey, signers, m, programId)\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n", "import { PublicKey, Signer } from '@solana/web3.js';\n\n/** @internal */\nexport function getSigners(signerOrMultisig: Signer | PublicKey, multiSigners: Signer[]): [PublicKey, Signer[]] {\n    return signerOrMultisig instanceof PublicKey\n        ? [signerOrMultisig, multiSigners]\n        : [signerOrMultisig.publicKey, [signerOrMultisig]];\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createTransferInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Transfer tokens from one account to another\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transfer(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferInstruction(source, destination, ownerPublicKey, amount, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createApproveInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param delegate       Account authorized to transfer tokens from the account\n * @param owner          Owner of the account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approve(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createApproveInstruction(account, delegate, ownerPublicKey, amount, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createRevokeInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Revoke approval for the transfer of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function revoke(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createRevokeInstruction(account, ownerPublicKey, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { AuthorityType, createSetAuthorityInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Assign a new authority to the account\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param account          Address of the account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function setAuthority(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    currentAuthority: Signer | PublicKey,\n    authorityType: AuthorityType,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [currentAuthorityPublicKey, signers] = getSigners(currentAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createSetAuthorityInstruction(\n            account,\n            currentAuthorityPublicKey,\n            authorityType,\n            newAuthority,\n            multiSigners,\n            programId\n        )\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createMintToInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Mint tokens to an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintTo(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createMintToInstruction(mint, destination, authorityPublicKey, amount, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createBurnInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Burn tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burn(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createBurnInstruction(account, mint, ownerPublicKey, amount, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createCloseAccountInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Close a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to close\n * @param destination    Account to receive the remaining balance of the closed account\n * @param authority      Authority which is allowed to close the account\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function closeAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createCloseAccountInstruction(account, destination, authorityPublicKey, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createFreezeAccountInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Freeze a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to freeze\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function freezeAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createFreezeAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createThawAccountInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Thaw (unfreeze) a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to thaw\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function thawAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createThawAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createTransferCheckedInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Transfer tokens from one account to another, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferChecked(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferCheckedInstruction(\n            source,\n            mint,\n            destination,\n            ownerPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId\n        )\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createApproveCheckedInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account, asserting the token mint and\n * decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the account\n * @param delegate       Account authorized to perform a transfer tokens from the source account\n * @param owner          Owner of the source account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param decimals       Number of decimals in approve amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approveChecked(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createApproveCheckedInstruction(\n            account,\n            mint,\n            delegate,\n            ownerPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId\n        )\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createMintToCheckedInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Mint tokens to an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param decimals       Number of decimals in amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintToChecked(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createMintToCheckedInstruction(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createBurnCheckedInstruction } from '../instructions/index';\nimport { getSigners } from './internal';\n\n/**\n * Burn tokens from an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param decimals       Number of decimals in amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burnChecked(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createBurnCheckedInstruction(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import {\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { createSyncNativeInstruction } from '../instructions/index';\n\n/**\n * Sync the balance of a native SPL token account to the underlying system account's lamports\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Native account to sync\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function syncNative(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createSyncNativeInstruction(account, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n", "import {\n    Commitment,\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n} from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/index';\nimport { Account, getAccount, getAssociatedTokenAddress } from '../state/index';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const associatedToken = await getAssociatedTokenAddress(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId\n                    )\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAY;CAAZ,SAAYA,mBAAgB;AACxB,EAAAA,kBAAAA,kBAAA,oBAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,uBAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,wBAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,cAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,aAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,YAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,kBAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,YAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,UAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,kBAAA,KAAA;AACA,EAAAA,kBAAAA,kBAAA,mBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,iBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,qBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,oBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,mBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,iBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,wBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,gBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,wBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,yBAAA,MAAA;AACA,EAAAA,kBAAAA,kBAAA,qBAAA,MAAA;AACJ,GAtBY,qBAAA,mBAAgB,CAAA,EAAA;;;ACD5B,IAAAC,wBAA2B;;;ACOpB,IAAM,eAAe,CAAI,WAAsC;AAClE,QAAM,SAAS,OAAO,OAAO,KAAK,MAAM;AACxC,QAAM,SAAS,OAAO,OAAO,KAAK,MAAM;AACxC,SAAO,EAAE,QAAQ,OAAM;AAC3B;;;ACXA,2BAA6B;AAC7B,2BAA+D;AAGxD,IAAM,SACT,CAAC,WACD,CAAC,aAAqC;AAClC,QAAM,aAAS,2BAAK,QAAQ,QAAQ;AACpC,QAAM,EAAE,QAAQ,OAAM,IAAK,aAAa,MAAM;AAE9C,QAAM,eAAe;AAErB,eAAa,SAAS,CAAC,QAAgB,WAAkB;AACrD,UAAM,MAAM,OAAO,QAAQ,MAAM;AACjC,eAAO,iCAAW,OAAO,KAAK,GAAG,CAAC;EACtC;AAEA,eAAa,SAAS,CAACC,SAAgB,QAAgB,WAAkB;AACrE,UAAM,UAAM,iCAAWA,SAAQ,MAAM;AACrC,WAAO,OAAO,KAAK,QAAQ,MAAM;EACrC;AAEA,SAAO;AACX;AAEG,IAAM,WACT,CAAC,WACD,CAAC,aAAqC;AAClC,QAAM,aAAS,2BAAK,QAAQ,QAAQ;AACpC,QAAM,EAAE,QAAQ,OAAM,IAAK,aAAa,MAAM;AAE9C,QAAM,eAAe;AAErB,eAAa,SAAS,CAAC,QAAgB,WAAkB;AACrD,UAAM,MAAM,OAAO,QAAQ,MAAM;AACjC,eAAO,iCAAW,OAAO,KAAK,GAAG,CAAC;EACtC;AAEA,eAAa,SAAS,CAACA,SAAgB,QAAgB,WAAkB;AACrE,UAAM,UAAM,iCAAWA,SAAQ,MAAM;AACrC,WAAO,OAAO,KAAK,QAAQ,MAAM;EACrC;AAEA,SAAO;AACX;AAEG,IAAM,MAAM,OAAO,CAAC;AAEpB,IAAM,QAAQ,SAAS,CAAC;AAExB,IAAM,OAAO,OAAO,EAAE;AAEtB,IAAM,SAAS,SAAS,EAAE;AAE1B,IAAM,OAAO,OAAO,EAAE;AAEtB,IAAM,SAAS,SAAS,EAAE;AAE1B,IAAM,OAAO,OAAO,EAAE;AAEtB,IAAM,SAAS,SAAS,EAAE;;;ACvD1B,IAAM,MAAM,IAAI,kBAAU,OAAO;;;ACLxC,IAAAC,wBAA2B;AAGpB,IAAM,OAAO,CAAC,aAAsC;AACvD,QAAM,aAAS,0BAAG,QAAQ;AAC1B,QAAM,EAAE,QAAQ,OAAM,IAAK,aAAa,MAAM;AAE9C,QAAM,aAAa;AAEnB,aAAW,SAAS,CAAC,QAAgB,WAAkB;AACnD,UAAM,MAAM,OAAO,QAAQ,MAAM;AACjC,WAAO,CAAC,CAAC;EACb;AAEA,aAAW,SAAS,CAACC,OAAe,QAAgB,WAAkB;AAClE,UAAM,MAAM,OAAOA,KAAI;AACvB,WAAO,OAAO,KAAK,QAAQ,MAAM;EACrC;AAEA,SAAO;AACX;;;ACpBA,IAAAC,wBAA6B;AAItB,IAAM,YAAY,CAAC,aAAwC;AAC9D,QAAM,aAAS,4BAAK,IAAI,QAAQ;AAChC,QAAM,EAAE,QAAQ,OAAM,IAAK,aAAa,MAAM;AAE9C,QAAM,kBAAkB;AAExB,kBAAgB,SAAS,CAAC,QAAgB,WAAkB;AACxD,UAAM,MAAM,OAAO,QAAQ,MAAM;AACjC,WAAO,IAAI,UAAU,GAAG;EAC5B;AAEA,kBAAgB,SAAS,CAACC,YAAsB,QAAgB,WAAkB;AAC9E,UAAM,MAAMA,WAAU,SAAQ;AAC9B,WAAO,OAAO,KAAK,QAAQ,MAAM;EACrC;AAEA,SAAO;AACX;;;AClBO,IAAM,mBAAmB,IAAI,UAAU,6CAA6C;AAGpF,IAAM,8BAA8B,IAAI,UAAU,8CAA8C;AAGhG,IAAM,cAAc,IAAI,UAAU,6CAA6C;;;ACRhF,IAAgB,aAAhB,cAAmC,MAAK;EAC1C,YAAY,SAAgB;AACxB,UAAM,OAAO;EACjB;;AAIE,IAAO,4BAAP,cAAyC,WAAU;EAAzD,cAAA;;AACI,SAAA,OAAO;EACX;;AAGM,IAAO,gCAAP,cAA6C,WAAU;EAA7D,cAAA;;AACI,SAAA,OAAO;EACX;;AAGM,IAAO,+BAAP,cAA4C,WAAU;EAA5D,cAAA;;AACI,SAAA,OAAO;EACX;;AAGM,IAAO,wBAAP,cAAqC,WAAU;EAArD,cAAA;;AACI,SAAA,OAAO;EACX;;AAGM,IAAO,yBAAP,cAAsC,WAAU;EAAtD,cAAA;;AACI,SAAA,OAAO;EACX;;AAGM,IAAO,0BAAP,cAAuC,WAAU;EAAvD,cAAA;;AACI,SAAA,OAAO;EACX;;AAGM,IAAO,sCAAP,cAAmD,WAAU;EAAnE,cAAA;;AACI,SAAA,OAAO;EACX;;AAGM,IAAO,mCAAP,cAAgD,WAAU;EAAhE,cAAA;;AACI,SAAA,OAAO;EACX;;AAGM,IAAO,mCAAP,cAAgD,WAAU;EAAhE,cAAA;;AACI,SAAA,OAAO;EACX;;AAGM,IAAO,mCAAP,cAAgD,WAAU;EAAhE,cAAA;;AACI,SAAA,OAAO;EACX;;;;APjCO,IAAM,oCAAgC,8BAAsC;MAC/E,0BAAG,aAAa;MAChB,0BAAG,UAAU;EACb,UAAU,eAAe;MACzB,0BAAG,uBAAuB;EAC1B,UAAU,iBAAiB;CAC9B;AAaK,SAAU,gCACZ,MACA,UACA,eACA,iBACA,YAAY,kBAAgB;AAE5B,QAAM,OAAO;IACT,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,KAAI;IACjD,EAAE,QAAQ,oBAAoB,UAAU,OAAO,YAAY,MAAK;;AAGpE,QAAM,OAAO,OAAO,MAAM,8BAA8B,IAAI;AAC5D,gCAA8B,OAC1B;IACI,aAAa,iBAAiB;IAC9B;IACA;IACA,uBAAuB,kBAAkB,IAAI;IAC7C,iBAAiB,mBAAmB,IAAI,UAAU,CAAC;KAEvD,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAyBM,SAAU,gCACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,8BAA8B;AAAM,UAAM,IAAI,iCAAgC;AAE9G,QAAM,EACF,MAAM,EAAE,MAAM,KAAI,GAClB,KAAI,IACJ,yCAAyC,WAAW;AACxD,MAAI,KAAK,gBAAgB,iBAAiB;AAAgB,UAAM,IAAI,iCAAgC;AACpG,MAAI,CAAC,QAAQ,CAAC;AAAM,UAAM,IAAI,iCAAgC;AAI9D,SAAO;IACH;IACA,MAAM;MACF;MACA;;IAEJ;;AAER;AAwBM,SAAU,yCAAyC,EACrD,WACA,MAAM,CAAC,MAAM,IAAI,GACjB,KAAI,GACiB;AACrB,QAAM,EAAE,aAAa,UAAU,eAAe,uBAAuB,gBAAe,IAChF,8BAA8B,OAAO,IAAI;AAE7C,SAAO;IACH;IACA,MAAM;MACF;MACA;;IAEJ,MAAM;MACF;MACA;MACA;MACA,iBAAiB,wBAAwB,kBAAkB;;;AAGvE;;;AQhKA,IAAAC,wBAA2B;AAiBpB,IAAM,uCAAmC,8BAAyC,KAAC,0BAAG,aAAa,CAAC,CAAC;AAYtG,SAAU,mCACZ,SACA,MACA,OACA,YAAY,kBAAgB;AAE5B,QAAM,OAAO;IACT,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI;IACpD,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,MAAK;IAClD,EAAE,QAAQ,OAAO,UAAU,OAAO,YAAY,MAAK;IACnD,EAAE,QAAQ,oBAAoB,UAAU,OAAO,YAAY,MAAK;;AAGpE,QAAM,OAAO,OAAO,MAAM,iCAAiC,IAAI;AAC/D,mCAAiC,OAAO,EAAE,aAAa,iBAAiB,kBAAiB,GAAI,IAAI;AAEjG,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAwBM,SAAU,mCACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,iCAAiC;AAAM,UAAM,IAAI,iCAAgC;AAEjH,QAAM,EACF,MAAM,EAAE,SAAS,MAAM,OAAO,KAAI,GAClC,KAAI,IACJ,4CAA4C,WAAW;AAC3D,MAAI,KAAK,gBAAgB,iBAAiB;AAAmB,UAAM,IAAI,iCAAgC;AACvG,MAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC;AAAM,UAAM,IAAI,iCAAgC;AAIpF,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAuBM,SAAU,4CAA4C,EACxD,WACA,MAAM,CAAC,SAAS,MAAM,OAAO,IAAI,GACjC,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,iCAAiC,OAAO,IAAI;;AAE1D;;;ACtIA,IAAAC,wBAA2B;AAkBpB,IAAM,wCAAoC,8BAA0C;MACvF,0BAAG,aAAa;MAChB,0BAAG,GAAG;CACT;AAYK,SAAU,oCACZ,SACA,SACA,GACA,YAAY,kBAAgB;AAE5B,QAAM,OAAO;IACT,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI;IACpD,EAAE,QAAQ,oBAAoB,UAAU,OAAO,YAAY,MAAK;;AAEpE,aAAW,UAAU,SAAS;AAC1B,SAAK,KAAK,EAAE,QAAQ,QAAQ,UAAU,OAAO,YAAY,MAAK,CAAE;;AAGpE,QAAM,OAAO,OAAO,MAAM,kCAAkC,IAAI;AAChE,oCAAkC,OAC9B;IACI,aAAa,iBAAiB;IAC9B;KAEJ,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAwBM,SAAU,oCACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,kCAAkC;AAC9D,UAAM,IAAI,iCAAgC;AAE9C,QAAM,EACF,MAAM,EAAE,SAAS,MAAM,QAAO,GAC9B,KAAI,IACJ,6CAA6C,WAAW;AAC5D,MAAI,KAAK,gBAAgB,iBAAiB;AAAoB,UAAM,IAAI,iCAAgC;AACxG,MAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,QAAQ;AAAQ,UAAM,IAAI,iCAAgC;AAIpF,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;;IAEJ;;AAER;AAuBM,SAAU,6CAA6C,EACzD,WACA,MAAM,CAAC,SAAS,SAAS,OAAO,GAChC,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;;IAEJ,MAAM,kCAAkC,OAAO,IAAI;;AAE3D;;;AChJA,IAAAC,wBAA2B;;;ACGrB,SAAU,WAAW,MAAqB,kBAA6B,cAAsB;AAC/F,MAAI,aAAa,QAAQ;AACrB,SAAK,KAAK,EAAE,QAAQ,kBAAkB,UAAU,OAAO,YAAY,MAAK,CAAE;AAC1E,eAAW,UAAU,cAAc;AAC/B,WAAK,KAAK,EAAE,QAAQ,OAAO,WAAW,UAAU,MAAM,YAAY,MAAK,CAAE;;SAE1E;AACH,SAAK,KAAK,EAAE,QAAQ,kBAAkB,UAAU,MAAM,YAAY,MAAK,CAAE;;AAE7E,SAAO;AACX;;;ADOO,IAAM,8BAA0B,8BAAgC,KAAC,0BAAG,aAAa,GAAG,IAAI,QAAQ,CAAC,CAAC;AAcnG,SAAU,0BACZ,QACA,aACA,OACA,QACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,QAAQ,UAAU,OAAO,YAAY,KAAI;IACnD,EAAE,QAAQ,aAAa,UAAU,OAAO,YAAY,KAAI;KAE5D,OACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,wBAAwB,IAAI;AACtD,0BAAwB,OACpB;IACI,aAAa,iBAAiB;IAC9B,QAAQ,OAAO,MAAM;KAEzB,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAyBM,SAAU,0BACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,wBAAwB;AAAM,UAAM,IAAI,iCAAgC;AAExG,QAAM,EACF,MAAM,EAAE,QAAQ,aAAa,OAAO,aAAY,GAChD,KAAI,IACJ,mCAAmC,WAAW;AAClD,MAAI,KAAK,gBAAgB,iBAAiB;AAAU,UAAM,IAAI,iCAAgC;AAC9F,MAAI,CAAC,UAAU,CAAC,eAAe,CAAC;AAAO,UAAM,IAAI,iCAAgC;AAIjF,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAwBM,SAAU,mCAAmC,EAC/C,WACA,MAAM,CAAC,QAAQ,aAAa,UAAU,YAAY,GAClD,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,wBAAwB,OAAO,IAAI;;AAEjD;;;AEvJA,IAAAC,wBAA2B;AAoBpB,IAAM,6BAAyB,8BAA+B,KAAC,0BAAG,aAAa,GAAG,IAAI,QAAQ,CAAC,CAAC;AAcjG,SAAU,yBACZ,SACA,UACA,OACA,QACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI;IACpD,EAAE,QAAQ,UAAU,UAAU,OAAO,YAAY,MAAK;KAE1D,OACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,uBAAuB,IAAI;AACrD,yBAAuB,OACnB;IACI,aAAa,iBAAiB;IAC9B,QAAQ,OAAO,MAAM;KAEzB,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAyBM,SAAU,yBACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,uBAAuB;AAAM,UAAM,IAAI,iCAAgC;AAEvG,QAAM,EACF,MAAM,EAAE,SAAS,UAAU,OAAO,aAAY,GAC9C,KAAI,IACJ,kCAAkC,WAAW;AACjD,MAAI,KAAK,gBAAgB,iBAAiB;AAAS,UAAM,IAAI,iCAAgC;AAC7F,MAAI,CAAC,WAAW,CAAC,YAAY,CAAC;AAAO,UAAM,IAAI,iCAAgC;AAI/E,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAwBM,SAAU,kCAAkC,EAC9C,WACA,MAAM,CAAC,SAAS,UAAU,UAAU,YAAY,GAChD,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,uBAAuB,OAAO,IAAI;;AAEhD;;;ACvJA,IAAAC,wBAA2B;AAkBpB,IAAM,4BAAwB,8BAA8B,KAAC,0BAAG,aAAa,CAAC,CAAC;AAYhF,SAAU,wBACZ,SACA,OACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WAAW,CAAC,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI,CAAE,GAAG,OAAO,YAAY;AAErG,QAAM,OAAO,OAAO,MAAM,sBAAsB,IAAI;AACpD,wBAAsB,OAAO,EAAE,aAAa,iBAAiB,OAAM,GAAI,IAAI;AAE3E,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAuBM,SAAU,wBACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,sBAAsB;AAAM,UAAM,IAAI,iCAAgC;AAEtG,QAAM,EACF,MAAM,EAAE,SAAS,OAAO,aAAY,GACpC,KAAI,IACJ,iCAAiC,WAAW;AAChD,MAAI,KAAK,gBAAgB,iBAAiB;AAAQ,UAAM,IAAI,iCAAgC;AAC5F,MAAI,CAAC,WAAW,CAAC;AAAO,UAAM,IAAI,iCAAgC;AAIlE,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;;IAEJ;;AAER;AAsBM,SAAU,iCAAiC,EAC7C,WACA,MAAM,CAAC,SAAS,UAAU,YAAY,GACtC,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;;IAEJ,MAAM,sBAAsB,OAAO,IAAI;;AAE/C;;;AC9HA,IAAAC,yBAA2B;AAc3B,IAAY;CAAZ,SAAYC,gBAAa;AACrB,EAAAA,eAAAA,eAAA,gBAAA,KAAA;AACA,EAAAA,eAAAA,eAAA,mBAAA,KAAA;AACA,EAAAA,eAAAA,eAAA,kBAAA,KAAA;AACA,EAAAA,eAAAA,eAAA,kBAAA,KAAA;AACJ,GALY,kBAAA,gBAAa,CAAA,EAAA;AAgBlB,IAAM,kCAA8B,+BAAoC;MAC3E,2BAAG,aAAa;MAChB,2BAAG,eAAe;MAClB,2BAAG,oBAAoB;EACvB,UAAU,cAAc;CAC3B;AAcK,SAAU,8BACZ,SACA,kBACA,eACA,cACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WAAW,CAAC,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI,CAAE,GAAG,kBAAkB,YAAY;AAEhH,QAAM,OAAO,OAAO,MAAM,4BAA4B,IAAI;AAC1D,8BAA4B,OACxB;IACI,aAAa,iBAAiB;IAC9B;IACA,oBAAoB,eAAe,IAAI;IACvC,cAAc,gBAAgB,IAAI,UAAU,CAAC;KAEjD,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAyBM,SAAU,8BACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,4BAA4B;AAAM,UAAM,IAAI,iCAAgC;AAE5G,QAAM,EACF,MAAM,EAAE,SAAS,kBAAkB,aAAY,GAC/C,KAAI,IACJ,uCAAuC,WAAW;AACtD,MAAI,KAAK,gBAAgB,iBAAiB;AAAc,UAAM,IAAI,iCAAgC;AAClG,MAAI,CAAC,WAAW,CAAC;AAAkB,UAAM,IAAI,iCAAgC;AAI7E,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;;IAEJ;;AAER;AAwBM,SAAU,uCAAuC,EACnD,WACA,MAAM,CAAC,SAAS,qBAAqB,YAAY,GACjD,KAAI,GACiB;AACrB,QAAM,EAAE,aAAa,eAAe,oBAAoB,aAAY,IAAK,4BAA4B,OAAO,IAAI;AAEhH,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;;IAEJ,MAAM;MACF;MACA;MACA,cAAc,qBAAqB,eAAe;;;AAG9D;;;ACrKA,IAAAC,yBAA2B;AAoBpB,IAAM,4BAAwB,+BAA8B,KAAC,2BAAG,aAAa,GAAG,IAAI,QAAQ,CAAC,CAAC;AAc/F,SAAU,wBACZ,MACA,aACA,WACA,QACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,KAAI;IACjD,EAAE,QAAQ,aAAa,UAAU,OAAO,YAAY,KAAI;KAE5D,WACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,sBAAsB,IAAI;AACpD,wBAAsB,OAClB;IACI,aAAa,iBAAiB;IAC9B,QAAQ,OAAO,MAAM;KAEzB,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAyBM,SAAU,wBACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,sBAAsB;AAAM,UAAM,IAAI,iCAAgC;AAEtG,QAAM,EACF,MAAM,EAAE,MAAM,aAAa,WAAW,aAAY,GAClD,KAAI,IACJ,iCAAiC,WAAW;AAChD,MAAI,KAAK,gBAAgB,iBAAiB;AAAQ,UAAM,IAAI,iCAAgC;AAC5F,MAAI,CAAC,QAAQ,CAAC,eAAe,CAAC;AAAW,UAAM,IAAI,iCAAgC;AAInF,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAwBM,SAAU,iCAAiC,EAC7C,WACA,MAAM,CAAC,MAAM,aAAa,cAAc,YAAY,GACpD,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,sBAAsB,OAAO,IAAI;;AAE/C;;;ACvJA,IAAAC,yBAA2B;AAoBpB,IAAM,0BAAsB,+BAA4B,KAAC,2BAAG,aAAa,GAAG,IAAI,QAAQ,CAAC,CAAC;AAc3F,SAAU,sBACZ,SACA,MACA,OACA,QACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI;IACpD,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,KAAI;KAErD,OACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,oBAAoB,IAAI;AAClD,sBAAoB,OAChB;IACI,aAAa,iBAAiB;IAC9B,QAAQ,OAAO,MAAM;KAEzB,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAyBM,SAAU,sBACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,oBAAoB;AAAM,UAAM,IAAI,iCAAgC;AAEpG,QAAM,EACF,MAAM,EAAE,SAAS,MAAM,OAAO,aAAY,GAC1C,KAAI,IACJ,+BAA+B,WAAW;AAC9C,MAAI,KAAK,gBAAgB,iBAAiB;AAAM,UAAM,IAAI,iCAAgC;AAC1F,MAAI,CAAC,WAAW,CAAC,QAAQ,CAAC;AAAO,UAAM,IAAI,iCAAgC;AAI3E,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAwBM,SAAU,+BAA+B,EAC3C,WACA,MAAM,CAAC,SAAS,MAAM,UAAU,YAAY,GAC5C,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,oBAAoB,OAAO,IAAI;;AAE7C;;;ACvJA,IAAAC,yBAA2B;AAkBpB,IAAM,kCAA8B,+BAAoC,KAAC,2BAAG,aAAa,CAAC,CAAC;AAa5F,SAAU,8BACZ,SACA,aACA,WACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI;IACpD,EAAE,QAAQ,aAAa,UAAU,OAAO,YAAY,KAAI;KAE5D,WACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,4BAA4B,IAAI;AAC1D,8BAA4B,OAAO,EAAE,aAAa,iBAAiB,aAAY,GAAI,IAAI;AAEvF,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAwBM,SAAU,8BACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,4BAA4B;AAAM,UAAM,IAAI,iCAAgC;AAE5G,QAAM,EACF,MAAM,EAAE,SAAS,aAAa,WAAW,aAAY,GACrD,KAAI,IACJ,uCAAuC,WAAW;AACtD,MAAI,KAAK,gBAAgB,iBAAiB;AAAc,UAAM,IAAI,iCAAgC;AAClG,MAAI,CAAC,WAAW,CAAC,eAAe,CAAC;AAAW,UAAM,IAAI,iCAAgC;AAItF,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAuBM,SAAU,uCAAuC,EACnD,WACA,MAAM,CAAC,SAAS,aAAa,cAAc,YAAY,GACvD,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,4BAA4B,OAAO,IAAI;;AAErD;;;AC3IA,IAAAC,yBAA2B;AAkBpB,IAAM,mCAA+B,+BAAqC,KAAC,2BAAG,aAAa,CAAC,CAAC;AAa9F,SAAU,+BACZ,SACA,MACA,WACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI;IACpD,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,MAAK;KAEtD,WACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,6BAA6B,IAAI;AAC3D,+BAA6B,OAAO,EAAE,aAAa,iBAAiB,cAAa,GAAI,IAAI;AAEzF,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAwBM,SAAU,+BACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,6BAA6B;AAAM,UAAM,IAAI,iCAAgC;AAE7G,QAAM,EACF,MAAM,EAAE,SAAS,MAAM,WAAW,aAAY,GAC9C,KAAI,IACJ,wCAAwC,WAAW;AACvD,MAAI,KAAK,gBAAgB,iBAAiB;AAAe,UAAM,IAAI,iCAAgC;AACnG,MAAI,CAAC,WAAW,CAAC,QAAQ,CAAC;AAAW,UAAM,IAAI,iCAAgC;AAI/E,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAuBM,SAAU,wCAAwC,EACpD,WACA,MAAM,CAAC,SAAS,MAAM,cAAc,YAAY,GAChD,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,6BAA6B,OAAO,IAAI;;AAEtD;;;AC3IA,IAAAC,yBAA2B;AAkBpB,IAAM,iCAA6B,+BAAmC,KAAC,2BAAG,aAAa,CAAC,CAAC;AAa1F,SAAU,6BACZ,SACA,MACA,WACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI;IACpD,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,MAAK;KAEtD,WACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,2BAA2B,IAAI;AACzD,6BAA2B,OAAO,EAAE,aAAa,iBAAiB,YAAW,GAAI,IAAI;AAErF,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAwBM,SAAU,6BACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,2BAA2B;AAAM,UAAM,IAAI,iCAAgC;AAE3G,QAAM,EACF,MAAM,EAAE,SAAS,MAAM,WAAW,aAAY,GAC9C,KAAI,IACJ,sCAAsC,WAAW;AACrD,MAAI,KAAK,gBAAgB,iBAAiB;AAAa,UAAM,IAAI,iCAAgC;AACjG,MAAI,CAAC,WAAW,CAAC,QAAQ,CAAC;AAAW,UAAM,IAAI,iCAAgC;AAI/E,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAuBM,SAAU,sCAAsC,EAClD,WACA,MAAM,CAAC,SAAS,MAAM,cAAc,YAAY,GAChD,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,2BAA2B,OAAO,IAAI;;AAEpD;;;AC3IA,IAAAC,yBAA2B;AAqBpB,IAAM,qCAAiC,+BAAuC;MACjF,2BAAG,aAAa;EAChB,IAAI,QAAQ;MACZ,2BAAG,UAAU;CAChB;AAgBK,SAAU,iCACZ,QACA,MACA,aACA,OACA,QACA,UACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,QAAQ,UAAU,OAAO,YAAY,KAAI;IACnD,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,MAAK;IAClD,EAAE,QAAQ,aAAa,UAAU,OAAO,YAAY,KAAI;KAE5D,OACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,+BAA+B,IAAI;AAC7D,iCAA+B,OAC3B;IACI,aAAa,iBAAiB;IAC9B,QAAQ,OAAO,MAAM;IACrB;KAEJ,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AA2BM,SAAU,iCACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,+BAA+B;AAAM,UAAM,IAAI,iCAAgC;AAE/G,QAAM,EACF,MAAM,EAAE,QAAQ,MAAM,aAAa,OAAO,aAAY,GACtD,KAAI,IACJ,0CAA0C,WAAW;AACzD,MAAI,KAAK,gBAAgB,iBAAiB;AAAiB,UAAM,IAAI,iCAAgC;AACrG,MAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,eAAe,CAAC;AAAO,UAAM,IAAI,iCAAgC;AAI1F,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;MACA;;IAEJ;;AAER;AA0BM,SAAU,0CAA0C,EACtD,WACA,MAAM,CAAC,QAAQ,MAAM,aAAa,UAAU,YAAY,GACxD,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;MACA;;IAEJ,MAAM,+BAA+B,OAAO,IAAI;;AAExD;;;ACxKA,IAAAC,yBAA2B;AAqBpB,IAAM,oCAAgC,+BAAsC;MAC/E,2BAAG,aAAa;EAChB,IAAI,QAAQ;MACZ,2BAAG,UAAU;CAChB;AAgBK,SAAU,gCACZ,SACA,MACA,UACA,OACA,QACA,UACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI;IACpD,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,MAAK;IAClD,EAAE,QAAQ,UAAU,UAAU,OAAO,YAAY,MAAK;KAE1D,OACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,8BAA8B,IAAI;AAC5D,gCAA8B,OAC1B;IACI,aAAa,iBAAiB;IAC9B,QAAQ,OAAO,MAAM;IACrB;KAEJ,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AA2BM,SAAU,gCACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,8BAA8B;AAAM,UAAM,IAAI,iCAAgC;AAE9G,QAAM,EACF,MAAM,EAAE,SAAS,MAAM,UAAU,OAAO,aAAY,GACpD,KAAI,IACJ,yCAAyC,WAAW;AACxD,MAAI,KAAK,gBAAgB,iBAAiB;AAAgB,UAAM,IAAI,iCAAgC;AACpG,MAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,YAAY,CAAC;AAAO,UAAM,IAAI,iCAAgC;AAIxF,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;MACA;;IAEJ;;AAER;AA0BM,SAAU,yCAAyC,EACrD,WACA,MAAM,CAAC,SAAS,MAAM,UAAU,UAAU,YAAY,GACtD,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;MACA;;IAEJ,MAAM,8BAA8B,OAAO,IAAI;;AAEvD;;;ACxKA,IAAAC,yBAA2B;AAqBpB,IAAM,mCAA+B,+BAAqC;MAC7E,2BAAG,aAAa;EAChB,IAAI,QAAQ;MACZ,2BAAG,UAAU;CAChB;AAeK,SAAU,+BACZ,MACA,aACA,WACA,QACA,UACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,KAAI;IACjD,EAAE,QAAQ,aAAa,UAAU,OAAO,YAAY,KAAI;KAE5D,WACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,6BAA6B,IAAI;AAC3D,+BAA6B,OACzB;IACI,aAAa,iBAAiB;IAC9B,QAAQ,OAAO,MAAM;IACrB;KAEJ,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AA0BM,SAAU,+BACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,6BAA6B;AAAM,UAAM,IAAI,iCAAgC;AAE7G,QAAM,EACF,MAAM,EAAE,MAAM,aAAa,WAAW,aAAY,GAClD,KAAI,IACJ,wCAAwC,WAAW;AACvD,MAAI,KAAK,gBAAgB,iBAAiB;AAAe,UAAM,IAAI,iCAAgC;AACnG,MAAI,CAAC,QAAQ,CAAC,eAAe,CAAC;AAAW,UAAM,IAAI,iCAAgC;AAInF,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAyBM,SAAU,wCAAwC,EACpD,WACA,MAAM,CAAC,MAAM,aAAa,cAAc,YAAY,GACpD,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,6BAA6B,OAAO,IAAI;;AAEtD;;;ACjKA,IAAAC,yBAA2B;AAqBpB,IAAM,iCAA6B,+BAAmC;MACzE,2BAAG,aAAa;EAChB,IAAI,QAAQ;MACZ,2BAAG,UAAU;CAChB;AAeK,SAAU,6BACZ,SACA,MACA,OACA,QACA,UACA,eAAyB,CAAA,GACzB,YAAY,kBAAgB;AAE5B,QAAM,OAAO,WACT;IACI,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI;IACpD,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,KAAI;KAErD,OACA,YAAY;AAGhB,QAAM,OAAO,OAAO,MAAM,2BAA2B,IAAI;AACzD,6BAA2B,OACvB;IACI,aAAa,iBAAiB;IAC9B,QAAQ,OAAO,MAAM;IACrB;KAEJ,IAAI;AAGR,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AA0BM,SAAU,6BACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,2BAA2B;AAAM,UAAM,IAAI,iCAAgC;AAE3G,QAAM,EACF,MAAM,EAAE,SAAS,MAAM,OAAO,aAAY,GAC1C,KAAI,IACJ,sCAAsC,WAAW;AACrD,MAAI,KAAK,gBAAgB,iBAAiB;AAAa,UAAM,IAAI,iCAAgC;AACjG,MAAI,CAAC,WAAW,CAAC,QAAQ,CAAC;AAAO,UAAM,IAAI,iCAAgC;AAI3E,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ;;AAER;AAyBM,SAAU,sCAAsC,EAClD,WACA,MAAM,CAAC,SAAS,MAAM,UAAU,YAAY,GAC5C,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;MACA;MACA;MACA;;IAEJ,MAAM,2BAA2B,OAAO,IAAI;;AAEpD;;;ACjKA,IAAAC,yBAA2B;AAiBpB,IAAM,gCAA4B,+BAAkC,KAAC,2BAAG,aAAa,CAAC,CAAC;AAUxF,SAAU,4BAA4B,SAAoB,YAAY,kBAAgB;AACxF,QAAM,OAAO,CAAC,EAAE,QAAQ,SAAS,UAAU,OAAO,YAAY,KAAI,CAAE;AAEpE,QAAM,OAAO,OAAO,MAAM,0BAA0B,IAAI;AACxD,4BAA0B,OAAO,EAAE,aAAa,iBAAiB,WAAU,GAAI,IAAI;AAEnF,SAAO,IAAI,uBAAuB,EAAE,MAAM,WAAW,KAAI,CAAE;AAC/D;AAqBM,SAAU,4BACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,UAAU,OAAO,SAAS;AAAG,UAAM,IAAI,oCAAmC;AAC3F,MAAI,YAAY,KAAK,WAAW,0BAA0B;AAAM,UAAM,IAAI,iCAAgC;AAE1G,QAAM,EACF,MAAM,EAAE,QAAO,GACf,KAAI,IACJ,qCAAqC,WAAW;AACpD,MAAI,KAAK,gBAAgB,iBAAiB;AAAY,UAAM,IAAI,iCAAgC;AAChG,MAAI,CAAC;AAAS,UAAM,IAAI,iCAAgC;AAIxD,SAAO;IACH;IACA,MAAM;MACF;;IAEJ;;AAER;AAoBM,SAAU,qCAAqC,EACjD,WACA,MAAM,CAAC,OAAO,GACd,KAAI,GACiB;AACrB,SAAO;IACH;IACA,MAAM;MACF;;IAEJ,MAAM,0BAA0B,OAAO,IAAI;;AAEnD;;;AC9GA,IAAAC,yBAAmB;AAkDb,SAAU,kBACZ,aACA,YAAY,kBAAgB;AAE5B,MAAI,CAAC,YAAY,KAAK;AAAQ,UAAM,IAAI,iCAAgC;AAExE,QAAM,WAAO,2BAAE,EAAG,OAAO,YAAY,IAAI;AACzC,MAAI,SAAS,iBAAiB;AAAgB,WAAO,gCAAgC,aAAa,SAAS;AAC3G,MAAI,SAAS,iBAAiB;AAAmB,WAAO,mCAAmC,aAAa,SAAS;AACjH,MAAI,SAAS,iBAAiB;AAC1B,WAAO,oCAAoC,aAAa,SAAS;AACrE,MAAI,SAAS,iBAAiB;AAAU,WAAO,0BAA0B,aAAa,SAAS;AAC/F,MAAI,SAAS,iBAAiB;AAAS,WAAO,yBAAyB,aAAa,SAAS;AAC7F,MAAI,SAAS,iBAAiB;AAAQ,WAAO,wBAAwB,aAAa,SAAS;AAC3F,MAAI,SAAS,iBAAiB;AAAc,WAAO,8BAA8B,aAAa,SAAS;AACvG,MAAI,SAAS,iBAAiB;AAAQ,WAAO,wBAAwB,aAAa,SAAS;AAC3F,MAAI,SAAS,iBAAiB;AAAM,WAAO,sBAAsB,aAAa,SAAS;AACvF,MAAI,SAAS,iBAAiB;AAAc,WAAO,8BAA8B,aAAa,SAAS;AACvG,MAAI,SAAS,iBAAiB;AAAe,WAAO,+BAA+B,aAAa,SAAS;AACzG,MAAI,SAAS,iBAAiB;AAAa,WAAO,6BAA6B,aAAa,SAAS;AACrG,MAAI,SAAS,iBAAiB;AAAiB,WAAO,iCAAiC,aAAa,SAAS;AAC7G,MAAI,SAAS,iBAAiB;AAAgB,WAAO,gCAAgC,aAAa,SAAS;AAC3G,MAAI,SAAS,iBAAiB;AAAe,WAAO,+BAA+B,aAAa,SAAS;AACzG,MAAI,SAAS,iBAAiB;AAAa,WAAO,6BAA6B,aAAa,SAAS;AAErG,MAAI,SAAS,iBAAiB;AAAoB,UAAM,IAAI,iCAAgC;AAC5F,MAAI,SAAS,iBAAiB;AAAY,WAAO,4BAA4B,aAAa,SAAS;AAEnG,MAAI,SAAS,iBAAiB;AAAoB,UAAM,IAAI,iCAAgC;AAE5F,MAAI,SAAS,iBAAiB;AAAqB,UAAM,IAAI,iCAAgC;AAE7F,MAAI,SAAS,iBAAiB;AAAiB,UAAM,IAAI,iCAAgC;AAEzF,QAAM,IAAI,iCAAgC;AAC9C;AAGM,SAAU,4BAA4B,SAA2B;AACnE,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,+BACZ,SAA2B;AAE3B,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,gCACZ,SAA2B;AAE3B,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,sBAAsB,SAA2B;AAC7D,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,qBAAqB,SAA2B;AAC5D,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,oBAAoB,SAA2B;AAC3D,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,0BAA0B,SAA2B;AACjE,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,oBAAoB,SAA2B;AAC3D,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,kBAAkB,SAA2B;AACzD,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,0BAA0B,SAA2B;AACjE,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,2BAA2B,SAA2B;AAClE,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,yBAAyB,SAA2B;AAChE,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,6BACZ,SAA2B;AAE3B,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,4BAA4B,SAA2B;AACnE,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,2BAA2B,SAA2B;AAClE,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAGM,SAAU,yBAAyB,SAA2B;AAChE,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;AAUM,SAAU,wBAAwB,SAA2B;AAC/D,SAAO,QAAQ,KAAK,gBAAgB,iBAAiB;AACzD;;;ACxKM,SAAU,wCACZ,OACA,iBACA,OACA,MACA,YAAY,kBACZ,2BAA2B,6BAA2B;AAEtD,QAAM,OAAO;IACT,EAAE,QAAQ,OAAO,UAAU,MAAM,YAAY,KAAI;IACjD,EAAE,QAAQ,iBAAiB,UAAU,OAAO,YAAY,KAAI;IAC5D,EAAE,QAAQ,OAAO,UAAU,OAAO,YAAY,MAAK;IACnD,EAAE,QAAQ,MAAM,UAAU,OAAO,YAAY,MAAK;IAClD,EAAE,QAAQ,cAAc,WAAW,UAAU,OAAO,YAAY,MAAK;IACrE,EAAE,QAAQ,WAAW,UAAU,OAAO,YAAY,MAAK;IACvD,EAAE,QAAQ,oBAAoB,UAAU,OAAO,YAAY,MAAK;;AAGpE,SAAO,IAAI,uBAAuB;IAC9B;IACA,WAAW;IACX,MAAM,OAAO,MAAM,CAAC;GACvB;AACL;;;ACtCA,IAAAC,yBAAgC;AAoChC,IAAY;CAAZ,SAAYC,eAAY;AACpB,EAAAA,cAAAA,cAAA,mBAAA,KAAA;AACA,EAAAA,cAAAA,cAAA,iBAAA,KAAA;AACA,EAAAA,cAAAA,cAAA,YAAA,KAAA;AACJ,GAJY,iBAAA,eAAY,CAAA,EAAA;AAsBjB,IAAM,oBAAgB,+BAAmB;EAC5C,UAAU,MAAM;EAChB,UAAU,OAAO;EACjB,IAAI,QAAQ;MACZ,4BAAI,gBAAgB;EACpB,UAAU,UAAU;MACpB,2BAAG,OAAO;MACV,4BAAI,gBAAgB;EACpB,IAAI,UAAU;EACd,IAAI,iBAAiB;MACrB,4BAAI,sBAAsB;EAC1B,UAAU,gBAAgB;CAC7B;AAGM,IAAM,eAAe,cAAc;AAY1C,eAAsB,WAClB,YACA,SACA,YACA,YAAY,kBAAgB;AAE5B,QAAM,OAAO,MAAM,WAAW,eAAe,SAAS,UAAU;AAChE,MAAI,CAAC;AAAM,UAAM,IAAI,0BAAyB;AAC9C,MAAI,CAAC,KAAK,MAAM,OAAO,SAAS;AAAG,UAAM,IAAI,8BAA6B;AAC1E,MAAI,KAAK,KAAK,UAAU;AAAc,UAAM,IAAI,6BAA4B;AAE5E,QAAM,aAAa,cAAc,OAAO,KAAK,IAAI;AAEjD,SAAO;IACH;IACA,MAAM,WAAW;IACjB,OAAO,WAAW;IAClB,QAAQ,WAAW;IACnB,UAAU,WAAW,iBAAiB,WAAW,WAAW;IAC5D,iBAAiB,WAAW;IAC5B,eAAe,WAAW,UAAU,aAAa;IACjD,UAAU,WAAW,UAAU,aAAa;IAC5C,UAAU,CAAC,CAAC,WAAW;IACvB,mBAAmB,WAAW,iBAAiB,WAAW,WAAW;IACrE,gBAAgB,WAAW,uBAAuB,WAAW,iBAAiB;;AAEtF;AASA,eAAsB,sCAClB,YACA,YAAuB;AAEvB,SAAO,MAAM,WAAW,kCAAkC,cAAc,UAAU;AACtF;;;AC7HA,IAAAC,yBAAgC;AA0CzB,IAAM,iBAAa,+BAAgB;MACtC,4BAAI,qBAAqB;EACzB,UAAU,eAAe;EACzB,IAAI,QAAQ;MACZ,2BAAG,UAAU;EACb,KAAK,eAAe;MACpB,4BAAI,uBAAuB;EAC3B,UAAU,iBAAiB;CAC9B;AAGM,IAAM,YAAY,WAAW;AAYpC,eAAsB,QAClB,YACA,SACA,YACA,YAAY,kBAAgB;AAE5B,QAAM,OAAO,MAAM,WAAW,eAAe,SAAS,UAAU;AAChE,MAAI,CAAC;AAAM,UAAM,IAAI,0BAAyB;AAC9C,MAAI,CAAC,KAAK,MAAM,OAAO,SAAS;AAAG,UAAM,IAAI,8BAA6B;AAC1E,MAAI,KAAK,KAAK,UAAU;AAAW,UAAM,IAAI,6BAA4B;AAEzE,QAAM,UAAU,WAAW,OAAO,KAAK,IAAI;AAE3C,SAAO;IACH;IACA,eAAe,QAAQ,sBAAsB,QAAQ,gBAAgB;IACrE,QAAQ,QAAQ;IAChB,UAAU,QAAQ;IAClB,eAAe,QAAQ;IACvB,iBAAiB,QAAQ,wBAAwB,QAAQ,kBAAkB;;AAEnF;AASA,eAAsB,mCAClB,YACA,YAAuB;AAEvB,SAAO,MAAM,WAAW,kCAAkC,WAAW,UAAU;AACnF;AAaA,eAAsB,0BAClB,MACA,OACA,qBAAqB,OACrB,YAAY,kBACZ,2BAA2B,6BAA2B;AAEtD,MAAI,CAAC,sBAAsB,CAAC,UAAU,UAAU,MAAM,SAAQ,CAAE;AAAG,UAAM,IAAI,wBAAuB;AAEpG,QAAM,CAAC,OAAO,IAAI,MAAM,UAAU,mBAC9B,CAAC,MAAM,SAAQ,GAAI,UAAU,SAAQ,GAAI,KAAK,SAAQ,CAAE,GACxD,wBAAwB;AAG5B,SAAO;AACX;;;AChIA,IAAAC,yBAA2B;AAkCpB,IAAM,qBAAiB,+BAAoB;MAC9C,2BAAG,GAAG;MACN,2BAAG,GAAG;EACN,KAAK,eAAe;EACpB,UAAU,SAAS;EACnB,UAAU,SAAS;EACnB,UAAU,SAAS;EACnB,UAAU,SAAS;EACnB,UAAU,SAAS;EACnB,UAAU,SAAS;EACnB,UAAU,SAAS;EACnB,UAAU,SAAS;EACnB,UAAU,SAAS;EACnB,UAAU,UAAU;EACpB,UAAU,UAAU;CACvB;AAGM,IAAM,gBAAgB,eAAe;AAY5C,eAAsB,YAClB,YACA,SACA,YACA,YAAY,kBAAgB;AAE5B,QAAM,OAAO,MAAM,WAAW,eAAe,SAAS,UAAU;AAChE,MAAI,CAAC;AAAM,UAAM,IAAI,0BAAyB;AAC9C,MAAI,CAAC,KAAK,MAAM,OAAO,SAAS;AAAG,UAAM,IAAI,8BAA6B;AAC1E,MAAI,KAAK,KAAK,UAAU;AAAe,UAAM,IAAI,6BAA4B;AAE7E,SAAO,EAAE,SAAS,GAAG,eAAe,OAAO,KAAK,IAAI,EAAC;AACzD;AASA,eAAsB,uCAClB,YACA,YAAuB;AAEvB,SAAO,MAAM,WAAW,kCAAkC,eAAe,UAAU;AACvF;;;AC9DA,eAAsB,WAClB,YACA,OACA,eACA,iBACA,UACA,UAAU,QAAQ,SAAQ,GAC1B,gBACA,YAAY,kBAAgB;AAE5B,QAAM,WAAW,MAAM,mCAAmC,UAAU;AAEpE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,cAAc,cAAc;IACxB,YAAY,MAAM;IAClB,kBAAkB,QAAQ;IAC1B,OAAO;IACP;IACA;GACH,GACD,gCAAgC,QAAQ,WAAW,UAAU,eAAe,iBAAiB,SAAS,CAAC;AAG3G,QAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,OAAO,GAAG,cAAc;AAEzF,SAAO,QAAQ;AACnB;;;ACpCA,eAAsB,6BAClB,YACA,OACA,MACA,OACA,gBACA,YAAY,kBACZ,2BAA2B,6BAA2B;AAEtD,QAAM,kBAAkB,MAAM,0BAA0B,MAAM,OAAO,OAAO,WAAW,wBAAwB;AAE/G,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,wCACI,MAAM,WACN,iBACA,OACA,MACA,WACA,wBAAwB,CAC3B;AAGL,QAAM,0BAA0B,YAAY,aAAa,CAAC,KAAK,GAAG,cAAc;AAEhF,SAAO;AACX;;;ACfA,eAAsB,cAClB,YACA,OACA,MACA,OACA,SACA,gBACA,YAAY,kBAAgB;AAG5B,MAAI,CAAC;AAAS,WAAO,MAAM,6BAA6B,YAAY,OAAO,MAAM,OAAO,gBAAgB,SAAS;AAGjH,QAAM,WAAW,MAAM,sCAAsC,UAAU;AAEvE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,cAAc,cAAc;IACxB,YAAY,MAAM;IAClB,kBAAkB,QAAQ;IAC1B,OAAO;IACP;IACA;GACH,GACD,mCAAmC,QAAQ,WAAW,MAAM,OAAO,SAAS,CAAC;AAGjF,QAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,OAAO,GAAG,cAAc;AAEzF,SAAO,QAAQ;AACnB;;;ACzBA,eAAsB,2BAClB,YACA,OACA,OACA,QACA,SACA,gBACA,YAAY,kBAAgB;AAG5B,MAAI,CAAC;AAAQ,WAAO,MAAM,cAAc,YAAY,OAAO,aAAa,OAAO,SAAS,gBAAgB,SAAS;AAGjH,MAAI,CAAC,SAAS;AACV,UAAM,kBAAkB,MAAM,0BAC1B,aACA,OACA,OACA,WACA,2BAA2B;AAG/B,UAAMC,eAAc,IAAI,YAAW,EAAG,IAClC,wCACI,MAAM,WACN,iBACA,OACA,aACA,WACA,2BAA2B,GAE/B,cAAc,SAAS;MACnB,YAAY,MAAM;MAClB,UAAU;MACV,UAAU;KACb,GACD,4BAA4B,iBAAiB,SAAS,CAAC;AAG3D,UAAM,0BAA0B,YAAYA,cAAa,CAAC,KAAK,GAAG,cAAc;AAEhF,WAAO;;AAIX,QAAM,WAAW,MAAM,sCAAsC,UAAU;AAEvE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,cAAc,cAAc;IACxB,YAAY,MAAM;IAClB,kBAAkB,QAAQ;IAC1B,OAAO;IACP;IACA;GACH,GACD,cAAc,SAAS;IACnB,YAAY,MAAM;IAClB,UAAU,QAAQ;IAClB,UAAU;GACb,GACD,mCAAmC,QAAQ,WAAW,aAAa,OAAO,SAAS,CAAC;AAGxF,QAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,OAAO,GAAG,cAAc;AAEzF,SAAO,QAAQ;AACnB;;;ACvEA,eAAsB,eAClB,YACA,OACA,SACA,GACA,UAAU,QAAQ,SAAQ,GAC1B,gBACA,YAAY,kBAAgB;AAE5B,QAAM,WAAW,MAAM,uCAAuC,UAAU;AAExE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,cAAc,cAAc;IACxB,YAAY,MAAM;IAClB,kBAAkB,QAAQ;IAC1B,OAAO;IACP;IACA;GACH,GACD,oCAAoC,QAAQ,WAAW,SAAS,GAAG,SAAS,CAAC;AAGjF,QAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,OAAO,GAAG,cAAc;AAEzF,SAAO,QAAQ;AACnB;;;ACjDM,SAAU,WAAW,kBAAsC,cAAsB;AACnF,SAAO,4BAA4B,YAC7B,CAAC,kBAAkB,YAAY,IAC/B,CAAC,iBAAiB,WAAW,CAAC,gBAAgB,CAAC;AACzD;;;ACqBA,eAAsB,SAClB,YACA,OACA,QACA,aACA,OACA,QACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,gBAAgB,OAAO,IAAI,WAAW,OAAO,YAAY;AAEhE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,0BAA0B,QAAQ,aAAa,gBAAgB,QAAQ,cAAc,SAAS,CAAC;AAGnG,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;AClBA,eAAsB,QAClB,YACA,OACA,SACA,UACA,OACA,QACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,gBAAgB,OAAO,IAAI,WAAW,OAAO,YAAY;AAEhE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,yBAAyB,SAAS,UAAU,gBAAgB,QAAQ,cAAc,SAAS,CAAC;AAGhG,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;ACpBA,eAAsB,OAClB,YACA,OACA,SACA,OACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,gBAAgB,OAAO,IAAI,WAAW,OAAO,YAAY;AAEhE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,wBAAwB,SAAS,gBAAgB,cAAc,SAAS,CAAC;AAG7E,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;ACdA,eAAsB,aAClB,YACA,OACA,SACA,kBACA,eACA,cACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,2BAA2B,OAAO,IAAI,WAAW,kBAAkB,YAAY;AAEtF,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,8BACI,SACA,2BACA,eACA,cACA,cACA,SAAS,CACZ;AAGL,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;ACzBA,eAAsB,OAClB,YACA,OACA,MACA,aACA,WACA,QACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,oBAAoB,OAAO,IAAI,WAAW,WAAW,YAAY;AAExE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,wBAAwB,MAAM,aAAa,oBAAoB,QAAQ,cAAc,SAAS,CAAC;AAGnG,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;AClBA,eAAsB,KAClB,YACA,OACA,SACA,MACA,OACA,QACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,gBAAgB,OAAO,IAAI,WAAW,OAAO,YAAY;AAEhE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,sBAAsB,SAAS,MAAM,gBAAgB,QAAQ,cAAc,SAAS,CAAC;AAGzF,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;ACnBA,eAAsB,aAClB,YACA,OACA,SACA,aACA,WACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,oBAAoB,OAAO,IAAI,WAAW,WAAW,YAAY;AAExE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,8BAA8B,SAAS,aAAa,oBAAoB,cAAc,SAAS,CAAC;AAGpG,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;ACjBA,eAAsB,cAClB,YACA,OACA,SACA,MACA,WACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,oBAAoB,OAAO,IAAI,WAAW,WAAW,YAAY;AAExE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,+BAA+B,SAAS,MAAM,oBAAoB,cAAc,SAAS,CAAC;AAG9F,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;ACjBA,eAAsB,YAClB,YACA,OACA,SACA,MACA,WACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,oBAAoB,OAAO,IAAI,WAAW,WAAW,YAAY;AAExE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,6BAA6B,SAAS,MAAM,oBAAoB,cAAc,SAAS,CAAC;AAG5F,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;ACdA,eAAsB,gBAClB,YACA,OACA,QACA,MACA,aACA,OACA,QACA,UACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,gBAAgB,OAAO,IAAI,WAAW,OAAO,YAAY;AAEhE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,iCACI,QACA,MACA,aACA,gBACA,QACA,UACA,cACA,SAAS,CACZ;AAGL,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;AC7BA,eAAsB,eAClB,YACA,OACA,MACA,SACA,UACA,OACA,QACA,UACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,gBAAgB,OAAO,IAAI,WAAW,OAAO,YAAY;AAEhE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,gCACI,SACA,MACA,UACA,gBACA,QACA,UACA,cACA,SAAS,CACZ;AAGL,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;AC9BA,eAAsB,cAClB,YACA,OACA,MACA,aACA,WACA,QACA,UACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,oBAAoB,OAAO,IAAI,WAAW,WAAW,YAAY;AAExE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,+BAA+B,MAAM,aAAa,oBAAoB,QAAQ,UAAU,cAAc,SAAS,CAAC;AAGpH,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;ACnBA,eAAsB,YAClB,YACA,OACA,SACA,MACA,OACA,QACA,UACA,eAAyB,CAAA,GACzB,gBACA,YAAY,kBAAgB;AAE5B,QAAM,CAAC,gBAAgB,OAAO,IAAI,WAAW,OAAO,YAAY;AAEhE,QAAM,cAAc,IAAI,YAAW,EAAG,IAClC,6BAA6B,SAAS,MAAM,gBAAgB,QAAQ,UAAU,cAAc,SAAS,CAAC;AAG1G,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,OAAO,GAAG,OAAO,GAAG,cAAc;AACvG;;;ACzBA,eAAsB,WAClB,YACA,OACA,SACA,gBACA,YAAY,kBAAgB;AAE5B,QAAM,cAAc,IAAI,YAAW,EAAG,IAAI,4BAA4B,SAAS,SAAS,CAAC;AAEzF,SAAO,MAAM,0BAA0B,YAAY,aAAa,CAAC,KAAK,GAAG,cAAc;AAC3F;;;ACCA,eAAsB,kCAClB,YACA,OACA,MACA,OACA,qBAAqB,OACrB,YACA,gBACA,YAAY,kBACZ,2BAA2B,6BAA2B;AAEtD,QAAM,kBAAkB,MAAM,0BAC1B,MACA,OACA,oBACA,WACA,wBAAwB;AAK5B,MAAI;AACJ,MAAI;AACA,cAAU,MAAM,WAAW,YAAY,iBAAiB,YAAY,SAAS;WACxE,OAAP;AAIE,QAAI,iBAAiB,6BAA6B,iBAAiB,+BAA+B;AAE9F,UAAI;AACA,cAAM,cAAc,IAAI,YAAW,EAAG,IAClC,wCACI,MAAM,WACN,iBACA,OACA,MACA,WACA,wBAAwB,CAC3B;AAGL,cAAM,0BAA0B,YAAY,aAAa,CAAC,KAAK,GAAG,cAAc;eAC3EC,QAAP;;AAMF,gBAAU,MAAM,WAAW,YAAY,iBAAiB,YAAY,SAAS;WAC1E;AACH,YAAM;;;AAId,MAAI,CAAC,QAAQ,KAAK,OAAO,IAAI;AAAG,UAAM,IAAI,sBAAqB;AAC/D,MAAI,CAAC,QAAQ,MAAM,OAAO,KAAK;AAAG,UAAM,IAAI,uBAAsB;AAElE,SAAO;AACX;",
  "names": ["TokenInstruction", "import_buffer_layout", "bigInt", "import_buffer_layout", "bool", "import_buffer_layout", "publicKey", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "AuthorityType", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "AccountState", "import_buffer_layout", "import_buffer_layout", "transaction", "error"]
}
