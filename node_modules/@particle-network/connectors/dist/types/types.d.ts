/// <reference types="node" />
import type { AuthCoreModalOptions } from '@particle-network/auth-core-modal';
import type { Chain, ChainInfo } from '@particle-network/chains';
import type { Connector, ParticleConnector } from '../providers/connectors/base';
export interface Account {
    id: string;
    publicAddress: string;
    name?: string;
    icon?: string;
}
export interface WalletInfo {
    publicAddress: string;
    privateKey: string;
    mnemonic?: string;
}
export declare enum WalletReadyState {
    /**
     * User-installable wallets can typically be detected by scanning for an API
     * that they've injected into the global context. If such an API is present,
     * we consider the wallet to have been installed.
     */
    Installed = "Installed",
    NotDetected = "NotDetected",
    /**
     * Loadable wallets are always available to you. Since you can load them at
     * any time, it's meaningless to say that they have been detected.
     */
    Loadable = "Loadable",
    /**
     * If a wallet is not supported on a given platform (eg. server-rendering, or
     * mobile) then it will stay in the `Unsupported` state.
     */
    Unsupported = "Unsupported"
}
export type ConnectConfig = Omit<AuthCoreModalOptions, 'themeType' | 'language'> & {
    chains: Chain[] | ChainInfo[];
    connectors?: Wallet[];
};
export interface JsonRpcRequest {
    id: number | string;
    jsonrpc: string;
    method: string;
    params?: unknown;
}
export interface EVMProvider {
    on(event: string, listener: any): this;
    once(event: string, listener: any): this;
    off(event: string, listener: any): this;
    removeListener(event: string, listener: any): this;
    request(request: Partial<JsonRpcRequest>): Promise<any>;
    disconnect?(): Promise<void>;
    enable?(): Promise<string[]>;
}
export interface PublicKey {
    toBase58(): string;
    toJSON(): string;
    /**
     * Return the byte array representation of the public key
     */
    toBytes(): Uint8Array;
    /**
     * Return the Buffer representation of the public key
     */
    toBuffer(): Buffer;
    /**
     * Return the base-58 representation of the public key
     */
    toString(): string;
}
export type Commitment = 'processed' | 'confirmed' | 'finalized' | 'recent' | 'single' | 'singleGossip' | 'root' | 'max';
export type SendOptions = {
    /** disable transaction verification step */
    skipPreflight?: boolean;
    /** preflight commitment level */
    preflightCommitment?: Commitment;
    /** Maximum number of times for the RPC node to retry sending the transaction to the leader. */
    maxRetries?: number;
    /** The minimum slot that the request can be evaluated at */
    minContextSlot?: number;
};
export interface SolanaProvider {
    publicKey: PublicKey | null | (() => Promise<PublicKey | null>);
    on(event: string, listener: any): this;
    once(event: string, listener: any): this;
    off(event: string, listener: any): this;
    removeListener(event: string, listener: any): this;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    signAndSendTransaction(transaction: unknown, options?: SendOptions): Promise<string>;
    signTransaction(transaction: unknown): Promise<any>;
    signAllTransactions(transaction: unknown[]): Promise<any[]>;
    signMessage(message: Uint8Array): Promise<Uint8Array>;
}
export type Provider = EVMProvider | SolanaProvider;
export interface ConnectorMap {
    [id: string]: Connector;
}
export interface ParticleConnectorMap {
    [id: string]: ParticleConnector;
}
export interface IConnectDisplay {
    name: string;
    icon: string;
    url: string;
}
export interface IProviderInfo {
    id: string;
    name: string;
    logo: string;
    type: string;
    check: string;
}
export interface IInjectedProvidersMap {
    injectedAvailable: boolean;
    [isProviderName: string]: boolean;
}
export interface DownloadUrls {
    browserExtension?: string;
    qrCode?: string;
}
export type Wallet<C = ParticleConnector> = {
    id: string;
    name: string;
    iconUrl: string;
    downloadUrls?: DownloadUrls;
    createConnector: (chains?: Chain[]) => C;
};
export type WalletMeta = Omit<Wallet, 'createConnector'>;
export type WalletList = {
    groupName: string;
    wallets: Wallet[];
}[];
