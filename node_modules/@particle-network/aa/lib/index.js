"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AAWrapProvider: () => AAWrapProvider,
  SendTransactionEvent: () => SendTransactionEvent,
  SendTransactionMode: () => SendTransactionMode,
  SmartAccount: () => SmartAccount,
  SmartAccountType: () => SmartAccountType
});
module.exports = __toCommonJS(src_exports);

// src/aaWrapProvider.ts
var import_events = __toESM(require("events"), 1);
var SendTransactionMode = /* @__PURE__ */ ((SendTransactionMode2) => {
  SendTransactionMode2[SendTransactionMode2["UserSelect"] = 0] = "UserSelect";
  SendTransactionMode2[SendTransactionMode2["Gasless"] = 1] = "Gasless";
  SendTransactionMode2[SendTransactionMode2["UserPaidNative"] = 2] = "UserPaidNative";
  return SendTransactionMode2;
})(SendTransactionMode || {});
var SendTransactionEvent = /* @__PURE__ */ ((SendTransactionEvent2) => {
  SendTransactionEvent2["Request"] = "RequestSendTransaction";
  SendTransactionEvent2["Resolve"] = "ResolveSendTransaction";
  SendTransactionEvent2["Reject"] = "RejectSendTransaction";
  return SendTransactionEvent2;
})(SendTransactionEvent || {});
var AAWrapProvider = class {
  constructor(smartAccount, sendTxMode = 2 /* UserPaidNative */) {
    this.smartAccount = smartAccount;
    this.sendTxMode = sendTxMode;
    this.events = new import_events.default();
    this.events.setMaxListeners(100);
    if (!Object.values(SendTransactionMode).includes(sendTxMode)) {
      throw new Error(`sendTxMode value error, must in ${Object.values(SendTransactionMode)}`);
    }
  }
  resolveSendTransaction(params) {
    this.events.emit("ResolveSendTransaction" /* Resolve */, params);
  }
  rejectSendTransaction(error) {
    this.events.emit("RejectSendTransaction" /* Reject */, error);
  }
  on(event, listener) {
    if ("RequestSendTransaction" /* Request */ === event) {
      this.events.on(event, listener);
    } else {
      this.smartAccount.provider.on(event, listener);
    }
    return this;
  }
  once(event, listener) {
    if ("RequestSendTransaction" /* Request */ === event) {
      this.events.once(event, listener);
    } else {
      this.smartAccount.provider.once(event, listener);
    }
    return this;
  }
  off(event, listener) {
    if ("RequestSendTransaction" /* Request */ === event) {
      this.events.off(event, listener);
    } else {
      this.smartAccount.provider.off(event, listener);
    }
    return this;
  }
  removeListener(event, listener) {
    if ("RequestSendTransaction" /* Request */ === event) {
      this.events.removeListener(event, listener);
    } else {
      this.smartAccount.provider.removeListener(event, listener);
    }
    return this;
  }
  enable() {
    return this.request({
      method: "eth_requestAccounts"
    });
  }
  request(payload) {
    return __async(this, null, function* () {
      if (payload.method === "eth_requestAccounts" || payload.method === "eth_accounts") {
        yield this.smartAccount.provider.request(payload);
        const address = yield this.smartAccount.getAddress();
        return [address];
      } else if (payload.method === "eth_sendTransaction") {
        if (!payload.params) {
          return Promise.reject(new Error("send transaction param error"));
        }
        const txData = payload.params[0];
        const feeQuotesResult = yield this.smartAccount.getFeeQuotes(txData);
        if (this.sendTxMode === 1 /* Gasless */) {
          const { userOp, userOpHash } = feeQuotesResult.verifyingPaymasterGasless || feeQuotesResult.verifyingPaymasterNative;
          return this.smartAccount.sendUserOperation({ userOp, userOpHash });
        } else if (this.sendTxMode === 2 /* UserPaidNative */) {
          const { userOp, userOpHash } = feeQuotesResult.verifyingPaymasterNative;
          return this.smartAccount.sendUserOperation({ userOp, userOpHash });
        }
        return new Promise((resolve, reject) => {
          this.events.removeAllListeners("RejectSendTransaction" /* Reject */);
          this.events.removeAllListeners("ResolveSendTransaction" /* Resolve */);
          this.events.once("ResolveSendTransaction" /* Resolve */, (params) => __async(this, null, function* () {
            try {
              const sendParams = __spreadProps(__spreadValues({}, params), { tx: txData });
              const txHash = yield this.smartAccount.sendTransaction(sendParams);
              resolve(txHash);
            } catch (error) {
              reject(error);
            }
          }));
          this.events.once("RejectSendTransaction" /* Reject */, reject);
          this.events.emit("RequestSendTransaction" /* Request */, feeQuotesResult);
        });
      }
      return this.smartAccount.provider.request(payload);
    });
  }
};

// src/smartAccount.ts
var import_axios = __toESM(require("axios"), 1);

// src/types.ts
var SmartAccountType = /* @__PURE__ */ ((SmartAccountType2) => {
  SmartAccountType2["SIMPLE"] = "SIMPLE";
  SmartAccountType2["CYBERCONNECT"] = "CYBERCONNECT";
  SmartAccountType2["BICONOMY"] = "BICONOMY";
  return SmartAccountType2;
})(SmartAccountType || {});

// src/utils.ts
var rpcUrl = () => {
  const productionApi = "https://rpc.particle.network";
  const developmentApi = "https://rpc-debug.particle.network";
  const dev = typeof window !== "undefined" && window.__PARTICLE_ENVIRONMENT__ === "development";
  return dev ? developmentApi : productionApi;
};
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}

// src/smartAccount.ts
var SmartAccount = class {
  constructor(provider, config) {
    this.provider = provider;
    this.config = config;
    this.smartAccountType = "BICONOMY" /* BICONOMY */;
    this.getChainId = () => __async(this, null, function* () {
      return yield this.provider.request({ method: "eth_chainId" });
    });
    if (this.config.aaOptions.biconomy && this.config.aaOptions.biconomy.length > 0) {
      this.smartAccountType = "BICONOMY" /* BICONOMY */;
    } else if (this.config.aaOptions.cyberConnect && this.config.aaOptions.cyberConnect.length > 0) {
      this.smartAccountType = "CYBERCONNECT" /* CYBERCONNECT */;
    } else if (this.config.aaOptions.simple && this.config.aaOptions.simple.length > 0) {
      this.smartAccountType = "SIMPLE" /* SIMPLE */;
    } else {
      throw new Error("aaOptions is not configured correctly");
    }
    this.connection = import_axios.default.create({
      baseURL: `${rpcUrl()}/evm-chain`,
      timeout: 6e4
    });
    this.connection.interceptors.request.use((config2) => {
      var _a, _b, _c;
      if ((_a = config2 == null ? void 0 : config2.data) == null ? void 0 : _a.method) {
        config2.baseURL = `${config2.baseURL}${((_b = config2.baseURL) == null ? void 0 : _b.includes("?")) ? "&" : "?"}method=${(_c = config2 == null ? void 0 : config2.data) == null ? void 0 : _c.method}`;
      }
      return config2;
    });
  }
  setSmartAccountType(type) {
    this.smartAccountType = type;
  }
  getAccountConfig() {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const chainId = yield this.getChainId();
      const apiKey = yield this.getPaymasterApiKey();
      const ownerAddress = (yield this.provider.request({ method: "eth_accounts" }))[0];
      if (this.smartAccountType === "BICONOMY" /* BICONOMY */) {
        const networkConfig = (_a = this.config.aaOptions.biconomy) == null ? void 0 : _a.find((item) => item.chainId === Number(chainId));
        if (networkConfig) {
          return {
            name: "BICONOMY" /* BICONOMY */,
            version: networkConfig.version,
            biconomyApiKey: apiKey,
            ownerAddress
          };
        }
      } else if (this.smartAccountType === "CYBERCONNECT" /* CYBERCONNECT */) {
        const networkConfig = (_b = this.config.aaOptions.cyberConnect) == null ? void 0 : _b.find((item) => item.chainId === Number(chainId));
        if (networkConfig) {
          return {
            name: "CYBERCONNECT" /* CYBERCONNECT */,
            version: networkConfig.version,
            biconomyApiKey: apiKey,
            ownerAddress
          };
        }
      } else if (this.smartAccountType === "SIMPLE" /* SIMPLE */) {
        const networkConfig = (_c = this.config.aaOptions.simple) == null ? void 0 : _c.find((item) => item.chainId === Number(chainId));
        if (networkConfig) {
          return {
            name: "SIMPLE" /* SIMPLE */,
            version: networkConfig.version,
            biconomyApiKey: apiKey,
            ownerAddress
          };
        }
      } else {
        throw new Error(`smart account type error, unsupport type: ${this.smartAccountType}`);
      }
      throw new Error(`Current chain is not supported, chainId: ${chainId}, please configure it first`);
    });
  }
  getPaymasterApiKey() {
    return __async(this, null, function* () {
      var _a;
      const chainId = yield this.getChainId();
      const apiKeyConfig = (_a = this.config.aaOptions.paymasterApiKeys) == null ? void 0 : _a.find((item) => item.chainId === Number(chainId));
      return apiKeyConfig == null ? void 0 : apiKeyConfig.apiKey;
    });
  }
  getFeeQuotes(tx) {
    return __async(this, null, function* () {
      const accountConfig = yield this.getAccountConfig();
      return this.sendRpc({
        method: "particle_aa_getFeeQuotes",
        params: [accountConfig, Array.isArray(tx) ? tx : [tx]]
      });
    });
  }
  buildUserOperation(_0) {
    return __async(this, arguments, function* ({ tx, feeQuote, tokenPaymasterAddress }) {
      const accountConfig = yield this.getAccountConfig();
      return yield this.sendRpc({
        method: "particle_aa_createUserOp",
        params: [accountConfig, Array.isArray(tx) ? tx : [tx], feeQuote, tokenPaymasterAddress].filter(
          (val) => !!val
        )
      });
    });
  }
  signUserOperation(_0) {
    return __async(this, arguments, function* ({ userOpHash, userOp }) {
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      const signature = yield this.provider.request({
        method: "personal_sign",
        params: [userOpHash, eoas[0]]
      });
      return __spreadProps(__spreadValues({}, userOp), { signature });
    });
  }
  sendUserOperation(_0) {
    return __async(this, arguments, function* ({ userOpHash, userOp }) {
      const signedUserOp = yield this.signUserOperation({ userOpHash, userOp });
      return this.sendSignedUserOperation(signedUserOp);
    });
  }
  sendSignedUserOperation(userOp) {
    return __async(this, null, function* () {
      const accountConfig = yield this.getAccountConfig();
      return this.sendRpc({
        method: "particle_aa_sendUserOp",
        params: [accountConfig, userOp]
      });
    });
  }
  sendTransaction(params) {
    return __async(this, null, function* () {
      if (Object.prototype.hasOwnProperty.call(params, "userOpHash") && Object.prototype.hasOwnProperty.call(params, "userOp")) {
        const { userOpHash, userOp } = params;
        if (userOpHash && userOp) {
          return this.sendUserOperation({ userOpHash, userOp });
        }
      }
      const { tx, feeQuote, tokenPaymasterAddress } = params;
      const userOpBundle = yield this.buildUserOperation({ tx, feeQuote, tokenPaymasterAddress });
      return this.sendUserOperation(userOpBundle);
    });
  }
  getAccount() {
    return __async(this, null, function* () {
      const accountConfig = yield this.getAccountConfig();
      const accounts = yield this.sendRpc({
        method: "particle_aa_getSmartAccount",
        params: [accountConfig]
      });
      return accounts[0];
    });
  }
  getAddress() {
    return __async(this, null, function* () {
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      if (!eoas || eoas.length === 0) {
        return "";
      }
      const accountConfig = yield this.getAccountConfig();
      const localKey = `particle_${accountConfig.name}_${accountConfig.version}_${eoas[0]}`;
      if (typeof window !== "undefined" && localStorage) {
        const localAA = localStorage.getItem(localKey);
        if (localAA) {
          return localAA;
        }
      }
      const account = yield this.getAccount();
      const address = account.smartAccountAddress;
      if (typeof window !== "undefined" && localStorage) {
        localStorage.setItem(localKey, address);
      }
      return address;
    });
  }
  getOwner() {
    return __async(this, null, function* () {
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      return eoas[0];
    });
  }
  isDeployed() {
    return __async(this, null, function* () {
      const account = yield this.getAccount();
      return account.isDeployed;
    });
  }
  deployWalletContract() {
    return __async(this, null, function* () {
      return this.sendTransaction({
        tx: {
          to: "0x0000000000000000000000000000000000000000",
          data: "0x"
        }
      });
    });
  }
  sendRpc(arg) {
    return __async(this, null, function* () {
      const chainId = yield this.getChainId();
      const response = yield this.connection.post(
        "",
        __spreadProps(__spreadValues({}, arg), {
          id: payloadId(),
          jsonrpc: "2.0"
        }),
        {
          params: {
            chainId: Number(chainId),
            projectUuid: this.config.projectId,
            projectKey: this.config.clientKey
          }
        }
      ).then((res) => res.data);
      if (response.error) {
        return Promise.reject(response.error);
      } else {
        return response.result;
      }
    });
  }
};
//# sourceMappingURL=index.js.map
