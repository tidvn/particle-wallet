"use client";
import {
  AuthError,
  bnToHex,
  getEvmChain,
  getSolanaChain,
  isNullish,
  isServer,
  isValidCaptcha,
  isValidE164PhoneNumber,
  isValidEmail,
  sendAnalyticsActive,
  toHexPrefixString,
  useCustomNavigate,
  useEvents,
  useModalOptions,
  useParticleAuth
} from "./chunk-EKFKQUBM.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod
} from "./chunk-LQ53OFQ3.js";

// src/context/hooks/useAuthCore.ts
import {
  AuthCoreEvent,
  getSecurityAccount,
  hasMasterPassword,
  hasPaymentPassword,
  isConnected,
  isNeedRestoreWallet,
  particleAuth
} from "@particle-network/auth-core";
import { walletEntryPlugin } from "@particle-network/wallet";
import { useCallback, useEffect, useState } from "react";

// src/common/config/index.ts
var _devEnv, _stagingEnv, _productionEnv;
var GlobalConfig = class {
  constructor() {
    __privateAdd(this, _devEnv, {
      buyUrl: "https://ramp-debug.particle.network"
    });
    __privateAdd(this, _stagingEnv, {
      buyUrl: "https://ramp-staging.particle.network"
    });
    __privateAdd(this, _productionEnv, {
      buyUrl: "https://ramp.particle.network"
    });
  }
  get env() {
    if (!isServer() && window.__PARTICLE_ENVIRONMENT__ === "development") {
      return __privateGet(this, _devEnv);
    } else if (!isServer() && window.__PARTICLE_ENVIRONMENT__ === "staging") {
      return __privateGet(this, _stagingEnv);
    } else {
      return __privateGet(this, _productionEnv);
    }
  }
};
_devEnv = new WeakMap();
_stagingEnv = new WeakMap();
_productionEnv = new WeakMap();
var globalConfig = new GlobalConfig();
var config_default = globalConfig;

// src/context/hooks/useAuthCore.ts
var useAuthCore = () => {
  const navigate = useCustomNavigate();
  const { userInfo, modalOptions } = useParticleAuth();
  const [needRestoreWallet, setNeedRestoreWallet] = useState(isNeedRestoreWallet());
  const openAccountAndSecurity = useCallback(() => {
    navigate("account/security" /* AccountSecurity */);
  }, [navigate]);
  const openSetMasterPassword = useCallback(() => {
    if (hasMasterPassword()) {
      throw new Error("Master password already exists.");
    }
    navigate("account/master-password");
  }, [navigate]);
  const openChangeMasterPassword = useCallback(() => {
    if (!hasMasterPassword()) {
      throw new Error("Master password not exist, please set it first!");
    }
    if (isNeedRestoreWallet()) {
      throw new Error("Wallet not restore, please restore it by master password first!");
    }
    navigate("account/master-password/change");
  }, [navigate]);
  const openRestoreByMasterPassword = useCallback(() => {
    if (!hasMasterPassword()) {
      throw new Error("Master password not exists.");
    }
    if (!isNeedRestoreWallet()) {
      throw new Error("Wallet has been restore.");
    }
    navigate("account/master-password/verify" /* MasterPasswordVerify */);
  }, [navigate]);
  const openWallet = useCallback((options) => {
    const { windowSize, pathName, query, topMenuType } = options || {};
    if (!isConnected()) {
      throw AuthError.notLogin();
    }
    walletEntryPlugin.openWallet({
      windowSize: windowSize || "large",
      pathName: pathName || "/",
      query,
      topMenuType
    });
    sendAnalyticsActive("open_wallet");
  }, []);
  const buildWalletUrl = useCallback((options) => {
    if (!isConnected()) {
      throw AuthError.notLogin();
    }
    return walletEntryPlugin.getWalletUrl(options);
  }, []);
  const openBuy = useCallback(
    (options) => {
      var _a;
      let url = `${config_default.env.buyUrl}/?language=${modalOptions.language || "en"}&theme=${modalOptions.themeType || "light"}`;
      if ((_a = modalOptions.wallet) == null ? void 0 : _a.customStyle) {
        const { light, dark } = modalOptions.wallet.customStyle;
        url += `&customStyle=${encodeURIComponent(
          Buffer.from(JSON.stringify({ light, dark })).toString("base64")
        )}`;
      }
      if (options) {
        Object.keys(options).forEach((key) => {
          const value = options[key];
          if (value) {
            url += `&${key}=${encodeURIComponent(value)}`;
          }
        });
      }
      if (typeof window !== "undefined") {
        window.open(url);
      }
    },
    [modalOptions.wallet, modalOptions.themeType, modalOptions.language]
  );
  const openSetPaymentPassword = useCallback(
    (securityAccountEmailOrPhone) => {
      const securityAccount = getSecurityAccount();
      if (!securityAccount.email && !securityAccount.phone) {
        throw new Error("Please set security account first!");
      }
      if (hasPaymentPassword()) {
        throw new Error("Payment password already exists.");
      }
      if (securityAccountEmailOrPhone && securityAccountEmailOrPhone !== securityAccount.email && securityAccountEmailOrPhone !== securityAccount.phone) {
        throw new Error("Invalid security account.");
      }
      navigate("account/set-password", {
        state: {
          account: securityAccountEmailOrPhone
        }
      });
    },
    [navigate]
  );
  const openChangePaymentPassword = useCallback(() => {
    if (!hasPaymentPassword()) {
      throw new Error("Payment password not exists.");
    }
    navigate("account/change-password");
  }, [navigate]);
  const openSetSecurityAccount = useCallback(() => {
    const securityAccount = getSecurityAccount();
    if (securityAccount.email && securityAccount.phone) {
      throw new Error("Security account already exists.");
    }
    const showSwitch = !securityAccount.email && !securityAccount.phone;
    if (securityAccount.email && !securityAccount.phone || !securityAccount.email && securityAccount.phone) {
      navigate("/account/verify", {
        state: {
          account: securityAccount.email || securityAccount.phone,
          authType: securityAccount.email ? "phone" : "email",
          redirectUrl: "/account/security",
          pageType: "verify_security_account_set_security_account" /* VerifySecurityAccount_SetSecurityAccount */
        }
      });
    } else {
      if ((userInfo == null ? void 0 : userInfo.email) && !securityAccount.phone) {
        navigate("account/bind", {
          state: { showSwitch, accountType: "phone", redirectUrl: "account/security" /* AccountSecurity */ }
        });
      } else if (!securityAccount.email) {
        navigate("account/bind", {
          state: { showSwitch, accountType: "email", redirectUrl: "account/security" /* AccountSecurity */ }
        });
      } else {
        navigate("account/bind", {
          state: { showSwitch, accountType: "phone", redirectUrl: "account/security" /* AccountSecurity */ }
        });
      }
    }
  }, [navigate, userInfo]);
  const openLinkLoginAccount = useCallback(() => {
    const securityAccount = getSecurityAccount();
    if (!securityAccount.email && !securityAccount.phone) {
      throw new Error("Please set security account first!");
    }
    navigate("login-account" /* LoginAccount */);
  }, [navigate]);
  useEffect(() => {
    if (userInfo) {
      setNeedRestoreWallet(isNeedRestoreWallet());
    } else {
      setNeedRestoreWallet(false);
    }
  }, [userInfo]);
  useEffect(() => {
    const onWalletRestored = () => {
      setNeedRestoreWallet(isNeedRestoreWallet());
    };
    particleAuth.on(AuthCoreEvent.ParticleWalletRestored, onWalletRestored);
    return () => {
      particleAuth.off(AuthCoreEvent.ParticleWalletRestored, onWalletRestored);
    };
  }, []);
  return {
    userInfo,
    needRestoreWallet,
    openAccountAndSecurity,
    openSetMasterPassword,
    openChangeMasterPassword,
    openRestoreByMasterPassword,
    openSetPaymentPassword,
    openChangePaymentPassword,
    openSetSecurityAccount,
    openLinkLoginAccount,
    openWallet,
    buildWalletUrl,
    openBuy
  };
};

// src/context/hooks/useLogin.ts
import { RecordType } from "@particle-network/analytics";
import { analyticsRecord, connect, thirdpartyAuth } from "@particle-network/auth-core";
import base64url from "base64url";
import { useCallback as useCallback2 } from "react";

// src/repository/index.ts
function save(key, value) {
  if (value) {
    localStorage.setItem(key, value);
  } else {
    removeItem(key);
  }
}
function load(key) {
  return localStorage.getItem(key);
}
function once(key) {
  const value = localStorage.getItem(key);
  if (!value) {
    localStorage.setItem(key, "1");
  }
  return Boolean(value);
}
function removeItem(key) {
  localStorage.removeItem(key);
}
var PreferenceKey = class {
};
PreferenceKey.PN_OPEN_SET_PAYMENT_PASSWORD = "PN_OPEN_SET_PAYMENT_PASSWORD";
PreferenceKey.PN_OPEN_SET_MASTER_PASSWORD = "PN_OPEN_SET_MASTER_PASSWORD";

// src/api/master-password.ts
var isPromptSetMasterPassword = (promptMasterPasswordSettingWhenLogin) => {
  if (promptMasterPasswordSettingWhenLogin === 2 /* every */ || promptMasterPasswordSettingWhenLogin === 3 /* everyAndNotSkip */) {
    return true;
  } else if (promptMasterPasswordSettingWhenLogin || promptMasterPasswordSettingWhenLogin === 1 /* first */) {
    return !once(PreferenceKey.PN_OPEN_SET_MASTER_PASSWORD);
  } else {
    return false;
  }
};

// src/context/hooks/useLogin.ts
var useLogin = () => {
  const navigate = useCustomNavigate();
  const { loginSuccessRedirectToApp, modalOptions, events } = useParticleAuth();
  const loginHandler = useCallback2(
    async (data, emitError = true) => {
      var _a, _b;
      try {
        const userInfo = await connect(data);
        sendAnalyticsActive("login", userInfo);
        analyticsRecord({
          record_type: RecordType.PAGE_LOGIN_BUTTON_CLICK_SUCCESS
        });
        console.log("login successful, check master password");
        if ((_a = userInfo.security_account) == null ? void 0 : _a.has_set_master_password) {
          console.log("login successful, start verify master password");
          navigate("account/master-password/verify" /* MasterPasswordVerify */, {
            replace: true,
            state: {
              loginVerifyMasterPassword: true
            }
          });
        } else {
          if (isPromptSetMasterPassword(
            (_b = modalOptions.promptSettingConfig) == null ? void 0 : _b.promptMasterPasswordSettingWhenLogin
          )) {
            console.log("login successful, popup set master password");
            navigate("account/master-password/prompt" /* MasterPasswordPrompt */, {
              replace: true
            });
          } else {
            loginSuccessRedirectToApp();
          }
        }
      } catch (error) {
        analyticsRecord({
          record_type: RecordType.PAGE_LOGIN_BUTTON_CLICK_FAILURE
        });
        if (emitError) {
          console.log("login failed, emit LoginFail event", error);
          events.emit("loginFail" /* LoginFail */, error);
        } else {
          throw error;
        }
      }
    },
    [modalOptions.promptSettingConfig, navigate, loginSuccessRedirectToApp]
  );
  const socialAuthLogin = useCallback2(
    async (options) => {
      try {
        const appState = base64url(
          JSON.stringify({
            chain: options.chain,
            authorization: options.authorization,
            socialType: options.socialType
          })
        );
        await thirdpartyAuth({
          authType: options.socialType,
          appState,
          prompt: options.prompt
        });
      } catch (error) {
        events.emit("loginFail" /* LoginFail */, error);
      }
    },
    [events]
  );
  return { loginHandler, socialAuthLogin };
};
var useLogin_default = useLogin;

// src/context/hooks/useConnect.ts
import {
  AuthCoreEvent as AuthCoreEvent2,
  AuthType,
  check,
  disconnect,
  getCloudflareTurnstileResponse,
  getConnectCaptcha,
  isConnected as isConnected2,
  isNullish as isNullish2,
  particleAuth as particleAuth2,
  requireNotNullish
} from "@particle-network/auth-core";
import { useCallback as useCallback3, useEffect as useEffect2, useMemo } from "react";
var useConnect = () => {
  const navigate = useCustomNavigate();
  const { events } = useEvents();
  const {
    modalOptions,
    setLoginAuthorization,
    setConnectionStatus,
    connectionStatus,
    setAuthCoreModal,
    socialConnectCallback,
    setSocialConnectCallback
  } = useParticleAuth();
  const { loginHandler, socialAuthLogin } = useLogin_default();
  const isLoginDirectly = useCallback3((options) => {
    const { email, phone, code, jwt, socialType } = options;
    return (isValidEmail(email) || isValidE164PhoneNumber(phone)) && isValidCaptcha(code) || socialType || jwt;
  }, []);
  const connect2 = useCallback3(
    async (options) => {
      if (options && options.authorization) {
        check(options.chain, "chain is required when authorization is provided");
      }
      if (options && modalOptions.authTypes && modalOptions.authTypes.length > 0) {
        if ("email" in options && !isNullish2(options.email)) {
          check(
            modalOptions.authTypes.includes(AuthType.email),
            'Email login is not supported, please add AuthType.email to AuthCoreContextProvider init-param "authTypes"'
          );
        } else if ("phone" in options && !isNullish2(options.phone)) {
          check(
            modalOptions.authTypes.includes(AuthType.phone),
            'Phone login is not supported, please add AuthType.phone to AuthCoreContextProvider init-param "authTypes"'
          );
        } else if ("socialType" in options && options.socialType) {
          const type = options.socialType === "twitterv1" ? "twitter" : options.socialType;
          check(
            modalOptions.authTypes.includes(type),
            `${type} login is not supported, please add AuthType.${type} to AuthCoreContextProvider init-param "authTypes"`
          );
        } else if ("jwt" in options && options.jwt) {
          check(
            modalOptions.authTypes.includes(AuthType.jwt),
            'JWT login is not supported, please add AuthType.jwt to AuthCoreContextProvider init-param "authTypes"'
          );
        }
      }
      setConnectionStatus("connecting");
      return new Promise((resolve, reject) => {
        events.once("loginSuccess" /* LoginSuccess */, (userInfo) => {
          var _a;
          setConnectionStatus("connected");
          setAuthCoreModal({
            particleModalVisible: false
          });
          const { socialType, nonce, code } = options || {};
          if (socialType && nonce && code) {
            (_a = socialConnectCallback == null ? void 0 : socialConnectCallback.onSuccess) == null ? void 0 : _a.call(socialConnectCallback, userInfo);
          }
          resolve(userInfo);
        });
        events.once("loginFail" /* LoginFail */, (error) => {
          var _a;
          setConnectionStatus("disconnected");
          setAuthCoreModal({
            particleModalVisible: false
          });
          const { socialType, nonce, code } = options || {};
          if (socialType && nonce && code) {
            (_a = socialConnectCallback == null ? void 0 : socialConnectCallback.onError) == null ? void 0 : _a.call(socialConnectCallback, error);
          }
          reject(error);
        });
        if (options && isLoginDirectly(options)) {
          const { authorization, chain, socialType, nonce, prompt, code } = options;
          if (authorization) {
            setLoginAuthorization({ authorization, chain: requireNotNullish(chain) });
          } else {
            setLoginAuthorization(void 0);
          }
          if (socialType && (!nonce || !code)) {
            socialAuthLogin({
              socialType,
              prompt,
              authorization,
              chain
            });
          } else {
            loginHandler(options);
          }
        } else {
          navigate("login" /* Login */, {
            state: options
          });
        }
      });
    },
    [events, modalOptions.authTypes, loginHandler, isLoginDirectly, navigate, socialConnectCallback]
  );
  useEffect2(() => {
    const onConnect = () => {
      setConnectionStatus("connected");
    };
    const onDisconnect = () => {
      setConnectionStatus("disconnected");
    };
    particleAuth2.on(AuthCoreEvent2.ParticleAuthConnect, onConnect);
    particleAuth2.on(AuthCoreEvent2.ParticleAuthDisconnect, onDisconnect);
    if (isConnected2()) {
      setConnectionStatus("connected");
    }
    return () => {
      particleAuth2.off(AuthCoreEvent2.ParticleAuthConnect, onConnect);
      particleAuth2.off(AuthCoreEvent2.ParticleAuthDisconnect, onDisconnect);
    };
  }, []);
  const requestConnectCaptcha = useCallback3(
    async (config) => {
      if ("email" in config && config.email) {
        return await getConnectCaptcha(config);
      } else if ("phone" in config && config.phone) {
        const token = await getCloudflareTurnstileResponse(config.cloudflareOptions);
        return await getConnectCaptcha({ phone: config.phone, cf_turnstile_response: token });
      }
      throw new Error("Invalid config");
    },
    []
  );
  const connected = useMemo(() => connectionStatus === "connected", [connectionStatus]);
  return {
    connect: connect2,
    disconnect,
    connectionStatus,
    connected,
    requestConnectCaptcha,
    setSocialConnectCallback
  };
};

// src/context/hooks/useCustomize.ts
var useCustomize = () => {
  const { modalOptions, setModalOptions } = useParticleAuth();
  const setThemeType = (themeType) => {
    setModalOptions({
      themeType
    });
  };
  const setCustomStyle = (customStyle) => {
    setModalOptions({
      customStyle: customStyle ? { ...customStyle } : void 0
    });
  };
  const setLanguage = (language) => {
    setModalOptions({
      language
    });
  };
  const setAuthTypes = (authTypes) => {
    setModalOptions({
      authTypes: authTypes ? [...authTypes] : void 0
    });
  };
  const setFiatCoin = (fiatCoin) => {
    setModalOptions({
      fiatCoin
    });
  };
  const setERC4337 = (erc4337) => {
    setModalOptions({
      erc4337
    });
  };
  const setWalletOptions = (wallet) => {
    setModalOptions({
      wallet: { ...wallet }
    });
  };
  const setPromptSettingConfig = (promptSettingConfig) => {
    setModalOptions({
      promptSettingConfig
    });
  };
  return {
    themeType: modalOptions.themeType,
    setThemeType,
    customStyle: modalOptions.customStyle,
    setCustomStyle,
    walletOptions: modalOptions.wallet,
    setWalletOptions,
    language: modalOptions.language,
    setLanguage,
    authTypes: modalOptions.authTypes,
    setAuthTypes,
    fiatCoin: modalOptions.fiatCoin,
    setFiatCoin,
    erc4337: modalOptions.erc4337,
    setERC4337,
    promptSettingConfig: modalOptions.promptSettingConfig,
    setPromptSettingConfig
  };
};

// src/utils/number-utils.ts
import { isHexString, stripHexPrefix } from "@ethereumjs/util";
import { BigNumber } from "bignumber.js";
import BN from "bn.js";
import ethjs from "ethjs-unit";
import numbro from "numbro";
function formatTokenAmount(amount, decimals) {
  if (!amount || !decimals) {
    return "0";
  }
  return numbro(amount / Math.pow(10, decimals)).format({
    thousandSeparated: true,
    mantissa: decimals,
    trimMantissa: true
  });
}
function toWeiBigNumber(amount, unit = "ether") {
  return new BigNumber(bnToHex(toWei(amount, unit)));
}
function toBigNumber(amount) {
  if (typeof amount === "string" || typeof amount === "number") {
    return new BigNumber(amount);
  }
  return new BigNumber(toHexPrefixString(amount));
}
function toWei(amount, unit = "ether") {
  if (!amount) {
    return new BN(0);
  }
  return ethjs.toWei(amount, unit);
}
function fromWei(amount, unit = "ether") {
  if (!amount) {
    return "0";
  }
  let result;
  if (typeof amount === "string" && amount.startsWith("0x")) {
    result = ethjs.fromWei(new BN(stripHexPrefix(amount), 16), unit);
  } else {
    result = ethjs.fromWei(amount, unit);
  }
  return result;
}
function fromWeiFormat(amount, unit = "ether", mantissa = 6) {
  if (!amount) {
    return "0";
  }
  let result;
  if (typeof amount === "string" && amount.startsWith("0x")) {
    result = ethjs.fromWei(new BN(stripHexPrefix(amount), 16), unit);
  } else {
    result = ethjs.fromWei(amount, unit);
  }
  return numbro(result).format({
    thousandSeparated: true,
    trimMantissa: true,
    mantissa
  });
}
function formatPrice({
  amount,
  price,
  mantissa,
  fiatCoin
}) {
  if (!price) {
    return "";
  }
  const value = new BigNumber(amount).multipliedBy(new BigNumber(price));
  if (isNullish(mantissa)) {
    if (value.lt(new BigNumber(1))) {
      mantissa = 4;
    } else {
      mantissa = 2;
    }
  }
  return `\u2248${numbro(value).format({
    thousandSeparated: true,
    trimMantissa: true,
    mantissa
  }).replace(/-0$/, "0")} ${fiatCoin.toUpperCase()}`;
}
function trimDecimals(value, mantissa = 6) {
  return numbro(value).format({
    thousandSeparated: true,
    trimMantissa: true,
    mantissa
  });
}
function fromSunFormat(amount, mantissa = 6) {
  const bn = new BigNumber(amount, isHexString(amount) ? 16 : 10);
  const value = bn.div(new BigNumber(1e6)).toString(10);
  return numbro(value).format({
    thousandSeparated: true,
    trimMantissa: true,
    mantissa
  });
}
var formatTokenAmount2 = (value, decimals) => {
  let bn;
  if (!(value instanceof BigNumber)) {
    bn = new BigNumber(value).dividedBy(new BigNumber(10).pow(decimals));
  } else {
    bn = value;
  }
  const str = bn.toFixed();
  const [int, dec] = str.split(".");
  let decimalLength = 9;
  if (int.length > 15) {
    return bn.toExponential(2);
  }
  if (int.length > 5) {
    decimalLength = Math.max(9 - (int.length - 5), 0);
  }
  if (dec && decimalLength > 0) {
    const decPart = dec.slice(0, decimalLength);
    return new BigNumber(`${int}.${decPart}`).toFixed();
  }
  return int;
};

// src/context/hooks/useUserInfo.ts
var useUserInfo = () => {
  const { userInfo } = useParticleAuth();
  return {
    userInfo
  };
};

// src/context/hooks/useEthereum.ts
import {
  AuthCoreEvent as AuthCoreEvent3,
  AuthType as AuthType2,
  EvmRpcMethod as EvmRpcMethod2,
  SignTypedDataVersion,
  check as check2,
  getLatestAuthType,
  isConnected as isConnected3,
  particleAuth as particleAuth4,
  requireNotNullish as requireNotNullish3
} from "@particle-network/auth-core";
import { chains as chains4 } from "@particle-network/chains";
import { useCallback as useCallback4, useEffect as useEffect3, useMemo as useMemo2, useState as useState2 } from "react";

// src/utils/evmSendTransaction.ts
import {
  EvmEnhancedMethod,
  GasFeeMode,
  isNullish as isNullish3,
  particleAuth as particleAuth3
} from "@particle-network/auth-core";
import { chains as chains2 } from "@particle-network/chains";

// src/utils/transaction-utils.ts
import { isHexString as isHexString2 } from "@ethereumjs/util";
import { tronAddressToHex } from "@particle-network/auth-core";
import { chains } from "@particle-network/chains";
function isEIP1559Type(type) {
  if (typeof type == "number") {
    return type === 2;
  } else if (typeof type == "string") {
    return Number(type) === 2;
  }
  return false;
}
var parseValue = (value) => {
  if (typeof value === "string") {
    return `0x${Number(value).toString(16)}`;
  } else {
    return toHexPrefixString(value);
  }
};
function parseTransaction(txData, chainInfo) {
  let nonce, gasPrice, gasLimit, from, to, value, data, type, chainId, maxPriorityFeePerGas, maxFeePerGas, action, gasLevel;
  const tron = isTron(chainInfo);
  if (tron && !isHexString2(txData.from)) {
    from = tronAddressToHex(txData.from);
  } else {
    from = txData.from;
  }
  if (txData.to) {
    if (tron && !isHexString2(txData.to)) {
      to = tronAddressToHex(txData.to);
    } else {
      to = txData.to;
    }
  }
  if (txData.gas && !txData.gasLimit) {
    gasLimit = parseValue(txData.gas);
  } else if (txData.gasLimit) {
    gasLimit = parseValue(txData.gasLimit);
  }
  if (txData.value) {
    value = parseValue(txData.value);
  }
  if (txData.data) {
    data = toHexPrefixString(txData.data);
  }
  if (txData.chainId) {
    chainId = parseValue(txData.chainId);
  } else {
    chainId = parseValue(chainInfo.id);
  }
  if (txData.nonce) {
    nonce = parseValue(txData.nonce);
  }
  if ("maxPriorityFeePerGas" in txData && txData.maxPriorityFeePerGas) {
    maxPriorityFeePerGas = parseValue(txData.maxPriorityFeePerGas);
  }
  if ("maxFeePerGas" in txData && txData.maxFeePerGas) {
    maxFeePerGas = parseValue(txData.maxFeePerGas);
  }
  if (txData.gasPrice) {
    gasPrice = parseValue(txData.gasPrice);
  }
  if (txData.type || txData.type === 0) {
    type = parseValue(txData.type);
  } else {
    if ("maxPriorityFeePerGas" in txData && txData.maxPriorityFeePerGas && "maxFeePerGas" in txData && txData.maxFeePerGas && chains.isChainSupportEIP1559(chainInfo)) {
      type = "0x2";
    } else if ("gasPrice" in txData && txData.gasPrice) {
      type = "0x0";
    } else {
      type = chains.isChainSupportEIP1559(chainInfo) ? "0x2" : "0x0";
    }
  }
  if (txData.action && ["normal", "cancel", "speedup"].includes(txData.action)) {
    action = txData.action;
  } else {
    action = void 0;
  }
  if (txData.gasLevel && ["custom", "low", "medium", "high"].includes(txData.gasLevel)) {
    gasLevel = txData.gasLevel;
  } else {
    gasLevel = void 0;
  }
  return {
    nonce,
    gasPrice,
    gasLimit,
    from,
    to,
    value,
    data,
    type,
    chainId,
    maxPriorityFeePerGas,
    maxFeePerGas,
    action,
    gasLevel
  };
}
function isEVMAddress(address) {
  return address && address.length === 42 && address.startsWith("0x");
}
function isTron(chain) {
  return chain.name.toLowerCase() === "tron";
}

// src/utils/evmSendTransaction.ts
var evmSendTransaction = async (transaction) => {
  const chainId = Number(transaction.chainId || particleAuth3.ethereum.chainId);
  const txData = {
    ...transaction,
    from: particleAuth3.ethereum.selectedAddress,
    chainId
  };
  const chain = chains2.getEVMChainInfoById(chainId);
  if (isNullish3(txData.data)) {
    txData.data = "0x";
  }
  const evmTx = parseTransaction(txData, chain);
  if (!evmTx.gasLimit) {
    evmTx.gasLimit = await fetchEstimateGas(
      { from: evmTx.from, to: evmTx.to, value: evmTx.value, data: evmTx.data },
      chainId
    );
  }
  if (Number(evmTx.type) === 2) {
    if (!evmTx.maxPriorityFeePerGas || !evmTx.maxFeePerGas) {
      const gasFee = await fetchSuggestedGasFee(chainId);
      evmTx.maxFeePerGas = bnToHex(toWei(gasFee[GasFeeMode.medium].maxFeePerGas, "gwei"));
      evmTx.maxPriorityFeePerGas = bnToHex(toWei(gasFee[GasFeeMode.medium].maxPriorityFeePerGas, "gwei"));
    }
  } else {
    if (!evmTx.gasPrice) {
      const gasFee = await fetchSuggestedGasFee(chainId);
      evmTx.gasPrice = bnToHex(toWei(gasFee[GasFeeMode.medium].maxFeePerGas, "gwei"));
    }
  }
  const result = await particleAuth3.ethereum.sendTransaction(evmTx);
  return result;
};
var fetchEstimateGas = async (param, chainId) => {
  if (!param.to || param.to.length === 0) {
    delete param.to;
  }
  const result = await particleAuth3.ethereum.request({
    chainId,
    method: "eth_estimateGas",
    params: [param]
  });
  return result;
};
var fetchSuggestedGasFee = async (chainId) => {
  const result = await particleAuth3.ethereum.request({
    chainId,
    method: EvmEnhancedMethod.suggestedGasFees
  });
  return result;
};
var evmSendTransaction_default = evmSendTransaction;

// src/context/evmProvider.ts
import { addHexPrefix, isHexString as isHexString3 } from "@ethereumjs/util";
import { providerErrors, rpcErrors } from "@metamask/rpc-errors";
import {
  EvmRpcMethod,
  ethereumUtils,
  isNullish as isNullish4,
  requireNotNullish as requireNotNullish2
} from "@particle-network/auth-core";
import { chains as chains3 } from "@particle-network/chains";
var _checkConnected, checkConnected_fn;
var EVMProvider = class {
  constructor() {
    __privateAdd(this, _checkConnected);
    this.signMessage = async (message, uniq) => {
      throw new Error("signMessage not implemented.");
    };
    this.sendTransaction = async (transaction) => {
      throw new Error("sendTransaction not implemented.");
    };
    this.signTypedData = async ({
      data,
      version,
      uniq
    }) => {
      throw new Error("signTypedData not implemented.");
    };
  }
  get selectedAddress() {
    return requireNotNullish2(window.particleAuth).ethereum.selectedAddress;
  }
  get chainId() {
    return requireNotNullish2(window.particleAuth).ethereum.chainId;
  }
  isConnected() {
    return requireNotNullish2(window.particleAuth).ethereum.isConnected();
  }
  on(event, listener) {
    var _a;
    (_a = window.particleAuth) == null ? void 0 : _a.ethereum.on(event, listener);
    return this;
  }
  once(event, listener) {
    var _a;
    (_a = window.particleAuth) == null ? void 0 : _a.ethereum.once(event, listener);
    return this;
  }
  off(event, listener) {
    var _a;
    (_a = window.particleAuth) == null ? void 0 : _a.ethereum.off(event, listener);
    return this;
  }
  removeListener(event, listener) {
    var _a;
    (_a = window.particleAuth) == null ? void 0 : _a.ethereum.removeListener(event, listener);
    return this;
  }
  async enable() {
    return await requireNotNullish2(window.particleAuth).ethereum.enable();
  }
  async disconnect() {
    return await requireNotNullish2(window.particleAuth).ethereum.disconnect();
  }
  async request(data) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const method = data.method;
    if (!method) {
      throw rpcErrors.invalidParams("Invalid parameters: method is required.");
    }
    if (Object.values(EvmRpcMethod).includes(method)) {
      if (method === EvmRpcMethod.ethAccounts || method === EvmRpcMethod.ethRequestAccounts) {
        return await requireNotNullish2(window.particleAuth).ethereum.request(data);
      } else if (method === EvmRpcMethod.ethChainId) {
        return this.chainId;
      } else if (method.startsWith(EvmRpcMethod.ethSignTypedData)) {
        __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
        const isV1 = ethereumUtils.isSignTypedDataV1(method);
        const from = isV1 ? (_a = data == null ? void 0 : data.params) == null ? void 0 : _a[1] : (_b = data == null ? void 0 : data.params) == null ? void 0 : _b[0];
        let typedData = isV1 ? (_c = data == null ? void 0 : data.params) == null ? void 0 : _c[0] : (_d = data == null ? void 0 : data.params) == null ? void 0 : _d[1];
        if (!from || typeof from !== "string") {
          throw rpcErrors.invalidParams("Invalid parameters: must provide an Ethereum address.");
        }
        if (!typedData) {
          throw rpcErrors.invalidParams("Invalid parameters: must provide typed data.");
        }
        if (from.toLowerCase() !== ((_e = this.selectedAddress) == null ? void 0 : _e.toLowerCase())) {
          throw providerErrors.unauthorized();
        }
        if (typeof typedData === "string") {
          typedData = JSON.parse(typedData);
        }
        const uniq = ethereumUtils.isUniq(method);
        const version = ethereumUtils.getSignTypedVersion(method);
        const result = await this.signTypedData({
          data: typedData,
          version,
          uniq
        });
        return result;
      } else if (method.startsWith(EvmRpcMethod.personalSign)) {
        __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
        let message = (_f = data == null ? void 0 : data.params) == null ? void 0 : _f[0];
        const from = (_g = data == null ? void 0 : data.params) == null ? void 0 : _g[1];
        if (!message || typeof message !== "string") {
          throw rpcErrors.invalidParams("Invalid parameters: must provide a valid message.");
        }
        if (!from || typeof from !== "string") {
          throw rpcErrors.invalidParams("Invalid parameters: must provide an Ethereum address.");
        }
        if (from.toLowerCase() !== ((_h = this.selectedAddress) == null ? void 0 : _h.toLowerCase())) {
          throw providerErrors.unauthorized();
        }
        if (!isHexString3(message)) {
          message = addHexPrefix(Buffer.from(message).toString("hex"));
        }
        const uniq = ethereumUtils.isUniq(method);
        const result = await this.signMessage(message, uniq);
        return result;
      } else if (method === EvmRpcMethod.walletSwitchEthereumChain) {
        return await requireNotNullish2(window.particleAuth).ethereum.request(data);
      } else if (method === EvmRpcMethod.ethSendTransaction) {
        __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
        const chainId = Number(data.chainId || this.chainId);
        const chain = chains3.getEVMChainInfoById(chainId);
        if (!chain) {
          throw providerErrors.chainDisconnected();
        }
        const txData = (_i = data.params) == null ? void 0 : _i[0];
        if (!txData) {
          throw rpcErrors.invalidParams("Invalid parameters: must provide an transaction data.");
        }
        if (isNullish4(txData.type)) {
          if (chains3.isChainSupportEIP1559(chain)) {
            txData.type = "0x2";
          } else {
            txData.type = "0x0";
          }
        }
        if (isNullish4(txData.chainId)) {
          txData.chainId = `0x${chainId.toString(16)}`;
        }
        if (isNullish4(txData.nonce)) {
          txData.nonce = "0x0";
        }
        if (isNullish4(txData.data)) {
          txData.data = "0x";
        }
        const result = await this.sendTransaction(txData);
        return result;
      } else {
        throw providerErrors.unsupportedMethod();
      }
    } else {
      return await requireNotNullish2(window.particleAuth).ethereum.request(data);
    }
  }
};
_checkConnected = new WeakSet();
checkConnected_fn = function() {
  if (!this.isConnected()) {
    throw providerErrors.unauthorized();
  }
};

// src/context/hooks/useEthereum.ts
var useEthereum = () => {
  var _a;
  const navigate = useCustomNavigate();
  const { events } = useEvents();
  const [chainId, setChainId] = useState2(Number(particleAuth4.ethereum.chainId));
  const [chainInfo, setChainInfo] = useState2(requireNotNullish3(getEvmChain(chainId)));
  const [address, setAddress] = useState2(particleAuth4.ethereum.selectedAddress);
  const { userInfo } = useUserInfo();
  const { needRestoreWallet } = useAuthCore();
  const { modalOptions } = useModalOptions();
  const { setAuthCoreModal } = useParticleAuth();
  const { connect: connect2 } = useConnect();
  const silentApprove = useMemo2(() => {
    var _a2;
    if (needRestoreWallet || (userInfo == null ? void 0 : userInfo.security_account.has_set_payment_password) || ((_a2 = modalOptions.promptSettingConfig) == null ? void 0 : _a2.promptPaymentPasswordSettingWhenSign) || getLatestAuthType() !== AuthType2.jwt) {
      return false;
    }
    return true;
  }, [
    userInfo == null ? void 0 : userInfo.security_account.has_set_payment_password,
    needRestoreWallet,
    (_a = modalOptions.promptSettingConfig) == null ? void 0 : _a.promptPaymentPasswordSettingWhenSign
  ]);
  useEffect3(() => {
    const onChainChanged = (chainId2) => {
      setChainId(Number(chainId2));
    };
    particleAuth4.ethereum.on("chainChanged", onChainChanged);
    const onConnect = () => {
      setAddress(particleAuth4.ethereum.selectedAddress);
    };
    particleAuth4.ethereum.on("connect", onConnect);
    const onAccountsChanged = (accounts) => {
      if (accounts[0]) {
        setAddress(accounts[0]);
      }
    };
    particleAuth4.ethereum.on("accountsChanged", onAccountsChanged);
    const onDisconnect = () => {
      setAddress(null);
    };
    particleAuth4.ethereum.on("disconnect", onDisconnect);
    const onRequestAccount = ({ resolve, reject }) => {
      connect2().then((userInfo2) => {
        resolve(userInfo2);
      }).catch((error) => {
        reject(error);
      });
    };
    particleAuth4.on(AuthCoreEvent3.RequestEthereumAccount, onRequestAccount);
    return () => {
      particleAuth4.ethereum.off("chainChanged", onChainChanged);
      particleAuth4.ethereum.off("connect", onConnect);
      particleAuth4.ethereum.off("accountsChanged", onAccountsChanged);
      particleAuth4.ethereum.off("disconnect", onDisconnect);
      particleAuth4.off(AuthCoreEvent3.RequestEthereumAccount, onRequestAccount);
    };
  }, [connect2]);
  useEffect3(() => {
    if (chainId) {
      setChainInfo(requireNotNullish3(getEvmChain(chainId)));
    }
  }, [chainId]);
  const checkAuthCoreState = () => {
    check2(particleAuth4, "Please init first!");
    check2(isConnected3(), AuthError.notLogin());
    check2(particleAuth4.ethereum.selectedAddress, "Please create wallet first!");
  };
  const signImpl = useCallback4(
    async (state) => {
      checkAuthCoreState();
      const result = await new Promise((resolve, reject) => {
        if (events.listenerCount("signResponse" /* SignResponse */) > 0) {
          reject(AuthError.pending("sign"));
        } else {
          events.once("signResponse" /* SignResponse */, (response) => {
            if (response.error) {
              reject(response.error);
            } else {
              resolve(response.result);
            }
            setAuthCoreModal({ particleModalVisible: false });
          });
          navigate("evm-chain/sign" /* EvmSign */, {
            replace: true,
            state
          });
        }
      });
      return result;
    },
    [navigate, events]
  );
  const signMessage = useCallback4(
    async (message, uniq) => {
      if (silentApprove) {
        const result = await particleAuth4.ethereum.signMessage(toHexPrefixString(message), uniq);
        return result;
      } else {
        const result = await signImpl({
          param: toHexPrefixString(message),
          method: uniq ? EvmRpcMethod2.personalSignUniq : EvmRpcMethod2.personalSign
        });
        return result;
      }
    },
    [signImpl, silentApprove]
  );
  const signTypedData = useCallback4(
    async ({
      data,
      version,
      uniq
    }) => {
      if (silentApprove) {
        const result = await particleAuth4.ethereum.signTypedData({ data, version, uniq });
        return result;
      } else {
        const result = await signImpl({
          param: data,
          method: getSignTypedDataMethod({ version, uniq })
        });
        return result;
      }
    },
    [signImpl, silentApprove]
  );
  const sendTransaction = useCallback4(
    async (transaction) => {
      if (transaction.chainId && !chains4.getEVMChainInfoById(Number(transaction.chainId))) {
        throw new Error(`The chainId: ${transaction.chainId} is not supported.`);
      }
      if (silentApprove) {
        const result = await evmSendTransaction_default(transaction);
        return result;
      } else {
        const result = await signImpl({
          param: { ...transaction, from: address, chainId: transaction.chainId || chainId },
          method: EvmRpcMethod2.ethSendTransaction
        });
        return result;
      }
    },
    [address, chainId, signImpl, silentApprove]
  );
  const switchChain = useCallback4(async (id) => {
    await requireNotNullish3(particleAuth4, "Please init first!").ethereum.switchChain(id);
  }, []);
  const enable = useCallback4(async () => {
    const result = await requireNotNullish3(particleAuth4, "Please init first!").ethereum.enable();
    return result[0];
  }, []);
  const provider = useMemo2(() => {
    const eip1193Provider = new EVMProvider();
    eip1193Provider.signMessage = signMessage;
    eip1193Provider.signTypedData = signTypedData;
    eip1193Provider.sendTransaction = sendTransaction;
    return eip1193Provider;
  }, []);
  useEffect3(() => {
    if (provider) {
      provider.signMessage = signMessage;
      provider.signTypedData = signTypedData;
      provider.sendTransaction = sendTransaction;
    }
  }, [provider, signMessage, signTypedData, sendTransaction]);
  return {
    provider,
    address,
    chainId,
    chainInfo,
    switchChain,
    signMessage,
    signTypedData,
    sendTransaction,
    enable
  };
};
function getSignTypedDataMethod({ version, uniq }) {
  if (SignTypedDataVersion.V1 === version) {
    return EvmRpcMethod2.ethSignTypedDataV1;
  } else if (SignTypedDataVersion.V3 === version) {
    return EvmRpcMethod2.ethSignTypedDataV3;
  } else {
    return uniq ? EvmRpcMethod2.ethSignTypedDataV4Uniq : EvmRpcMethod2.ethSignTypedDataV4;
  }
}

// src/context/hooks/useIsMounted.ts
import { useEffect as useEffect4, useReducer } from "react";
var useIsMounted = () => {
  const [mounted, setMounted] = useReducer(() => true, false);
  useEffect4(setMounted, [setMounted]);
  return mounted;
};

// src/context/hooks/useSolana.ts
import {
  AuthCoreEvent as AuthCoreEvent4,
  AuthType as AuthType3,
  SolanaRpcMethod,
  check as check3,
  getLatestAuthType as getLatestAuthType2,
  isConnected as isConnected4,
  particleAuth as particleAuth5,
  requireNotNullish as requireNotNullish4
} from "@particle-network/auth-core";
import { chains as chains5 } from "@particle-network/chains";
import { useCallback as useCallback5, useEffect as useEffect5, useMemo as useMemo3, useState as useState3 } from "react";

// src/context/solanaWallet.ts
var SolanaWallet = class {
  constructor() {
    this.isParticleNetwork = true;
    this.name = "Particle";
    this.url = "https://particle.network";
    this.icon = "https://static.particle.network/wallet-icons/Particle.png";
    this.signTransaction = async (transaction, chainId) => {
      throw new Error("signMessage not implemented.");
    };
    this.signAllTransactions = async (transactions, chainId) => {
      throw new Error("signMessage not implemented.");
    };
    this.signAndSendTransaction = async (transaction, chainId) => {
      throw new Error("signMessage not implemented.");
    };
    this.signMessage = async (message) => {
      throw new Error("signMessage not implemented.");
    };
    this.switchChain = async (chainId) => {
      var _a;
      await ((_a = window.particleAuth) == null ? void 0 : _a.solana.switchChain(chainId));
    };
  }
  on(event, listener) {
    var _a;
    (_a = window.particleAuth) == null ? void 0 : _a.solana.on(event, listener);
    return this;
  }
  once(event, listener) {
    var _a;
    (_a = window.particleAuth) == null ? void 0 : _a.solana.once(event, listener);
    return this;
  }
  off(event, listener) {
    var _a;
    (_a = window.particleAuth) == null ? void 0 : _a.solana.off(event, listener);
    return this;
  }
  removeListener(event, listener) {
    var _a;
    (_a = window.particleAuth) == null ? void 0 : _a.solana.removeListener(event, listener);
    return this;
  }
  get connecting() {
    var _a, _b;
    return (_b = (_a = window.particleAuth) == null ? void 0 : _a.solana.connecting) != null ? _b : false;
  }
  get connected() {
    var _a, _b;
    return (_b = (_a = window.particleAuth) == null ? void 0 : _a.solana.connected) != null ? _b : false;
  }
  async publicKey() {
    var _a;
    return (_a = window.particleAuth) == null ? void 0 : _a.solana.publicKey();
  }
  get selectedAddress() {
    var _a, _b;
    return (_b = (_a = window.particleAuth) == null ? void 0 : _a.solana.selectedAddress) != null ? _b : null;
  }
  get chainId() {
    var _a, _b;
    return (_b = (_a = window.particleAuth) == null ? void 0 : _a.solana.chainId) != null ? _b : 101;
  }
  async connect() {
    var _a;
    await ((_a = window.particleAuth) == null ? void 0 : _a.solana.connect());
  }
  async disconnect() {
    var _a;
    await ((_a = window.particleAuth) == null ? void 0 : _a.solana.disconnect());
  }
  async request(data) {
    var _a;
    return (_a = window.particleAuth) == null ? void 0 : _a.solana.request(data);
  }
};

// src/context/hooks/useSolana.ts
var useSolana = () => {
  var _a;
  const navigate = useCustomNavigate();
  const { events } = useEvents();
  const [chainId, setChainId] = useState3(particleAuth5.solana.chainId);
  const [chainInfo, setChainInfo] = useState3(
    requireNotNullish4(getSolanaChain(particleAuth5.solana.chainId))
  );
  const [address, setAddress] = useState3(particleAuth5.solana.selectedAddress);
  const { setAuthCoreModal } = useParticleAuth();
  const { connect: connect2 } = useConnect();
  const { userInfo } = useUserInfo();
  const { needRestoreWallet } = useAuthCore();
  const { modalOptions } = useModalOptions();
  const silentApprove = useMemo3(() => {
    var _a2;
    if (needRestoreWallet || (userInfo == null ? void 0 : userInfo.security_account.has_set_payment_password) || ((_a2 = modalOptions.promptSettingConfig) == null ? void 0 : _a2.promptPaymentPasswordSettingWhenSign) || getLatestAuthType2() !== AuthType3.jwt) {
      return false;
    }
    return true;
  }, [
    userInfo == null ? void 0 : userInfo.security_account.has_set_payment_password,
    needRestoreWallet,
    (_a = modalOptions.promptSettingConfig) == null ? void 0 : _a.promptPaymentPasswordSettingWhenSign
  ]);
  useEffect5(() => {
    var _a2;
    const onChainChanged = (chainId2) => {
      setChainId(chainId2);
    };
    particleAuth5.solana.on("chainChanged", onChainChanged);
    const onConnect = () => {
      setAddress(particleAuth5.solana.selectedAddress);
    };
    particleAuth5.solana.on("connect", onConnect);
    setChainId((_a2 = particleAuth5.solana.chainId) != null ? _a2 : 101);
    const onDisconnect = () => {
      setAddress(null);
    };
    particleAuth5.solana.on("disconnect", onDisconnect);
    const onRequestAccount = ({ resolve, reject }) => {
      connect2().then((userInfo2) => {
        resolve(userInfo2);
      }).catch((error) => {
        reject(error);
      });
    };
    particleAuth5.on(AuthCoreEvent4.RequestSolanaAccount, onRequestAccount);
    return () => {
      particleAuth5.solana.off("chainChanged", onChainChanged);
      particleAuth5.solana.off("connect", onConnect);
      particleAuth5.solana.off("disconnect", onDisconnect);
      particleAuth5.off(AuthCoreEvent4.RequestSolanaAccount, onRequestAccount);
    };
  }, [connect2]);
  useEffect5(() => {
    if (chainId) {
      setChainInfo(requireNotNullish4(getSolanaChain(chainId)));
    }
  }, [chainId]);
  const checkAuthCoreState = () => {
    check3(particleAuth5, "Please init first!");
    check3(isConnected4(), AuthError.notLogin());
    check3(particleAuth5.solana.selectedAddress, "Please create wallet first!");
  };
  const signImpl = useCallback5(
    async (state) => {
      checkAuthCoreState();
      const result = await new Promise((resolve, reject) => {
        if (events.listenerCount("signResponse" /* SignResponse */) > 0) {
          reject(AuthError.pending("sign"));
        } else {
          events.once("signResponse" /* SignResponse */, (response) => {
            if (response.error) {
              reject(response.error);
            } else {
              resolve(response.result);
            }
            setAuthCoreModal({ particleModalVisible: false });
          });
          navigate("solana/sign" /* SolanaSign */, {
            replace: true,
            state
          });
        }
      });
      return result;
    },
    [navigate]
  );
  const signMessage = useCallback5(
    async (message) => {
      if (silentApprove) {
        const signature = await particleAuth5.solana.signMessage(message);
        return signature;
      } else {
        const signature = await signImpl({
          param: message,
          method: SolanaRpcMethod.signMessage
        });
        return signature;
      }
    },
    [signImpl, silentApprove]
  );
  const signTransaction = useCallback5(
    async (transaction, chainId2) => {
      check3(!chainId2 || chains5.getSolanaChainInfoById(chainId2), `The chainId: ${chainId2} is not supported`);
      if (silentApprove) {
        const signature = await particleAuth5.solana.signTransaction(transaction, chainId2);
        return signature;
      } else {
        const signature = await signImpl({
          param: transaction,
          method: SolanaRpcMethod.signTransaction,
          chainId: chainId2
        });
        return signature;
      }
    },
    [signImpl, silentApprove]
  );
  const signAllTransactions = useCallback5(
    async (transactions, chainId2) => {
      check3(!chainId2 || chains5.getSolanaChainInfoById(chainId2), `The chainId: ${chainId2} is not supported`);
      if (silentApprove) {
        const signature = await particleAuth5.solana.signAllTransactions(transactions, chainId2);
        return signature;
      } else {
        const signature = await signImpl({
          param: transactions,
          method: SolanaRpcMethod.signAllTransactions,
          chainId: chainId2
        });
        return signature;
      }
    },
    [signImpl, silentApprove]
  );
  const signAndSendTransaction = useCallback5(
    async (transaction, chainId2) => {
      check3(!chainId2 || chains5.getSolanaChainInfoById(chainId2), `The chainId: ${chainId2} is not supported`);
      if (silentApprove) {
        const signature = await particleAuth5.solana.signAndSendTransaction(transaction, chainId2);
        return signature;
      } else {
        const signature = await signImpl({
          param: transaction,
          method: SolanaRpcMethod.signAndSendTransaction,
          chainId: chainId2
        });
        return signature;
      }
    },
    [signImpl, silentApprove]
  );
  const switchChain = useCallback5(async (id) => {
    await requireNotNullish4(particleAuth5, "Please init first!").solana.switchChain(id);
  }, []);
  const enable = useCallback5(async () => {
    await requireNotNullish4(particleAuth5, "Please init first!").solana.connect();
    return requireNotNullish4(particleAuth5.solana.selectedAddress);
  }, []);
  const wallet = useMemo3(() => {
    const solanaWallet = new SolanaWallet();
    solanaWallet.signMessage = signMessage;
    solanaWallet.signTransaction = signTransaction;
    solanaWallet.signAllTransactions = signAllTransactions;
    solanaWallet.signAndSendTransaction = signAndSendTransaction;
    return solanaWallet;
  }, []);
  useEffect5(() => {
    if (wallet) {
      wallet.signMessage = signMessage;
      wallet.signTransaction = signTransaction;
      wallet.signAllTransactions = signAllTransactions;
      wallet.signAndSendTransaction = signAndSendTransaction;
    }
  }, [wallet, signMessage, signTransaction, signAllTransactions, signAndSendTransaction]);
  return {
    address,
    chainId,
    chainInfo,
    switchChain,
    signMessage,
    signTransaction,
    signAllTransactions,
    signAndSendTransaction,
    enable,
    wallet
  };
};

export {
  useAuthCore,
  save,
  load,
  PreferenceKey,
  useLogin_default,
  useConnect,
  useCustomize,
  formatTokenAmount,
  toWeiBigNumber,
  toBigNumber,
  toWei,
  fromWei,
  fromWeiFormat,
  formatPrice,
  trimDecimals,
  fromSunFormat,
  formatTokenAmount2,
  isEIP1559Type,
  parseTransaction,
  isEVMAddress,
  isTron,
  useUserInfo,
  useEthereum,
  useIsMounted,
  useSolana
};
//# sourceMappingURL=chunk-HMIJ6G3W.js.map
