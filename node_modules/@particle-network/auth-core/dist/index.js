"use client";
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ApiError: () => ApiError,
  AuthCoreEvent: () => AuthCoreEvent,
  AuthType: () => AuthType,
  EvmEnhancedMethod: () => EvmEnhancedMethod,
  EvmRpcMethod: () => EvmRpcMethod,
  GasFeeMode: () => GasFeeMode,
  IframeEvent: () => IframeEvent,
  SignTypedDataVersion: () => SignTypedDataVersion,
  SolanaEnhancedMethod: () => SolanaEnhancedMethod,
  SolanaRpcMethod: () => SolanaRpcMethod,
  TransactionSmartType: () => TransactionSmartType,
  WalletEncryptedType: () => WalletEncryptedType,
  WalletType: () => WalletType,
  analyticsActive: () => analyticsActive,
  analyticsRecord: () => analyticsRecord,
  bindLoginAccount: () => bindLoginAccount,
  bindSecurityAccount: () => bindSecurityAccount,
  check: () => check,
  checkHasBoundLoginPhoneOrEmail: () => checkHasBoundLoginPhoneOrEmail,
  connect: () => connect,
  deleteAuthorizationDApp: () => deleteAuthorizationDApp,
  deletePaymentPassword: () => deletePaymentPassword,
  disconnect: () => disconnect,
  ethereumUtils: () => ethereumUtils,
  getAuthorizationDApps: () => getAuthorizationDApps,
  getBindSecurityAccounCaptcha: () => getBindSecurityAccounCaptcha,
  getCloudflareTurnstileResponse: () => getCloudflareTurnstileResponse,
  getConnectCaptcha: () => getConnectCaptcha,
  getLatestAuthType: () => getLatestAuthType,
  getLoginBindAccounts: () => getLoginBindAccounts,
  getSecurityAccount: () => getSecurityAccount,
  getSecurityAccountCaptcha: () => getSecurityAccountCaptcha,
  getSecurityAccountToken: () => getSecurityAccountToken,
  getSmartAccountAddress: () => getSmartAccountAddress,
  getUserInfo: () => getUserInfo,
  hasMasterPassword: () => hasMasterPassword,
  hasPaymentPassword: () => hasPaymentPassword,
  isApiError: () => isApiError,
  isConnected: () => isConnected,
  isNeedRestoreWallet: () => isNeedRestoreWallet,
  isNullish: () => isNullish,
  isRpcError: () => isRpcError,
  isSocialAuthType: () => isSocialAuthType,
  isTron: () => isTron,
  mapToUserInfo: () => mapToUserInfo,
  particleAuth: () => particleAuth,
  requireNotNullish: () => requireNotNullish,
  restoreWallet: () => restoreWallet,
  setMastersPassword: () => setMastersPassword,
  setPaymentPassword: () => setPaymentPassword,
  syncUserInfo: () => syncUserInfo,
  thirdpartyAuth: () => thirdpartyAuth,
  tronAddressFromHex: () => fromHex,
  tronAddressToHex: () => toHex,
  updatePaymentPassword: () => updatePaymentPassword,
  verifyMasterPassword: () => verifyMasterPassword,
  verifyPaymentPassword: () => verifyPaymentPassword
});
module.exports = __toCommonJS(src_exports);

// src/api/apiError.ts
var ApiError = /* @__PURE__ */ ((ApiError2) => {
  ApiError2[ApiError2["SystemError"] = 10001] = "SystemError";
  ApiError2[ApiError2["ParamError"] = 10002] = "ParamError";
  ApiError2[ApiError2["AuthorizationError"] = 10004] = "AuthorizationError";
  ApiError2[ApiError2["InvalidToken"] = 10005] = "InvalidToken";
  ApiError2[ApiError2["MacError"] = 10009] = "MacError";
  ApiError2[ApiError2["InvalidCode"] = 20101] = "InvalidCode";
  ApiError2[ApiError2["ResendCode"] = 20103] = "ResendCode";
  ApiError2[ApiError2["SecurityAccountFrozen"] = 50010] = "SecurityAccountFrozen";
  ApiError2[ApiError2["WrongPaymentPassword"] = 50102] = "WrongPaymentPassword";
  return ApiError2;
})(ApiError || {});
function isApiError(err) {
  return err && err.message && typeof err.error_code === "number" && err.error_code > 0;
}
function isRpcError(err) {
  return err && err.message && typeof err.code === "number";
}

// src/api/authType.ts
var AuthType = /* @__PURE__ */ ((AuthType2) => {
  AuthType2["email"] = "email";
  AuthType2["phone"] = "phone";
  AuthType2["facebook"] = "facebook";
  AuthType2["google"] = "google";
  AuthType2["apple"] = "apple";
  AuthType2["twitter"] = "twitter";
  AuthType2["discord"] = "discord";
  AuthType2["github"] = "github";
  AuthType2["twitch"] = "twitch";
  AuthType2["microsoft"] = "microsoft";
  AuthType2["linkedin"] = "linkedin";
  AuthType2["jwt"] = "jwt";
  return AuthType2;
})(AuthType || {});
var isSocialAuthType = (authType) => {
  return [
    "facebook" /* facebook */,
    "google" /* google */,
    "apple" /* apple */,
    "twitter" /* twitter */,
    "discord" /* discord */,
    "github" /* github */,
    "twitch" /* twitch */,
    "microsoft" /* microsoft */,
    "linkedin" /* linkedin */
  ].includes(authType);
};

// src/api/types/apiData.ts
var WalletEncryptedType = /* @__PURE__ */ ((WalletEncryptedType2) => {
  WalletEncryptedType2[WalletEncryptedType2["KMS_AES"] = 0] = "KMS_AES";
  WalletEncryptedType2[WalletEncryptedType2["KMS_AES_WITH_DATA_KEY_AND_DEFAULT_MASTER_PASSWORD"] = 1] = "KMS_AES_WITH_DATA_KEY_AND_DEFAULT_MASTER_PASSWORD";
  WalletEncryptedType2[WalletEncryptedType2["KMS_AES_WITH_DATA_KEY_AND_MASTER_PASSWORD"] = 2] = "KMS_AES_WITH_DATA_KEY_AND_MASTER_PASSWORD";
  return WalletEncryptedType2;
})(WalletEncryptedType || {});

// src/api/types/rpcData.ts
var SolanaEnhancedMethod = /* @__PURE__ */ ((SolanaEnhancedMethod2) => {
  SolanaEnhancedMethod2["enhancedDeserializeTransaction"] = "enhancedDeserializeTransaction";
  return SolanaEnhancedMethod2;
})(SolanaEnhancedMethod || {});
var EvmEnhancedMethod = /* @__PURE__ */ ((EvmEnhancedMethod2) => {
  EvmEnhancedMethod2["deserializeTransaction"] = "particle_deserializeTransaction";
  EvmEnhancedMethod2["deserializeTypedData"] = "particle_deserializeTypedData";
  EvmEnhancedMethod2["suggestedGasFees"] = "particle_suggestedGasFees";
  EvmEnhancedMethod2["getPrice"] = "particle_getPrice";
  EvmEnhancedMethod2["getPendingTransactionsByAddress"] = "particle_getPendingTransactionsByAddress";
  return EvmEnhancedMethod2;
})(EvmEnhancedMethod || {});
var TransactionSmartType = /* @__PURE__ */ ((TransactionSmartType2) => {
  TransactionSmartType2["NativeTransfer"] = "native_transfer";
  TransactionSmartType2["ERC20_TRANSFER"] = "erc20_transfer";
  TransactionSmartType2["ERC20_APPROVE"] = "erc20_approve";
  TransactionSmartType2["ERC721_TRANFER"] = "erc721_transfer";
  TransactionSmartType2["ERC1155_TRANFER"] = "erc1155_transfer";
  TransactionSmartType2["SEAPORT_FULFILL_ORDER"] = "seaport_fulfill_order";
  TransactionSmartType2["SEAPORT_CANCEL_ORDER"] = "seaport_cancel_order";
  TransactionSmartType2["SEAPORT_NFT_LISTING"] = "seaport_nft_listing";
  TransactionSmartType2["OTHER"] = "other";
  return TransactionSmartType2;
})(TransactionSmartType || {});
var GasFeeMode = /* @__PURE__ */ ((GasFeeMode2) => {
  GasFeeMode2["custom"] = "custom";
  GasFeeMode2["low"] = "low";
  GasFeeMode2["medium"] = "medium";
  GasFeeMode2["high"] = "high";
  return GasFeeMode2;
})(GasFeeMode || {});

// src/api/types/index.ts
var mapToUserInfo = (originalUserInfo) => {
  const { mac_key, cognito_result, wallets, ...userInfo } = originalUserInfo;
  return {
    ...userInfo,
    wallets: wallets.map((wallet2) => {
      const { uuid: uuid5, chain_name, public_address } = wallet2;
      return { uuid: uuid5, chain_name, public_address };
    })
  };
};

// src/core/analyticsApi.ts
var import_analytics = require("@particle-network/analytics");

// src/config/index.ts
var import_uuid = require("uuid");

// src/storage/encryptedStorage.ts
var import_aes = __toESM(require("crypto-js/aes.js"), 1);
var import_enc_utf8 = __toESM(require("crypto-js/enc-utf8.js"), 1);
var import_md5 = __toESM(require("crypto-js/md5.js"), 1);

// src/utils/index.ts
var isServer = () => typeof window === "undefined";

// src/utils/validate.ts
var check = (condition, throwError) => {
  if (!condition) {
    if (throwError) {
      if (typeof throwError === "string") {
        throw new Error(throwError);
      }
      throw throwError;
    } else {
      throw new Error("Required conditions not met");
    }
  }
};
var requireNotNullish = (x, throwError) => {
  if (x !== void 0 && x !== null) {
    return x;
  }
  if (throwError) {
    if (typeof throwError === "string") {
      throw new Error(throwError);
    } else {
      throw throwError;
    }
  }
  throw new Error("Param is null or undefined");
};
function isNullish(x) {
  return x === void 0 || x === null;
}

// src/storage/encryptedStorage.ts
var _KEY_PREFIX, _appId, _secretKey, _wrapKey, wrapKey_fn, _encrypt, encrypt_fn, _decrypt, decrypt_fn;
var EncryptedStorage = class {
  constructor() {
    __privateAdd(this, _wrapKey);
    __privateAdd(this, _encrypt);
    __privateAdd(this, _decrypt);
    __privateAdd(this, _KEY_PREFIX, "particle-auth-core/");
    __privateAdd(this, _appId, "");
    __privateAdd(this, _secretKey, "");
  }
  init(appId) {
    __privateSet(this, _appId, appId);
    let hostname = "particle.network";
    if (typeof window !== "undefined") {
      hostname = window.location.origin;
    }
    __privateSet(this, _secretKey, (0, import_md5.default)(`${hostname}/${__privateGet(this, _appId)}`).toString().toLowerCase());
  }
  clear() {
    const removeKeys = [];
    const length = localStorage.length;
    for (let i = 0; i < length; i++) {
      const key = localStorage.key(i);
      if (key == null ? void 0 : key.startsWith(__privateGet(this, _KEY_PREFIX))) {
        removeKeys.push(key);
      }
    }
    removeKeys.forEach((key) => localStorage.removeItem(key));
  }
  getItem(key) {
    if (typeof window === "undefined") {
      return null;
    }
    const value = localStorage.getItem(this.getStorageKey(key));
    if (value != null && value.length > 0) {
      return __privateMethod(this, _decrypt, decrypt_fn).call(this, value);
    }
    return value;
  }
  removeItem(key) {
    localStorage.removeItem(this.getStorageKey(key));
  }
  setItem(key, value) {
    if (isServer()) {
      return;
    }
    let cipherValue = value;
    if (value.length > 0) {
      cipherValue = __privateMethod(this, _encrypt, encrypt_fn).call(this, value);
    }
    localStorage.setItem(this.getStorageKey(key), cipherValue);
  }
  getStorageKey(key) {
    return __privateGet(this, _KEY_PREFIX) + __privateMethod(this, _wrapKey, wrapKey_fn).call(this, key);
  }
};
_KEY_PREFIX = new WeakMap();
_appId = new WeakMap();
_secretKey = new WeakMap();
_wrapKey = new WeakSet();
wrapKey_fn = function(key) {
  check(__privateGet(this, _appId), "please init AuthCore first!");
  return (0, import_md5.default)(`${__privateGet(this, _appId)}/${key}`).toString().toLowerCase();
};
_encrypt = new WeakSet();
encrypt_fn = function(plaintext) {
  check(__privateGet(this, _secretKey), "please init AuthCore first!");
  const ciphertext = import_aes.default.encrypt(plaintext, __privateGet(this, _secretKey)).toString();
  return ciphertext;
};
_decrypt = new WeakSet();
decrypt_fn = function(ciphertext) {
  check(__privateGet(this, _secretKey), "please init AuthCore first!");
  const bytes = import_aes.default.decrypt(ciphertext, __privateGet(this, _secretKey));
  const plaintext = bytes.toString(import_enc_utf8.default);
  return plaintext;
};
var encryptedStorage = new EncryptedStorage();
var encryptedStorage_default = encryptedStorage;

// src/types/authCoreEvent.ts
var AuthCoreEvent = /* @__PURE__ */ ((AuthCoreEvent2) => {
  AuthCoreEvent2["RequestEthereumAccount"] = "requestEthereumAccount";
  AuthCoreEvent2["RequestSolanaAccount"] = "requestSolanaAccount";
  AuthCoreEvent2["ParticleAuthConnect"] = "particleAuthConnect";
  AuthCoreEvent2["ParticleAuthDisconnect"] = "particleAuthDisconnect";
  AuthCoreEvent2["UserInfoChanged"] = "userInfoChanged";
  AuthCoreEvent2["MasterPasswordChanged"] = "masterPasswordChanged";
  AuthCoreEvent2["ParticleWalletRestored"] = "particleWalletRestored";
  return AuthCoreEvent2;
})(AuthCoreEvent || {});

// src/types/cloudflare.ts
var IframeEvent = /* @__PURE__ */ ((IframeEvent2) => {
  IframeEvent2["CloudflareToken"] = "particle-auth-core-cloudflareToken";
  return IframeEvent2;
})(IframeEvent || {});

// src/types/rpcMethods.ts
var SolanaRpcMethod = /* @__PURE__ */ ((SolanaRpcMethod2) => {
  SolanaRpcMethod2["signTransaction"] = "signTransaction";
  SolanaRpcMethod2["signAndSendTransaction"] = "signAndSendTransaction";
  SolanaRpcMethod2["signMessage"] = "signMessage";
  SolanaRpcMethod2["signAllTransactions"] = "signAllTransactions";
  return SolanaRpcMethod2;
})(SolanaRpcMethod || {});
var EvmRpcMethod = /* @__PURE__ */ ((EvmRpcMethod2) => {
  EvmRpcMethod2["ethSignTransaction"] = "eth_signTransaction";
  EvmRpcMethod2["ethSign"] = "eth_sign";
  EvmRpcMethod2["walletWatchAsset"] = "wallet_watchAsset";
  EvmRpcMethod2["ethRequestAccounts"] = "eth_requestAccounts";
  EvmRpcMethod2["ethAccounts"] = "eth_accounts";
  EvmRpcMethod2["ethChainId"] = "eth_chainId";
  EvmRpcMethod2["ethSendTransaction"] = "eth_sendTransaction";
  EvmRpcMethod2["ethSignTypedData"] = "eth_signTypedData";
  EvmRpcMethod2["ethSignTypedDataV1"] = "eth_signTypedData_v1";
  EvmRpcMethod2["ethSignTypedDataV3"] = "eth_signTypedData_v3";
  EvmRpcMethod2["ethSignTypedDataV4"] = "eth_signTypedData_v4";
  EvmRpcMethod2["personalSign"] = "personal_sign";
  EvmRpcMethod2["ethSignTypedDataV4Uniq"] = "eth_signTypedData_v4_uniq";
  EvmRpcMethod2["personalSignUniq"] = "personal_sign_uniq";
  EvmRpcMethod2["walletSwitchEthereumChain"] = "wallet_switchEthereumChain";
  EvmRpcMethod2["walletAddEthereumChain"] = "wallet_addEthereumChain";
  return EvmRpcMethod2;
})(EvmRpcMethod || {});

// src/types/wallet.ts
var WalletType = /* @__PURE__ */ ((WalletType2) => {
  WalletType2["EVM"] = "evm_chain";
  WalletType2["Solana"] = "solana";
  return WalletType2;
})(WalletType || {});

// src/types/index.ts
var SignTypedDataVersion = /* @__PURE__ */ ((SignTypedDataVersion2) => {
  SignTypedDataVersion2["V1"] = "V1";
  SignTypedDataVersion2["V3"] = "V3";
  SignTypedDataVersion2["V4"] = "V4";
  return SignTypedDataVersion2;
})(SignTypedDataVersion || {});

// src/utils/eventUtils.ts
var import_events = __toESM(require("events"), 1);
var events = new import_events.default();
events.setMaxListeners(500);
var eventUtils_default = events;

// src/storage/userStorage.ts
var userStorage = {
  setUserInfo(info) {
    const localUserInfo = this.getUserInfo();
    if (info) {
      encryptedStorage_default.setItem("user_info", JSON.stringify(info));
    } else {
      encryptedStorage_default.removeItem("user_info");
    }
    if (JSON.stringify(localUserInfo) !== JSON.stringify(info)) {
      eventUtils_default.emit("userInfoChanged" /* UserInfoChanged */, info ? mapToUserInfo(info) : void 0);
    }
  },
  getUserInfo() {
    const info = encryptedStorage_default.getItem("user_info");
    if (info) {
      return JSON.parse(info);
    }
    return void 0;
  },
  isLogin() {
    return Boolean(this.getUserInfo());
  },
  getUserToken() {
    const info = this.getUserInfo();
    if (info) {
      return info.token;
    }
    return void 0;
  },
  getCognitoResult() {
    const info = this.getUserInfo();
    if (info) {
      return info.cognito_result;
    }
    return void 0;
  },
  getSecurityAccount() {
    const info = this.getUserInfo();
    if (info) {
      return info.security_account;
    }
    return void 0;
  },
  setLatestAuthType(authType) {
    encryptedStorage_default.setItem("latest_auth_type", authType);
  },
  getLatestAuthType() {
    const type = encryptedStorage_default.getItem("latest_auth_type");
    return type;
  },
  updateWallet(info) {
    const userInfo = this.getUserInfo();
    if (userInfo) {
      for (let i = 0; i < userInfo.wallets.length; i++) {
        if (userInfo.wallets[i].uuid === info.uuid) {
          userInfo.wallets[i] = info;
          this.setUserInfo(userInfo);
          break;
        }
      }
    }
  },
  updateCognitoResult(result) {
    const userInfo = this.getUserInfo();
    if (userInfo) {
      userInfo.cognito_result = result;
      this.setUserInfo(userInfo);
    }
  },
  updateSecurityAccount(account) {
    const userInfo = this.getUserInfo();
    if (userInfo) {
      userInfo.security_account = account;
      this.setUserInfo(userInfo);
    }
  },
  hasPaymentPassword() {
    var _a;
    return Boolean((_a = this.getSecurityAccount()) == null ? void 0 : _a.has_set_payment_password);
  },
  hasMasterPassword() {
    var _a;
    return Boolean((_a = this.getSecurityAccount()) == null ? void 0 : _a.has_set_master_password);
  },
  getEVMWallet() {
    const userInfo = this.getUserInfo();
    return userInfo == null ? void 0 : userInfo.wallets.find((wallet2) => wallet2.chain_name === "evm_chain" /* EVM */);
  },
  getSolanaWallet() {
    const userInfo = this.getUserInfo();
    return userInfo == null ? void 0 : userInfo.wallets.find((wallet2) => wallet2.chain_name === "solana" /* Solana */);
  }
};
var userStorage_default = userStorage;

// src/storage/index.ts
var getCurrentEvmChainId = () => {
  return Number(encryptedStorage_default.getItem("evm_chain_id" /* EvmChainId */));
};
var setCurrentEvmChainId = (id) => {
  encryptedStorage_default.setItem("evm_chain_id" /* EvmChainId */, id.toString());
};
var getCurrentSolanaChainId = () => {
  return Number(encryptedStorage_default.getItem("solana_chain_id" /* SolanaChainId */));
};
var setCurrentSolanaChainId = (id) => {
  encryptedStorage_default.setItem("solana_chain_id" /* SolanaChainId */, id.toString());
};

// src/config/index.ts
var _authOptions, _devEnv, _stagingEnv, _productionEnv;
var GlobalConfig = class {
  constructor() {
    __privateAdd(this, _authOptions, void 0);
    this.initialized = false;
    __privateAdd(this, _devEnv, {
      basicUsername: "test_user",
      basicPassword: "test_pass",
      baseUrl: "https://api-debug.particle.network",
      rpcUrl: "https://rpc-debug.particle.network",
      authCore: "https://core-debug.particle.network"
    });
    __privateAdd(this, _stagingEnv, {
      basicUsername: "PcJBtrqq69TDpQtY",
      basicPassword: "oGjPXSgKP9QtmxWQUkrfrUvvmsG62t",
      baseUrl: "https://api.particle.network",
      rpcUrl: "https://rpc.particle.network",
      authCore: "https://core.particle.network"
    });
    __privateAdd(this, _productionEnv, {
      basicUsername: "PcJBtrqq69TDpQtY",
      basicPassword: "oGjPXSgKP9QtmxWQUkrfrUvvmsG62t",
      baseUrl: "https://api.particle.network",
      rpcUrl: "https://rpc.particle.network",
      authCore: "https://core.particle.network"
    });
  }
  init(authOptions) {
    __privateSet(this, _authOptions, authOptions);
    this.initialized = true;
  }
  get authOptions() {
    check(__privateGet(this, _authOptions), "Please init AuthCore first!");
    return __privateGet(this, _authOptions);
  }
  get version() {
    return "web_1.3.4";
  }
  get deviceId() {
    if (typeof window === "undefined") {
      return (0, import_uuid.v4)();
    } else {
      const storeKey = "pn_device_id";
      let deviceId = encryptedStorage_default.getItem(storeKey);
      if (!deviceId) {
        deviceId = (0, import_uuid.v4)();
        encryptedStorage_default.setItem(storeKey, deviceId);
      }
      return deviceId;
    }
  }
  get env() {
    if (!isServer() && window.__PARTICLE_ENVIRONMENT__ === "development") {
      return __privateGet(this, _devEnv);
    } else if (!isServer() && window.__PARTICLE_ENVIRONMENT__ === "staging") {
      return __privateGet(this, _stagingEnv);
    } else {
      return __privateGet(this, _productionEnv);
    }
  }
};
_authOptions = new WeakMap();
_devEnv = new WeakMap();
_stagingEnv = new WeakMap();
_productionEnv = new WeakMap();
var globalConfig = new GlobalConfig();
var config_default = globalConfig;

// src/core/analyticsApi.ts
var getBI = () => {
  try {
    if (!window.__particleAnalytics) {
      window.__particleAnalytics = new import_analytics.BI({
        sdk_api_domain: config_default.env.baseUrl,
        device_id: config_default.deviceId,
        sdk_version: config_default.version,
        project_config: {
          project_uuid: config_default.authOptions.projectId,
          project_key: config_default.authOptions.clientKey,
          project_app_uuid: config_default.authOptions.appId
        }
      });
    }
  } catch (error) {
  }
  return window.__particleAnalytics;
};
var analyticsRecord = (params) => {
  var _a;
  if (!isServer()) {
    (_a = getBI()) == null ? void 0 : _a.records(params);
  }
};
var analyticsActive = (params) => {
  var _a;
  if (!isServer()) {
    (_a = getBI()) == null ? void 0 : _a.active(params);
  }
};

// src/core/ethereumProvider.ts
var import_util3 = require("@ethereumjs/util");
var import_eth_sig_util2 = require("@metamask/eth-sig-util");
var import_rpc_errors = require("@metamask/rpc-errors");
var import_chains3 = require("@particle-network/chains");
var import_events2 = __toESM(require("events"), 1);

// src/api/evmApi.ts
var import_uuid3 = require("uuid");

// src/api/client.ts
var import_axios = __toESM(require("axios"), 1);
var import_sha256 = __toESM(require("crypto-js/sha256.js"), 1);
var import_fast_json_stable_stringify = __toESM(require("fast-json-stable-stringify"), 1);
var import_uuid2 = require("uuid");
var client = import_axios.default.create({
  baseURL: config_default.env.baseUrl,
  timeout: 6e4,
  validateStatus: function(status) {
    return status >= 200 && status <= 500;
  },
  withCredentials: false
});
client.interceptors.request.use((config) => {
  var _a, _b;
  const noneAuth = config.headers && config.headers["Auth-Type"] === "None";
  if (noneAuth) {
    return config;
  }
  let macKey = "";
  const basicAuth = config.headers && config.headers["Auth-Type"] === "Basic";
  if (basicAuth) {
    if (!isChainRpcRequest(config.baseURL)) {
      if (config.baseURL !== config_default.env.baseUrl) {
        config.baseURL = config_default.env.baseUrl;
      }
      const auth = {
        username: config_default.env.basicUsername,
        password: config_default.env.basicPassword
      };
      macKey = (0, import_sha256.default)(auth.username + auth.password).toString().toLowerCase();
      config.auth = auth;
    }
  } else {
    const userInfo = userStorage_default.getUserInfo();
    if (!userInfo) {
      throw new Error("Please connect AuthCore first!");
    }
    const token = userInfo.token;
    macKey = userInfo.mac_key;
    config.headers.Authorization = `Bearer ${token}`;
    if (config.baseURL !== config_default.env.baseUrl) {
      config.baseURL = config_default.env.baseUrl;
    }
  }
  if (!config.params) {
    config.params = {};
  }
  if (isChainRpcRequest(config.baseURL)) {
    config.params = {
      ...config.params,
      chainId: ((_a = config.data) == null ? void 0 : _a.chainId) || 1,
      projectUuid: config_default.authOptions.projectId,
      projectKey: config_default.authOptions.clientKey,
      method: (_b = config.data) == null ? void 0 : _b.method
    };
    delete config.data.chainId;
  } else {
    const timestamp = Math.round(new Date().getTime() / 1e3);
    const randomStr = (0, import_uuid2.v4)();
    config.params = {
      ...config.params,
      timestamp,
      random_str: randomStr,
      device_id: config_default.deviceId,
      sdk_version: config_default.version,
      project_uuid: config_default.authOptions.projectId,
      project_client_key: config_default.authOptions.clientKey,
      project_app_uuid: config_default.authOptions.appId
    };
    const merged = { ...config.params };
    if (config.data) {
      Object.assign(merged, { ...config.data });
    }
    merged["mac_key"] = macKey;
    const mac = (0, import_fast_json_stable_stringify.default)(merged);
    config.params.mac = (0, import_sha256.default)(mac).toString().toLowerCase();
  }
  return config;
});
client.interceptors.response.use((response) => {
  const data = response.data;
  if (response.status < 300 || response.status === 304) {
    if (isApiError(data)) {
      if (data.error_code === 10005 /* InvalidToken */) {
        encryptedStorage_default.clear();
        setTimeout(() => eventUtils_default.emit("particleAuthDisconnect" /* ParticleAuthDisconnect */, data), 0);
      }
      return Promise.reject(data);
    } else if (data.error && isRpcError(data.error)) {
      return Promise.reject(data.error);
    }
    return Promise.resolve(response);
  }
  return Promise.reject({
    code: response.status,
    message: response.statusText || "Network Error",
    data: response.data
  });
});
var isChainRpcRequest = (baseUrl) => {
  return baseUrl == null ? void 0 : baseUrl.includes("rpc");
};
var client_default = client;

// src/api/evmApi.ts
var evmApi = {
  async request(data) {
    const response = await client_default.post(
      "/evm-chain",
      {
        ...data,
        id: data.id || (0, import_uuid3.v4)(),
        jsonrpc: data.jsonrpc || "2.0",
        chainId: data.chainId || 1
      },
      {
        headers: {
          "Auth-Type": "Basic"
        },
        baseURL: config_default.env.rpcUrl
      }
    ).then((response2) => response2.data);
    return response.result;
  }
};
var evmApi_default = evmApi;

// src/utils/chainUtils.ts
var import_chains = require("@particle-network/chains");

// src/utils/tron/crypto.ts
var import_enc_hex = __toESM(require("crypto-js/enc-hex.js"), 1);
var import_sha2562 = __toESM(require("crypto-js/sha256.js"), 1);

// src/utils/tron/base58.ts
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var ALPHABET_MAP = ALPHABET.split("").reduce((acc, x, i) => {
  acc[x] = i;
  return acc;
}, {});
var BASE = 58;
var encode58 = (buffer) => {
  if (buffer.length === 0)
    return "";
  const digits = [0];
  for (let i = 0; i < buffer.length; i++) {
    for (let j = 0; j < digits.length; j++)
      digits[j] <<= 8;
    digits[0] += buffer[i];
    let carry = 0;
    for (let j = 0; j < digits.length; ++j) {
      digits[j] += carry;
      carry = digits[j] / BASE | 0;
      digits[j] %= BASE;
    }
    while (carry) {
      digits.push(carry % BASE);
      carry = carry / BASE | 0;
    }
  }
  for (let i = 0; buffer[i] === 0 && i < buffer.length - 1; i++)
    digits.push(0);
  return [...digits].reverse().map((digit) => ALPHABET[digit]).join("");
};
var decode58 = (data) => {
  if (data.length === 0)
    return [];
  const bytes = [0];
  for (let i = 0; i < data.length; i++) {
    const c = data[i];
    if (!(c in ALPHABET_MAP))
      throw new Error("Non-base58 character");
    for (let j = 0; j < bytes.length; j++)
      bytes[j] *= BASE;
    bytes[0] += ALPHABET_MAP[c];
    let carry = 0;
    for (let j = 0; j < bytes.length; ++j) {
      bytes[j] += carry;
      carry = bytes[j] >> 8;
      bytes[j] &= 255;
    }
    while (carry) {
      bytes.push(carry & 255);
      carry >>= 8;
    }
  }
  for (let i = 0; data[i] === "1" && i < data.length - 1; i++)
    bytes.push(0);
  return bytes.reverse();
};

// src/utils/tron/crypto.ts
var sha2562 = (msg) => import_enc_hex.default.stringify((0, import_sha2562.default)(import_enc_hex.default.parse(msg)));
var fromHex = (hex2) => {
  const addr = `41${hex2.substring(2)}`;
  const doubleSha256 = sha2562(sha2562(addr));
  const checkSum = doubleSha256.substring(0, 8);
  const address = Buffer.from(addr + checkSum, "hex");
  return encode58(address);
};
var toHex = (base58Sting) => {
  if (base58Sting.length <= 4)
    throw new Error("Invalid address provided");
  let address = Buffer.from(decode58(base58Sting)).toString("hex");
  const checkSum = address.substring(address.length - 8, address.length);
  address = address.substring(0, address.length - 8);
  const checkSum1 = sha2562(sha2562(address)).substring(0, 8);
  if (`${checkSum}` === `${checkSum1}`)
    return `0x${address.substring(2)}`;
  throw new Error("Invalid address provided");
};

// src/utils/chainUtils.ts
function isTron(chain) {
  let chainInfo;
  if (typeof chain === "string" || typeof chain === "number") {
    const chainId = Number(chain);
    chainInfo = import_chains.chains.getEVMChainInfoById(chainId);
  } else {
    chainInfo = import_chains.chains.getEVMChainInfoById(chain.id);
  }
  return chainInfo !== void 0 && chainInfo.name.toLowerCase() === "tron";
}

// src/utils/ethereumUtils.ts
var ethereumUtils = {
  getSignTypedVersion(method) {
    if (method === "eth_signTypedData" /* ethSignTypedData */ || method === "eth_signTypedData_v1" /* ethSignTypedDataV1 */) {
      return "V1" /* V1 */;
    } else if (method === "eth_signTypedData_v3" /* ethSignTypedDataV3 */) {
      return "V3" /* V3 */;
    } else {
      return "V4" /* V4 */;
    }
  },
  isUniq(method) {
    return method === "personal_sign_uniq" /* personalSignUniq */ || method === "eth_signTypedData_v4_uniq" /* ethSignTypedDataV4Uniq */;
  },
  isSignTypedDataV1(method) {
    return method === "eth_signTypedData_v1" /* ethSignTypedDataV1 */ || method === "eth_signTypedData" /* ethSignTypedData */;
  }
};

// src/utils/sigUtils.ts
var import_util = require("@ethereumjs/util");
var import_eth_sig_util = require("@metamask/eth-sig-util");
var import_bn = __toESM(require("bn.js"), 1);
var import_keccak = require("ethereum-cryptography/keccak");
function personalSignHash({ data }) {
  if (isNullish(data)) {
    throw new Error("Missing data parameter");
  }
  const message = legacyToBuffer(data);
  const msgHash = (0, import_util.hashPersonalMessage)(message);
  return msgHash;
}
function signTypedDataHash({
  data,
  version
}) {
  if (isNullish(data)) {
    throw new Error("Missing data parameter");
  }
  const messageHash = version === "V1" /* V1 */ ? _typedSignatureHash(data) : import_eth_sig_util.TypedDataUtils.eip712Hash(
    data,
    version
  );
  return messageHash;
}
function _typedSignatureHash(typedData) {
  const error = new Error("Expect argument to be non-empty array");
  if (typeof typedData !== "object" || !("length" in typedData) || !typedData.length) {
    throw error;
  }
  const data = typedData.map(function(e) {
    if (e.type !== "bytes") {
      return e.value;
    }
    return legacyToBuffer(e.value);
  });
  const types = typedData.map(function(e) {
    return e.type;
  });
  const schema = typedData.map(function(e) {
    if (!e.name) {
      throw error;
    }
    return `${e.type} ${e.name}`;
  });
  return (0, import_util.arrToBufArr)(
    (0, import_keccak.keccak256)(
      solidityPack(
        ["bytes32", "bytes32"],
        [
          (0, import_keccak.keccak256)(solidityPack(new Array(typedData.length).fill("string"), schema)),
          (0, import_keccak.keccak256)(solidityPack(types, data))
        ]
      )
    )
  );
}
var solidityPack = function(types, values) {
  if (types.length !== values.length) {
    throw new Error("Number of types are not matching the values");
  }
  const ret = [];
  for (let i = 0; i < types.length; i++) {
    const type = elementaryName(types[i]);
    const value = values[i];
    ret.push(solidityHexValue(type, value, null));
  }
  return Buffer.concat(ret);
};
function elementaryName(name) {
  if (name.startsWith("int[")) {
    return "int256" + name.slice(3);
  } else if (name === "int") {
    return "int256";
  } else if (name.startsWith("uint[")) {
    return "uint256" + name.slice(4);
  } else if (name === "uint") {
    return "uint256";
  } else if (name.startsWith("fixed[")) {
    return "fixed128x128" + name.slice(5);
  } else if (name === "fixed") {
    return "fixed128x128";
  } else if (name.startsWith("ufixed[")) {
    return "ufixed128x128" + name.slice(6);
  } else if (name === "ufixed") {
    return "ufixed128x128";
  }
  return name;
}
var solidityHexValue = function(type, value, bitsize) {
  let size, num;
  if (isArray(type)) {
    let subType = type.replace(/\[.*?\]/, "");
    if (!isArray(subType)) {
      let arraySize = parseTypeArray(type);
      if (arraySize !== "dynamic" && arraySize !== 0 && value.length > arraySize) {
        throw new Error("Elements exceed array size: " + arraySize);
      }
    }
    let arrayValues = value.map(function(v) {
      return solidityHexValue(subType, v, 256);
    });
    return Buffer.concat(arrayValues);
  } else if (type === "bytes") {
    return value;
  } else if (type === "string") {
    return Buffer.from(value, "utf8");
  } else if (type === "bool") {
    bitsize = bitsize || 8;
    let padding = Array(bitsize / 4).join("0");
    return Buffer.from(value ? padding + "1" : padding + "0", "hex");
  } else if (type === "address") {
    let bytesize = 20;
    if (bitsize) {
      bytesize = bitsize / 8;
    }
    return (0, import_util.setLengthLeft)(value, bytesize);
  } else if (type.startsWith("bytes")) {
    size = parseTypeN(type);
    if (size < 1 || size > 32) {
      throw new Error("Invalid bytes<N> width: " + size);
    }
    return (0, import_util.setLengthRight)(value, size);
  } else if (type.startsWith("uint")) {
    size = parseTypeN(type);
    if (size % 8 || size < 8 || size > 256) {
      throw new Error("Invalid uint<N> width: " + size);
    }
    num = parseNumber(value);
    if (num.bitLength() > size) {
      throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
    }
    bitsize = bitsize || size;
    return num.toArrayLike(Buffer, "be", bitsize / 8);
  } else if (type.startsWith("int")) {
    size = parseTypeN(type);
    if (size % 8 || size < 8 || size > 256) {
      throw new Error("Invalid int<N> width: " + size);
    }
    num = parseNumber(value);
    if (num.bitLength() > size) {
      throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
    }
    bitsize = bitsize || size;
    return num.toTwos(size).toArrayLike(Buffer, "be", bitsize / 8);
  } else {
    throw new Error("Unsupported or invalid type: " + type);
  }
};
function parseTypeN(type) {
  return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
}
function parseTypeArray(type) {
  const tmp = type.match(/(.*)\[(.*?)\]$/);
  if (tmp) {
    return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
  }
  return null;
}
function parseNumber(arg) {
  const type = typeof arg;
  if (type === "string") {
    if ((0, import_util.isHexPrefixed)(arg)) {
      return new import_bn.default((0, import_util.stripHexPrefix)(arg), 16);
    } else {
      return new import_bn.default(arg, 10);
    }
  } else if (type === "number") {
    return new import_bn.default(arg);
  } else if (arg.toArray) {
    return arg;
  } else {
    throw new Error("Argument is not a number");
  }
}
function isArray(type) {
  return type.lastIndexOf("]") === type.length - 1;
}
function legacyToBuffer(value) {
  return typeof value === "string" && !(0, import_util.isHexString)(value) ? Buffer.from(value) : (0, import_util.toBuffer)(value);
}

// src/core/connectApi.ts
var import_chains2 = require("@particle-network/chains");
var import_base64url = __toESM(require("base64url"), 1);

// src/api/pnApi.ts
var pnApi = {
  async sendCaptcha(data) {
    const response = await client_default.post("/code", data, {
      headers: {
        "Auth-Type": "Basic"
      }
    });
    return response.data.success;
  },
  async login(data) {
    const response = await client_default.post("/login", data, {
      headers: {
        "Auth-Type": "Basic"
      }
    });
    const userInfo = response.data;
    return userInfo;
  },
  async loginWithThirdparty(provider, code) {
    const response = await client_default.post(
      "/login_thirdparty",
      {
        provider: provider === "twitter" ? "twitterv1" : provider,
        thirdparty_code: code
      },
      {
        headers: {
          "Auth-Type": "Basic"
        }
      }
    );
    const userInfo = response.data;
    return userInfo;
  },
  async loginWithThirdpartyV2(provider, code, nonce) {
    const response = await client_default.post(
      "/login_thirdparty_v2",
      {
        provider: provider === "twitter" ? "twitterv1" : provider,
        thirdparty_code: code,
        nonce
      },
      {
        headers: {
          "Auth-Type": "Basic"
        }
      }
    );
    const userInfo = response.data;
    return userInfo;
  },
  async getThirdpartyAuthUrl(provider, redirectUrl, appState, prompt) {
    const response = await client_default.post(
      "/thirdparty_auth_url",
      {
        provider: provider === "twitter" ? "twitterv1" : provider,
        redirect_url: redirectUrl,
        app_state: appState,
        prompt
      },
      {
        headers: {
          "Auth-Type": "Basic"
        }
      }
    );
    const result = response.data;
    return result;
  },
  async loginBindings(data) {
    const response = await client_default.post("/login_bindings", data);
    return response.data;
  },
  async loginBindingsCheck(params) {
    const response = await client_default.get("/login_bindings/check", {
      params
    });
    return response.data.exists;
  },
  async getLoginBindings() {
    const response = await client_default.get("/login_bindings");
    return response.data;
  },
  async deleteLoginBinding(params) {
    const response = await client_default.delete("/login_bindings", {
      params
    });
    return response.data.success;
  },
  async loginBindingsThirdparty(data) {
    const response = await client_default.post("/login_bindings/thirdparty", {
      ...data,
      provider: data.provider === "twitter" ? "twitterv1" : data.provider
    });
    return response.data;
  },
  async getTwitterToken() {
    const response = await client_default.post("/twitter_request_token", void 0, {
      headers: {
        "Auth-Type": "Basic"
      }
    });
    return response.data.oauth_token;
  },
  async syncUserInfo() {
    var _a;
    const response = await client_default.get(`/users/${(_a = userStorage_default.getUserInfo()) == null ? void 0 : _a.uuid}`);
    return response.data;
  },
  async logout() {
    const response = await client_default.post("/logout");
    return response.data.success;
  },
  async updateWallet(uuid5, params) {
    const response = await client_default.patch(`/wallets/users/${uuid5}`, params);
    return response.data.success;
  },
  async loginCognito() {
    const response = await client_default.post("/login_cognito");
    const result = response.data;
    userStorage_default.updateCognitoResult(result);
    return result;
  },
  async sendSecurityAccountsCode(data) {
    return client_default.post("/security/accounts/code", data).then((response) => response.data.success);
  },
  async bindSecurityAccount(params) {
    const response = await client_default.post("/security/accounts/bind", params);
    const result = response.data;
    return result;
  },
  async getSecurityAccountCode(verifyCodeMethod) {
    return client_default.post("/security/accounts/verify_code", {
      verify_code_method: verifyCodeMethod
    }).then((response) => response.data.success);
  },
  async getSecurityAccountToken({
    verifyCodeMethod,
    code
  }) {
    return client_default.post("/security/accounts/verify", {
      verify_code_method: verifyCodeMethod,
      code
    }).then((response) => response.data.token);
  },
  async setPaymentPassword({
    password,
    verifyCodeMethod,
    code
  }) {
    const response = await client_default.post("/security/payments/reset", {
      password,
      verify_code_method: verifyCodeMethod,
      code
    });
    return response.data;
  },
  async updatePaymentPassword({
    password,
    oldPassword
  }) {
    const response = await client_default.post("/security/payments/update", {
      password,
      old_password: oldPassword
    });
    return response.data;
  },
  async verifyPaymentPassword(password) {
    return client_default.post("/security/payments/verify", { password }).then((response) => response.data.payment_token);
  },
  async deletePaymentPassword(password) {
    const response = await client_default.post("/security/payments/disable", { password });
    return response.data;
  },
  async getAuthorizations() {
    return client_default.get("/authorizations").then((response) => {
      return response.data;
    });
  },
  async deleteAuthorization(projectAppUuid) {
    return client_default.delete(`/authorizations/${projectAppUuid}`).then((response) => {
      return response.data.success;
    });
  }
};
var pnApi_default = pnApi;

// src/api/kms.ts
async function createKMSClient() {
  const [AWS, fromCognitoIdentity, NotAuthorizedException] = await Promise.all([
    import("@aws-sdk/client-kms"),
    import("@aws-sdk/credential-providers").then((m) => m.fromCognitoIdentity),
    import("@aws-sdk/client-cognito-identity").then((m) => m.NotAuthorizedException)
  ]);
  const cognitoResult = userStorage_default.getCognitoResult();
  if (!cognitoResult) {
    throw new Error("cognito result not found!");
  }
  const credentials = fromCognitoIdentity({
    identityId: cognitoResult.identity_id,
    logins: {
      "cognito-identity.amazonaws.com": cognitoResult.id_token
    },
    clientConfig: { region: cognitoResult.region }
  });
  return {
    kmsClient: new AWS.KMS({
      region: cognitoResult.region,
      credentials
    }),
    NotAuthorizedException
  };
}
async function generateDataKey() {
  var _a;
  const { kmsClient, NotAuthorizedException } = await createKMSClient();
  let output;
  try {
    output = await kmsClient.generateDataKey({
      KeyId: (_a = userStorage_default.getCognitoResult()) == null ? void 0 : _a.kms_key_id,
      KeySpec: "AES_256"
    });
  } catch (e) {
    if (e instanceof NotAuthorizedException) {
      await pnApi_default.loginCognito();
      return await generateDataKey();
    } else {
      throw e;
    }
  }
  if (!output.CiphertextBlob || !output.Plaintext) {
    throw new Error("KMS generate DataKey error.");
  }
  return {
    ciphertext: Buffer.from(output.CiphertextBlob).toString("base64"),
    plaintext: Buffer.from(output.Plaintext).toString("base64")
  };
}
async function decryptDataKey(encryptDataKey) {
  var _a;
  const { kmsClient, NotAuthorizedException } = await createKMSClient();
  let dataKey;
  try {
    const output = await kmsClient.decrypt({
      KeyId: (_a = userStorage_default.getCognitoResult()) == null ? void 0 : _a.kms_key_id,
      CiphertextBlob: Buffer.from(encryptDataKey, "base64")
    });
    dataKey = output.Plaintext;
  } catch (e) {
    if (e instanceof NotAuthorizedException) {
      await pnApi_default.loginCognito();
      const result = await decryptDataKey(encryptDataKey);
      return result;
    } else {
      throw e;
    }
  }
  if (!dataKey) {
    throw new Error("KMS decryption failed, please try again later.");
  }
  return Buffer.from(dataKey).toString("base64");
}
async function decrypt(data, decompress = false) {
  var _a;
  const { kmsClient, NotAuthorizedException } = await createKMSClient();
  let Plaintext;
  try {
    const output = await kmsClient.decrypt({
      KeyId: (_a = userStorage_default.getCognitoResult()) == null ? void 0 : _a.kms_key_id,
      CiphertextBlob: Buffer.from(data, "base64")
    });
    Plaintext = output.Plaintext;
  } catch (e) {
    if (e instanceof NotAuthorizedException) {
      await pnApi_default.loginCognito();
      const txt = await decrypt(data, decompress);
      return txt;
    }
  }
  if (!Plaintext) {
    throw new Error("KMS decryption failed, please try again later.");
  }
  if (decompress) {
    const LZUTF8 = await import("lzutf8").then((m) => m.default);
    const output = LZUTF8.decompress(Plaintext);
    return Buffer.from(output).toString("utf8");
  } else {
    return Buffer.from(Plaintext).toString("utf8");
  }
}

// src/core/threshSig.ts
var import_util2 = require("@ethereumjs/util");
var import_bs58 = __toESM(require("bs58"), 1);
var threshSig = {
  async edDSA(data) {
    const { EdDsa } = await import("@particle-network/thresh-sig");
    return EdDsa.from(data);
  },
  async ecDSA(data) {
    const { Ecdsa } = await import("@particle-network/thresh-sig");
    return Ecdsa.from(data);
  },
  async refreshEcdsa(p2Key) {
    const { Ecdsa } = await import("@particle-network/thresh-sig");
    const newP2Key = (await Ecdsa.from(p2Key).refresh(config_default.env.baseUrl, this.params())).to();
    return newP2Key;
  },
  async decryptData(ciphertext, key) {
    try {
      const { decryptData } = await import("@particle-network/thresh-sig");
      const plaintext = await decryptData(ciphertext, key);
      return plaintext;
    } catch (error) {
      if (userStorage_default.hasMasterPassword()) {
        throw new Error("Master password decryption error");
      } else {
        throw new Error("Decryption failed, please try again later.");
      }
    }
  },
  async encryptData(plaintext, key) {
    const { encryptData } = await import("@particle-network/thresh-sig");
    const encrypted = await encryptData(plaintext, key);
    return encrypted;
  },
  async generateKey(password, uuid5) {
    const { generateKey } = await import("@particle-network/thresh-sig");
    const key = await generateKey(password, uuid5);
    return key;
  },
  async create(chainName) {
    const endpoint = config_default.env.baseUrl;
    const params = this.params();
    let p2Key;
    let address;
    if (chainName === "solana") {
      const { EdDsa } = await import("@particle-network/thresh-sig");
      const edDSA = await EdDsa.gen(endpoint, params);
      p2Key = edDSA.to();
      address = import_bs58.default.encode(edDSA.pub());
    } else {
      const { Ecdsa } = await import("@particle-network/thresh-sig");
      const ecDSA = await Ecdsa.gen(endpoint, params);
      p2Key = ecDSA.to();
      address = (0, import_util2.toChecksumAddress)("0x" + (0, import_util2.publicToAddress)(ecDSA.pub(), true).toString("hex"));
    }
    return {
      p2Key,
      address
    };
  },
  params() {
    const userInfo = requireNotNullish(userStorage_default.getUserInfo(), "Please connect AuthCore first!");
    const value = JSON.stringify({
      token: userInfo.token,
      project_uuid: config_default.authOptions.projectId,
      project_client_key: config_default.authOptions.clientKey,
      project_app_uuid: config_default.authOptions.appId,
      sdk_version: config_default.version,
      device_id: config_default.deviceId,
      mac_key: userInfo.mac_key,
      payment_token: config_default.paymentToken
    });
    config_default.paymentToken = void 0;
    return value;
  }
};
var threshSig_default = threshSig;

// src/core/masterPassword.ts
var setupMasterPassword = async (password) => {
  const userInfo = userStorage_default.getUserInfo();
  if (!userInfo) {
    throw new Error("user not login");
  }
  const { ciphertext, plaintext } = await generateDataKey();
  const localKey = await threshSig_default.generateKey(password, userInfo.uuid);
  const localKMSDataKey = await threshSig_default.generateKey(plaintext, userInfo.uuid);
  const requests = userInfo.wallets.map((wallet2) => {
    if (wallet2.encrypted_type === 0 /* KMS_AES */) {
      if (isNullish(wallet2.public_address)) {
        return createType2Wallet(wallet2, localKey, localKMSDataKey);
      } else {
        return encryptType0Wallet(wallet2, localKey, localKMSDataKey);
      }
    } else if (wallet2.encrypted_type === 1 /* KMS_AES_WITH_DATA_KEY_AND_DEFAULT_MASTER_PASSWORD */) {
      return encryptTypeWallet(wallet2, localKey, localKMSDataKey);
    } else {
      return encryptTypeWallet(wallet2, localKey, localKMSDataKey);
    }
  });
  const encryptResults = await Promise.all(requests);
  for (const result of encryptResults) {
    const decryptResult = await decryptP2Key(result.p2KeyEncrypted2, localKey, localKMSDataKey);
    check(decryptResult === result.p2Key, "check decrypt p2Key error");
  }
  const wallets = encryptResults.map((item) => {
    const { uuid: uuid5, public_address } = item.wallet;
    return {
      wallet_uuid: uuid5,
      public_address: item.created ? public_address : void 0,
      encrypted_data: item.p2KeyEncrypted2
    };
  });
  const encryptedKMSDataKey = ciphertext;
  const updateResult = await pnApi_default.updateWallet(userInfo.uuid, {
    encrypted_type: 2 /* KMS_AES_WITH_DATA_KEY_AND_MASTER_PASSWORD */,
    encrypted_kms_data_key: encryptedKMSDataKey,
    wallets
  });
  saveLocalKey(localKey);
  saveLocalKMSDataKey(encryptedKMSDataKey, localKMSDataKey);
  userInfo.wallets.forEach((wallet2) => {
    const newWallet = wallets.find((item) => item.wallet_uuid === wallet2.uuid);
    if (newWallet == null ? void 0 : newWallet.encrypted_data) {
      wallet2.encrypted_data = newWallet.encrypted_data;
      wallet2.encrypted_kms_data_key = encryptedKMSDataKey;
      wallet2.encrypted_type = 2 /* KMS_AES_WITH_DATA_KEY_AND_MASTER_PASSWORD */;
      if (newWallet.public_address) {
        wallet2.public_address = newWallet.public_address;
      }
    }
  });
  if (userInfo.security_account) {
    userInfo.security_account.has_set_master_password = true;
  }
  userStorage_default.setUserInfo(userInfo);
  return updateResult;
};
var createType2Wallet = async (wallet2, localKey, localKMSDataKey) => {
  const { p2Key, address } = await threshSig_default.create(wallet2.chain_name);
  const p2KeyEncrypted2 = await encryptP2Key(p2Key, localKey, localKMSDataKey);
  wallet2.public_address = address;
  return {
    p2Key,
    p2KeyEncrypted2,
    wallet: wallet2,
    created: true
  };
};
var createEncryptedWallet = async (wallet2, p2Key, address, encryptedKMSDataKey, localKMSDataKey) => {
  const userInfo = userStorage_default.getUserInfo();
  if (!userInfo) {
    throw new Error("user not login");
  }
  const encryptedType = userStorage_default.hasMasterPassword() ? 2 /* KMS_AES_WITH_DATA_KEY_AND_MASTER_PASSWORD */ : 1 /* KMS_AES_WITH_DATA_KEY_AND_DEFAULT_MASTER_PASSWORD */;
  if (!localKMSDataKey) {
    localKMSDataKey = await loadLocalKMSDataKey(encryptedKMSDataKey);
  }
  let localKey;
  if (encryptedType === 2 /* KMS_AES_WITH_DATA_KEY_AND_MASTER_PASSWORD */) {
    localKey = await loadLocalKey();
  } else {
    localKey = await threshSig_default.generateKey("", userInfo.uuid);
  }
  const p2KeyEncrypted2 = await encryptP2Key(p2Key, localKey, localKMSDataKey);
  const decryptResult = await decryptP2Key(p2KeyEncrypted2, localKey, localKMSDataKey);
  check(decryptResult === p2Key, "check decrypt p2Key error");
  const updateResult = await pnApi_default.updateWallet(userInfo.uuid, {
    encrypted_type: encryptedType,
    encrypted_kms_data_key: encryptedKMSDataKey,
    wallets: [
      {
        wallet_uuid: wallet2.uuid,
        encrypted_data: p2KeyEncrypted2,
        public_address: address
      }
    ]
  });
  saveLocalKey(localKey);
  saveLocalKMSDataKey(encryptedKMSDataKey, localKMSDataKey);
  const newWallet = userInfo.wallets.find((item) => item.uuid === wallet2.uuid);
  if (newWallet) {
    newWallet.encrypted_data = p2KeyEncrypted2;
    newWallet.encrypted_kms_data_key = encryptedKMSDataKey;
    newWallet.encrypted_type = encryptedType;
    newWallet.public_address = address;
  }
  userStorage_default.setUserInfo(userInfo);
  return updateResult;
};
var decryptWallet = async (wallet2) => {
  let p2Key = "";
  if (wallet2.encrypted_type === 0 /* KMS_AES */) {
    p2Key = await decrypt(wallet2.encrypted_data, wallet2.chain_name === "evm_chain");
  } else {
    const localKey = await loadLocalKey();
    const localKMSDataKey = await loadLocalKMSDataKey(wallet2.encrypted_kms_data_key || "");
    p2Key = await decryptP2Key(wallet2.encrypted_data, localKey, localKMSDataKey);
  }
  return p2Key;
};
var encryptType0Wallet = async (wallet2, localKey, localKMSDataKey) => {
  let p2Key = await decrypt(wallet2.encrypted_data, wallet2.chain_name === "evm_chain");
  if (wallet2.chain_name === "evm_chain") {
    p2Key = await threshSig_default.refreshEcdsa(p2Key);
  }
  const p2KeyEncrypted2 = await encryptP2Key(p2Key, localKey, localKMSDataKey);
  return {
    p2Key,
    p2KeyEncrypted2,
    wallet: wallet2
  };
};
var encryptTypeWallet = async (wallet2, localKey, localKMSDataKey) => {
  const oldLocalKMSDataKey = await loadLocalKMSDataKey(wallet2.encrypted_kms_data_key || "");
  const oldLocalKey = await loadLocalKey();
  let p2Key = await decryptP2Key(wallet2.encrypted_data, oldLocalKey, oldLocalKMSDataKey);
  if (wallet2.chain_name === "evm_chain") {
    p2Key = await threshSig_default.refreshEcdsa(p2Key);
  }
  const p2KeyEncrypted2 = await encryptP2Key(p2Key, localKey, localKMSDataKey);
  return {
    p2Key,
    p2KeyEncrypted2,
    wallet: wallet2
  };
};
var decryptP2Key = async (p2KeyEncrypted, localKey, localKMSDataKey) => {
  const p2KeyEncrypted1 = await threshSig_default.decryptData(p2KeyEncrypted, localKMSDataKey);
  const p2Key = await threshSig_default.decryptData(p2KeyEncrypted1, localKey);
  return p2Key;
};
var encryptP2Key = async (p2Key, localKey, localKMSDataKey) => {
  const p2KeyEncrypted1 = await threshSig_default.encryptData(p2Key, localKey);
  const p2KeyEncrypted2 = await threshSig_default.encryptData(p2KeyEncrypted1, localKMSDataKey);
  return p2KeyEncrypted2;
};
var checkMasterPassword = async (password) => {
  const userInfo = requireNotNullish(userStorage_default.getUserInfo(), "Please connect AuthCore first!");
  const localKey = await threshSig_default.generateKey(password, userInfo.uuid);
  const wallet2 = userInfo.wallets.find(
    (item) => !isNullish(item.public_address) && item.encrypted_type === 2 /* KMS_AES_WITH_DATA_KEY_AND_MASTER_PASSWORD */
  );
  if (!wallet2) {
    throw new Error("master password not set");
  }
  const localKMSDataKey = await loadLocalKMSDataKey(wallet2.encrypted_kms_data_key || "");
  const p2KeyEncrypted1 = await threshSig_default.decryptData(wallet2.encrypted_data, localKMSDataKey);
  await threshSig_default.decryptData(p2KeyEncrypted1, localKey);
  saveLocalKey(localKey);
};
var loadLocalKMSDataKey = async (encryptedKMSDataKey) => {
  if (!encryptedKMSDataKey) {
    throw new Error("encryptedKMSDataKey not found");
  }
  const userInfo = userStorage_default.getUserInfo();
  check(userInfo, new Error("please login first!"));
  let localKMSDataKey = encryptedStorage_default.getItem(encryptedKMSDataKey);
  if (localKMSDataKey) {
    return localKMSDataKey;
  }
  const kmsDataKey = await decryptDataKey(encryptedKMSDataKey);
  localKMSDataKey = await threshSig_default.generateKey(kmsDataKey, userStorage_default.getUserInfo().uuid);
  saveLocalKMSDataKey(encryptedKMSDataKey, localKMSDataKey);
  return localKMSDataKey;
};
var saveLocalKMSDataKey = (encryptedKMSDataKey, localKMSDataKey) => {
  encryptedStorage_default.setItem(encryptedKMSDataKey, localKMSDataKey);
};
var loadLocalKey = async () => {
  const localKey = encryptedStorage_default.getItem("local_key" /* LocalKey */);
  if (!localKey) {
    if (userStorage_default.hasMasterPassword()) {
      throw new Error("Local Key not found");
    } else {
      const userInfo = userStorage_default.getUserInfo();
      check(userInfo, new Error("please login first!"));
      const localKey2 = await threshSig_default.generateKey("", userInfo.uuid);
      saveLocalKey(localKey2);
      return localKey2;
    }
  }
  return localKey;
};
var hasLocalKey = () => {
  const localKey = encryptedStorage_default.getItem("local_key" /* LocalKey */);
  return !isNullish(localKey);
};
var clearLocalKey = () => {
  encryptedStorage_default.removeItem("local_key" /* LocalKey */);
};
var saveLocalKey = (localKey) => {
  encryptedStorage_default.setItem("local_key" /* LocalKey */, localKey);
};

// src/core/wallet.ts
var wallet = {
  getWalletInfo(name) {
    const userInfo = userStorage_default.getUserInfo();
    if (!userInfo) {
      throw new Error("please login first!");
    }
    return userInfo.wallets.filter((info) => info.chain_name === name)[0];
  },
  hasType1Wallet() {
    var _a, _b;
    return Boolean(
      (_b = (_a = userStorage_default.getUserInfo()) == null ? void 0 : _a.wallets) == null ? void 0 : _b.some(
        (info) => info.encrypted_type === 1 /* KMS_AES_WITH_DATA_KEY_AND_DEFAULT_MASTER_PASSWORD */
      )
    );
  },
  publicAddress(name) {
    const walletInfo = this.getWalletInfo(name);
    return walletInfo.public_address || "";
  },
  async gen(name) {
    const userInfo = userStorage_default.getUserInfo();
    if (!userInfo) {
      throw new Error("please login first!");
    }
    const walletInfo = this.getWalletInfo(name);
    let publicAddress;
    if (walletInfo == null ? void 0 : walletInfo.public_address) {
      publicAddress = walletInfo.public_address;
    } else {
      const otherWallet = userInfo.wallets.filter((info) => info.chain_name !== name)[0];
      let encryptedKMSDataKey = otherWallet.encrypted_kms_data_key;
      let localKMSDataKey;
      let p2KeyValue;
      if (encryptedKMSDataKey) {
        const { address, p2Key } = await threshSig_default.create(walletInfo.chain_name);
        publicAddress = address;
        p2KeyValue = p2Key;
      } else {
        const [{ p2Key, address }, kmsDataKey] = await Promise.all([
          threshSig_default.create(walletInfo.chain_name),
          generateDataKey().then(({ ciphertext, plaintext }) => {
            return Promise.all([
              threshSig_default.generateKey(plaintext, userInfo.uuid),
              Promise.resolve(ciphertext)
            ]);
          })
        ]);
        p2KeyValue = p2Key;
        publicAddress = address;
        localKMSDataKey = kmsDataKey[0];
        encryptedKMSDataKey = kmsDataKey[1];
      }
      await createEncryptedWallet(walletInfo, p2KeyValue, publicAddress, encryptedKMSDataKey, localKMSDataKey);
    }
    return publicAddress;
  },
  async decryptEcdsa(name) {
    const data = await decryptWallet(this.getWalletInfo(name));
    const ecDSA = await threshSig_default.ecDSA(data);
    return ecDSA;
  },
  async decryptEdDsa(name) {
    const data = await decryptWallet(this.getWalletInfo(name));
    const edDSA = await threshSig_default.edDSA(data);
    return edDSA;
  }
};
var wallet_default = wallet;

// src/core/connectApi.ts
var getCloudflareTurnstileResponse = async (options) => {
  const iframe = document.createElement("iframe");
  const theme = "light";
  const language = (options == null ? void 0 : options.language) || "en";
  iframe.src = `${config_default.env.authCore}/cloudflare.html?language=${language}&theme=${theme}&_=0.1.1`;
  iframe.classList.add("particle-cloudflare-iframe");
  const style = {
    position: "absolute",
    zIndex: "999",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: "none",
    background: "none",
    width: "300px",
    height: "65px",
    left: "50%",
    top: "50%",
    transform: "translate(-50%, -50%)",
    colorScheme: "none"
  };
  for (const key in style) {
    iframe.style[key] = style[key];
  }
  const container = (options == null ? void 0 : options.getContainer) ? typeof options.getContainer === "function" ? options.getContainer() : options.getContainer : document.body;
  container.appendChild(iframe);
  return new Promise((resolve, reject) => {
    const listener = (event) => {
      if (event.data.type === "particle-auth-core-cloudflareToken") {
        window.removeEventListener("message", listener);
        container.removeChild(iframe);
        const token = event.data.token;
        if (token) {
          resolve(event.data.token);
        } else {
          reject("Validation failed");
        }
      }
    };
    window.addEventListener("message", listener);
  });
};
var thirdpartyAuth = async (parms) => {
  const { authType, appState, prompt } = parms;
  let { redirectUrl } = parms;
  if (!redirectUrl) {
    redirectUrl = window.location.href;
  }
  const { auth_url: thirdpartyAuthUrl, state } = await pnApi_default.getThirdpartyAuthUrl(
    authType,
    redirectUrl,
    appState,
    prompt
  );
  if (authType === "twitter") {
    const dataStr = JSON.stringify({
      authType,
      redirectUrl,
      thirdpartyAuthUrl,
      state
    });
    const data = (0, import_base64url.default)(dataStr);
    window.location.href = `${config_default.env.authCore}/oauth.html?data=${data}`;
    return;
  }
  sessionStorage.setItem("auth-core-oauth-start", "true");
  window.location.href = thirdpartyAuthUrl;
};
var getConnectCaptcha = async (param) => {
  check(config_default.initialized, "Please init AuthCore first!");
  const result = await pnApi_default.sendCaptcha(param);
  return result;
};
var connect = async (param) => {
  check(config_default.initialized, "Please init AuthCore first!");
  let chainInfo;
  if (param.chain) {
    chainInfo = import_chains2.chains.getChainInfo(param.chain);
    check(chainInfo, `The chain ${JSON.stringify(param.chain)} is not supported`);
    delete param.chain;
  }
  let userInfo;
  let latestAuthType;
  if ("phone" in param && "code" in param && param.phone && param.code) {
    userInfo = await pnApi_default.login(param);
    latestAuthType = "phone" /* phone */;
  } else if ("email" in param && "code" in param && param.email && param.code) {
    userInfo = await pnApi_default.login(param);
    latestAuthType = "email" /* email */;
  } else if ("jwt" in param && param.jwt) {
    userInfo = await pnApi_default.loginWithThirdparty("jwt" /* jwt */, param.jwt);
    latestAuthType = "jwt" /* jwt */;
  } else if ("socialType" in param && param.socialType) {
    userInfo = await pnApi_default.loginWithThirdpartyV2(param.socialType, param.code, param.nonce);
    latestAuthType = param.socialType;
  } else {
    throw new Error("invalid connect param");
  }
  clearLocalKey();
  userStorage_default.setUserInfo(userInfo);
  try {
    await wallet_default.gen(
      chainInfo ? chainInfo.chainType === "evm" ? "evm_chain" /* EVM */ : "solana" /* Solana */ : "evm_chain" /* EVM */
    );
  } catch (error) {
    userStorage_default.setUserInfo(void 0);
    throw error;
  }
  userStorage_default.setLatestAuthType(latestAuthType);
  if (chainInfo) {
    eventUtils_default.emit("connectWithChain", chainInfo);
  }
  const info = mapToUserInfo(userInfo);
  onConnect(info);
  return info;
};
var disconnect = async () => {
  try {
    await pnApi_default.logout();
  } catch (error) {
  }
  encryptedStorage_default.clear();
  onDisconnect();
};
var onConnect = (userInfo) => {
  setTimeout(() => eventUtils_default.emit("particleAuthConnect" /* ParticleAuthConnect */, userInfo), 0);
};
var onDisconnect = () => {
  setTimeout(() => eventUtils_default.emit("particleAuthDisconnect" /* ParticleAuthDisconnect */), 0);
};
var isConnected = () => {
  return Boolean(getUserInfo());
};
var getUserInfo = () => {
  const originalUserInfo = userStorage_default.getUserInfo();
  return originalUserInfo ? mapToUserInfo(originalUserInfo) : void 0;
};
var syncUserInfo = async () => {
  const userInfo = userStorage_default.getUserInfo();
  if (!userInfo) {
    throw new Error("Please connect first!");
  }
  const result = await pnApi_default.syncUserInfo();
  const masterPasswordChange = result.wallets.some((wallet2) => {
    const localWallet = userInfo.wallets.find((item) => item.uuid == wallet2.uuid);
    return !localWallet || localWallet.encrypted_data !== wallet2.encrypted_data;
  });
  if (masterPasswordChange) {
    clearLocalKey();
    setTimeout(() => eventUtils_default.emit("masterPasswordChanged" /* MasterPasswordChanged */), 0);
  }
  const newUserInfo = { ...userInfo, ...result };
  userStorage_default.setUserInfo(newUserInfo);
  return mapToUserInfo(newUserInfo);
};
var getLatestAuthType = () => {
  return userStorage_default.getLatestAuthType();
};
var getSmartAccountAddress = async (options) => {
  check(isConnected(), "Please connect first!");
  const ownerAddress = requireNotNullish(particleAuth.ethereum.selectedAddress, "Please create wallet first!");
  const { version, name } = options;
  const localKey = `auth_core_erc4337_${name}_${version}_${ownerAddress}`;
  const localAAAddress = localStorage.getItem(localKey);
  if (localAAAddress) {
    return localAAAddress;
  }
  const accounts = await particleAuth.ethereum.request({
    method: "particle_aa_getSmartAccount",
    params: [{ version, name, ownerAddress }]
  });
  const smartAccountAddress = accounts[0].smartAccountAddress;
  localStorage.setItem(localKey, smartAccountAddress);
  return smartAccountAddress;
};

// src/core/ethereumProvider.ts
var _events, _chainId, _genWallet, genWallet_fn, _checkConnected, checkConnected_fn, _sendAnalyticsActive, sendAnalyticsActive_fn;
var EthereumProvider = class {
  constructor() {
    __privateAdd(this, _genWallet);
    __privateAdd(this, _checkConnected);
    __privateAdd(this, _sendAnalyticsActive);
    __privateAdd(this, _events, new import_events2.default());
    this.isParticleNetwork = true;
    __privateAdd(this, _chainId, 1);
    __privateGet(this, _events).setMaxListeners(100);
    const localChainId = getCurrentEvmChainId();
    if (localChainId && import_chains3.chains.getEVMChainInfoById(localChainId)) {
      __privateSet(this, _chainId, localChainId);
    } else {
      setCurrentEvmChainId(__privateGet(this, _chainId));
    }
    eventUtils_default.on("particleAuthDisconnect" /* ParticleAuthDisconnect */, () => {
      __privateGet(this, _events).emit("disconnect");
    });
    eventUtils_default.on("particleAuthConnect" /* ParticleAuthConnect */, () => {
      if (this.selectedAddress) {
        __privateGet(this, _events).emit("connect", { chainId: (0, import_util3.intToHex)(__privateGet(this, _chainId)) });
      }
    });
    eventUtils_default.on("connectWithChain", (chainInfo) => {
      if (chainInfo.chainType === "evm") {
        __privateSet(this, _chainId, chainInfo.id);
        setCurrentEvmChainId(__privateGet(this, _chainId));
        __privateGet(this, _events).emit("chainChanged", (0, import_util3.intToHex)(__privateGet(this, _chainId)));
      }
    });
  }
  get selectedAddress() {
    var _a;
    const address = (_a = userStorage_default.getEVMWallet()) == null ? void 0 : _a.public_address;
    return address ? address : null;
  }
  get chainId() {
    return (0, import_util3.intToHex)(__privateGet(this, _chainId));
  }
  isConnected() {
    return !isNullish(this.selectedAddress);
  }
  on(event, listener) {
    __privateGet(this, _events).on(event, listener);
    return this;
  }
  once(event, listener) {
    __privateGet(this, _events).once(event, listener);
    return this;
  }
  off(event, listener) {
    __privateGet(this, _events).off(event, listener);
    return this;
  }
  removeListener(event, listener) {
    __privateGet(this, _events).removeListener(event, listener);
    return this;
  }
  async enable() {
    return this.request({
      method: "eth_requestAccounts" /* ethRequestAccounts */
    });
  }
  async disconnect() {
    await disconnect();
  }
  async request(data) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const method = data.method;
    if (!method) {
      throw import_rpc_errors.rpcErrors.invalidParams("Invalid parameters: method is required.");
    }
    if (Object.values(EvmRpcMethod).includes(method)) {
      if (method === "eth_accounts" /* ethAccounts */ || method === "eth_requestAccounts" /* ethRequestAccounts */) {
        if (this.selectedAddress) {
          return [this.selectedAddress];
        } else {
          if (userStorage_default.isLogin()) {
            await __privateMethod(this, _genWallet, genWallet_fn).call(this);
            return [this.selectedAddress];
          } else {
            await new Promise((resolve, reject) => {
              eventUtils_default.emit("requestEthereumAccount" /* RequestEthereumAccount */, { resolve, reject });
            });
            if (!userStorage_default.isLogin()) {
              throw import_rpc_errors.providerErrors.unauthorized();
            } else if (!this.selectedAddress) {
              await __privateMethod(this, _genWallet, genWallet_fn).call(this);
              return [this.selectedAddress];
            }
          }
        }
      } else if (method === "eth_chainId" /* ethChainId */) {
        return this.chainId;
      } else if (method.startsWith("eth_signTypedData" /* ethSignTypedData */)) {
        __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
        const isV1 = ethereumUtils.isSignTypedDataV1(method);
        const from = isV1 ? (_a = data == null ? void 0 : data.params) == null ? void 0 : _a[1] : (_b = data == null ? void 0 : data.params) == null ? void 0 : _b[0];
        let typedData = isV1 ? (_c = data == null ? void 0 : data.params) == null ? void 0 : _c[0] : (_d = data == null ? void 0 : data.params) == null ? void 0 : _d[1];
        if (!from || typeof from !== "string") {
          throw import_rpc_errors.rpcErrors.invalidParams("Invalid parameters: must provide an Ethereum address.");
        }
        if (!typedData) {
          throw import_rpc_errors.rpcErrors.invalidParams("Invalid parameters: must provide typed data.");
        }
        if (from.toLowerCase() !== ((_e = this.selectedAddress) == null ? void 0 : _e.toLowerCase())) {
          throw import_rpc_errors.providerErrors.unauthorized();
        }
        if (typeof typedData === "string") {
          typedData = JSON.parse(typedData);
        }
        const uniq = ethereumUtils.isUniq(method);
        const version = ethereumUtils.getSignTypedVersion(method);
        const result = await this.signTypedData({
          data: typedData,
          version,
          uniq
        });
        return result;
      } else if (method.startsWith("personal_sign" /* personalSign */)) {
        __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
        let message = (_f = data == null ? void 0 : data.params) == null ? void 0 : _f[0];
        const from = (_g = data == null ? void 0 : data.params) == null ? void 0 : _g[1];
        if (!message || typeof message !== "string") {
          throw import_rpc_errors.rpcErrors.invalidParams("Invalid parameters: must provide a valid message.");
        }
        if (!from || typeof from !== "string") {
          throw import_rpc_errors.rpcErrors.invalidParams("Invalid parameters: must provide an Ethereum address.");
        }
        if (from.toLowerCase() !== ((_h = this.selectedAddress) == null ? void 0 : _h.toLowerCase())) {
          throw import_rpc_errors.providerErrors.unauthorized();
        }
        if (!(0, import_util3.isHexString)(message)) {
          message = (0, import_util3.addHexPrefix)(Buffer.from(message).toString("hex"));
        }
        const uniq = ethereumUtils.isUniq(method);
        const result = await this.signMessage(message, uniq);
        return result;
      } else if (method === "wallet_switchEthereumChain" /* walletSwitchEthereumChain */) {
        __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
        const chainId = Number((_j = (_i = data == null ? void 0 : data.params) == null ? void 0 : _i[0]) == null ? void 0 : _j.chainId);
        if (chainId !== __privateGet(this, _chainId)) {
          return await this.switchChain(chainId);
        }
        return null;
      } else if (method === "eth_sendTransaction" /* ethSendTransaction */) {
        __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
        const txData = (_k = data.params) == null ? void 0 : _k[0];
        if (!txData) {
          throw import_rpc_errors.rpcErrors.invalidParams("Invalid parameters: must provide an transaction data.");
        }
        const result = await this.sendTransaction(txData);
        return result;
      } else {
        throw import_rpc_errors.providerErrors.unsupportedMethod();
      }
    } else {
      if (!data.chainId) {
        data.chainId = __privateGet(this, _chainId);
      }
      let result;
      try {
        result = await evmApi_default.request(data);
      } catch (error) {
        const { code, message, extra } = error;
        if (code && message) {
          throw { code, message, data: extra };
        } else {
          throw error;
        }
      }
      return result;
    }
  }
  async sendTransaction(transaction) {
    __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
    const chainId = Number(transaction.chainId || this.chainId);
    const chain = import_chains3.chains.getEVMChainInfoById(chainId);
    if (!chain) {
      throw import_rpc_errors.providerErrors.chainDisconnected();
    }
    if (!transaction.chainId) {
      transaction.chainId = (0, import_util3.intToHex)(chainId);
    }
    if (isNullish(transaction.type)) {
      const chain2 = import_chains3.chains.getEVMChainInfoById(chainId);
      if (chain2 && import_chains3.chains.isChainSupportEIP1559(chain2)) {
        transaction.type = "0x2";
      } else {
        transaction.type = "0x0";
      }
    }
    if (isNullish(transaction.nonce)) {
      transaction.nonce = "0x0";
    }
    if (isNullish(transaction.data)) {
      transaction.data = "0x";
    }
    const ecDSA = await wallet_default.decryptEcdsa("evm_chain" /* EVM */);
    let signedTx;
    if (isTron(chainId)) {
      signedTx = await ecDSA.signTronTx(config_default.env.baseUrl, threshSig_default.params(), transaction);
    } else {
      if (isNullish(transaction.nonce)) {
        transaction.nonce = "0x0";
      }
      const signed = await ecDSA.signTx(config_default.env.baseUrl, threshSig_default.params(), transaction);
      const { TransactionFactory } = await import("@ethereumjs/tx");
      const tx = TransactionFactory.fromTxData(signed);
      signedTx = (0, import_util3.addHexPrefix)(tx.serialize().toString("hex"));
    }
    __privateMethod(this, _sendAnalyticsActive, sendAnalyticsActive_fn).call(this, chainId);
    const result = await evmApi_default.request({
      chainId,
      method: "eth_sendRawTransaction",
      params: [signedTx]
    });
    return result;
  }
  async signMessage(message, uniq) {
    __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
    const hash = personalSignHash({
      data: message
    });
    const ecDSA = await wallet_default.decryptEcdsa("evm_chain" /* EVM */);
    const sig = await ecDSA.sign(config_default.env.baseUrl, threshSig_default.params(), hash, uniq);
    __privateMethod(this, _sendAnalyticsActive, sendAnalyticsActive_fn).call(this);
    return (0, import_eth_sig_util2.concatSig)((0, import_util3.toBuffer)(sig.v + 27), sig.r, sig.s);
  }
  async signTypedData({
    data,
    version,
    uniq
  }) {
    __privateMethod(this, _checkConnected, checkConnected_fn).call(this);
    const hash = signTypedDataHash({
      data,
      version
    });
    const ecDSA = await wallet_default.decryptEcdsa("evm_chain" /* EVM */);
    const sig = await ecDSA.sign(config_default.env.baseUrl, threshSig_default.params(), hash, uniq);
    __privateMethod(this, _sendAnalyticsActive, sendAnalyticsActive_fn).call(this);
    return (0, import_eth_sig_util2.concatSig)((0, import_util3.toBuffer)(sig.v + 27), sig.r, sig.s);
  }
  async switchChain(chainId) {
    if (Number(chainId) !== __privateGet(this, _chainId)) {
      if (!import_chains3.chains.getEVMChainInfoById(Number(chainId))) {
        throw import_rpc_errors.providerErrors.chainDisconnected("The chain is not supported.");
      }
      const userInfo = userStorage_default.getUserInfo();
      if (userInfo) {
        if (!this.selectedAddress) {
          await __privateMethod(this, _genWallet, genWallet_fn).call(this);
        }
      }
      __privateSet(this, _chainId, Number(chainId));
      setCurrentEvmChainId(__privateGet(this, _chainId));
      setTimeout(() => __privateGet(this, _events).emit("chainChanged", (0, import_util3.intToHex)(__privateGet(this, _chainId))), 0);
    }
    return null;
  }
};
_events = new WeakMap();
_chainId = new WeakMap();
_genWallet = new WeakSet();
genWallet_fn = async function() {
  const address = await wallet_default.gen("evm_chain" /* EVM */);
  setTimeout(() => __privateGet(this, _events).emit("accountsChanged", [address]), 0);
};
_checkConnected = new WeakSet();
checkConnected_fn = function() {
  if (!this.isConnected()) {
    throw import_rpc_errors.providerErrors.unauthorized();
  }
};
_sendAnalyticsActive = new WeakSet();
sendAnalyticsActive_fn = function(chainId) {
  const useInfo = userStorage_default.getUserInfo();
  if (useInfo) {
    try {
      analyticsActive({
        chain_id: chainId != null ? chainId : __privateGet(this, _chainId),
        identity: useInfo.uuid,
        login_type: "particle",
        action: "sign",
        wallet_address: this.selectedAddress,
        user_info: JSON.stringify(mapToUserInfo(useInfo))
      });
    } catch (error) {
    }
  }
};

// src/core/solanaWallet.ts
var import_rpc_errors2 = require("@metamask/rpc-errors");
var import_chains4 = require("@particle-network/chains");
var import_events3 = __toESM(require("events"), 1);

// src/api/solanaApi.ts
var import_uuid4 = require("uuid");
var solanaApi = {
  async request(data) {
    const response = await client_default.post(
      "/solana",
      {
        ...data,
        id: data.id || (0, import_uuid4.v4)(),
        jsonrpc: data.jsonrpc || "2.0",
        chainId: data.chainId || 101
      },
      {
        headers: {
          "Auth-Type": "Basic"
        },
        baseURL: config_default.env.rpcUrl
      }
    ).then((response2) => response2.data);
    return response.result;
  },
  async getLatestBlockhash(chainId) {
    const result = await this.request({
      chainId,
      method: "getLatestBlockhash",
      params: [
        {
          commitment: "finalized"
        }
      ]
    });
    return result.value.blockhash;
  }
};
var solanaApi_default = solanaApi;

// src/utils/solanaUtils.ts
var isLegacyTransaction = (transaction) => {
  const version = transaction.version;
  return isNullish(version) || version === "legacy";
};

// src/core/solanaWallet.ts
var _events2, _publicKey, _connecting, _chainId2, _genWallet2, genWallet_fn2, _sendAnalyticsActive2, sendAnalyticsActive_fn2;
var SolanaWallet = class {
  constructor() {
    __privateAdd(this, _genWallet2);
    __privateAdd(this, _sendAnalyticsActive2);
    __privateAdd(this, _events2, new import_events3.default());
    this.isParticleNetwork = true;
    this.name = "Particle";
    this.url = "https://particle.network";
    this.icon = "https://static.particle.network/wallet-icons/Particle.png";
    __privateAdd(this, _publicKey, void 0);
    __privateAdd(this, _connecting, false);
    __privateAdd(this, _chainId2, 101);
    __privateGet(this, _events2).setMaxListeners(100);
    const localChainId = getCurrentSolanaChainId();
    if (localChainId && import_chains4.chains.getSolanaChainInfoById(localChainId)) {
      __privateSet(this, _chainId2, localChainId);
    } else {
      setCurrentSolanaChainId(__privateGet(this, _chainId2));
    }
    eventUtils_default.on("particleAuthDisconnect" /* ParticleAuthDisconnect */, () => {
      __privateSet(this, _publicKey, void 0);
      __privateGet(this, _events2).emit("disconnect");
    });
    eventUtils_default.on("particleAuthConnect" /* ParticleAuthConnect */, async () => {
      if (this.selectedAddress) {
        __privateGet(this, _events2).emit("connect", this.selectedAddress);
      }
    });
    eventUtils_default.on("connectWithChain", (chainInfo) => {
      if (chainInfo.chainType === "solana") {
        __privateSet(this, _chainId2, chainInfo.id);
        setCurrentSolanaChainId(__privateGet(this, _chainId2));
        __privateGet(this, _events2).emit("chainChanged", __privateGet(this, _chainId2));
      }
    });
  }
  on(event, listener) {
    __privateGet(this, _events2).on(event, listener);
    return this;
  }
  once(event, listener) {
    __privateGet(this, _events2).once(event, listener);
    return this;
  }
  off(event, listener) {
    __privateGet(this, _events2).off(event, listener);
    return this;
  }
  removeListener(event, listener) {
    __privateGet(this, _events2).removeListener(event, listener);
    return this;
  }
  get connecting() {
    return __privateGet(this, _connecting);
  }
  get connected() {
    return this.selectedAddress !== null;
  }
  async publicKey() {
    if (this.selectedAddress && !__privateGet(this, _publicKey)) {
      const { PublicKey } = await import("@solana/web3.js");
      __privateSet(this, _publicKey, new PublicKey(this.selectedAddress));
    }
    return __privateGet(this, _publicKey);
  }
  get selectedAddress() {
    var _a;
    const address = (_a = userStorage_default.getSolanaWallet()) == null ? void 0 : _a.public_address;
    return address ? address : null;
  }
  get chainId() {
    return __privateGet(this, _chainId2);
  }
  async connect() {
    try {
      __privateSet(this, _connecting, true);
      if (userStorage_default.isLogin()) {
        if (!this.selectedAddress) {
          await __privateMethod(this, _genWallet2, genWallet_fn2).call(this);
        }
      } else {
        await new Promise((resolve, reject) => {
          eventUtils_default.emit("requestSolanaAccount" /* RequestSolanaAccount */, { resolve, reject });
        });
        if (!userStorage_default.isLogin()) {
          throw import_rpc_errors2.providerErrors.unauthorized();
        } else if (!this.selectedAddress) {
          await __privateMethod(this, _genWallet2, genWallet_fn2).call(this);
        }
      }
      if (this.selectedAddress) {
        __privateGet(this, _events2).emit("connect", this.selectedAddress);
      } else {
        throw import_rpc_errors2.providerErrors.unauthorized();
      }
    } catch (e) {
      return Promise.reject(e);
    } finally {
      __privateSet(this, _connecting, false);
    }
  }
  async disconnect() {
    await disconnect();
    __privateSet(this, _publicKey, void 0);
    return Promise.resolve();
  }
  async signTransaction(transaction, chainId) {
    requireNotNullish(this.connected, "Please connect first!");
    const pubKey = await this.publicKey();
    const edDSA = await wallet_default.decryptEdDsa("solana" /* Solana */);
    if (transaction.signatures.length === 0) {
      const blockhash = await solanaApi_default.getLatestBlockhash(chainId || this.chainId);
      if (isLegacyTransaction(transaction)) {
        transaction.recentBlockhash = blockhash;
      } else {
        transaction.message.recentBlockhash = blockhash;
      }
    }
    const message = isLegacyTransaction(transaction) ? transaction.serializeMessage() : transaction.message.serialize();
    const signed = await edDSA.sign(config_default.env.baseUrl, threshSig_default.params(), message);
    transaction.addSignature(requireNotNullish(pubKey), signed);
    __privateMethod(this, _sendAnalyticsActive2, sendAnalyticsActive_fn2).call(this, chainId);
    return transaction;
  }
  async signAllTransactions(transactions, chainId) {
    requireNotNullish(this.connected, "Please connect first!");
    const pubKey = await this.publicKey();
    let blockhash;
    for (let i = 0; i < transactions.length; i++) {
      const tx = transactions[i];
      if (tx.signatures.length === 0) {
        if (!blockhash) {
          blockhash = await solanaApi_default.getLatestBlockhash(chainId || this.chainId);
        }
        if (isLegacyTransaction(tx)) {
          tx.recentBlockhash = blockhash;
        } else {
          tx.message.recentBlockhash = blockhash;
        }
      }
    }
    const edDSA = await wallet_default.decryptEdDsa("solana" /* Solana */);
    const signatures = await edDSA.batchSign(
      config_default.env.baseUrl,
      threshSig_default.params(),
      transactions.map((tx) => {
        const message = isLegacyTransaction(tx) ? tx.serializeMessage() : tx.message.serialize();
        return Buffer.from(message);
      })
    );
    transactions.forEach((tx, index) => {
      tx.addSignature(requireNotNullish(pubKey), signatures[index]);
    });
    __privateMethod(this, _sendAnalyticsActive2, sendAnalyticsActive_fn2).call(this, chainId);
    return transactions;
  }
  async signAndSendTransaction(transaction, chainId) {
    const signedTx = await this.signTransaction(transaction, chainId);
    const hash = await solanaApi_default.request({
      chainId: chainId || this.chainId,
      method: "sendTransaction",
      params: [
        Buffer.from(signedTx.serialize()).toString("base64"),
        { encoding: "base64", preflightCommitment: "confirmed" }
      ]
    });
    return hash;
  }
  async signMessage(message) {
    check(this.selectedAddress, "Please connect first!");
    const edDSA = await wallet_default.decryptEdDsa("solana" /* Solana */);
    const signature = await edDSA.sign(config_default.env.baseUrl, threshSig_default.params(), message);
    __privateMethod(this, _sendAnalyticsActive2, sendAnalyticsActive_fn2).call(this);
    return signature;
  }
  async switchChain(chainId) {
    check(typeof chainId === "number", "chainId must be a number");
    if (!import_chains4.chains.getSolanaChainInfoById(chainId)) {
      throw import_rpc_errors2.providerErrors.chainDisconnected("The chain is not supported.");
    }
    const userInfo = userStorage_default.getUserInfo();
    if (userInfo) {
      if (!this.selectedAddress) {
        await wallet_default.gen("solana" /* Solana */);
      }
    }
    __privateSet(this, _chainId2, chainId);
    setCurrentSolanaChainId(chainId);
    setTimeout(() => __privateGet(this, _events2).emit("chainChanged", chainId), 0);
  }
  async request(data) {
    const result = await solanaApi_default.request({ ...data, chainId: data.chainId || this.chainId });
    return result;
  }
};
_events2 = new WeakMap();
_publicKey = new WeakMap();
_connecting = new WeakMap();
_chainId2 = new WeakMap();
_genWallet2 = new WeakSet();
genWallet_fn2 = async function() {
  const address = await wallet_default.gen("solana" /* Solana */);
  setTimeout(() => __privateGet(this, _events2).emit("accountsChanged", [address]), 0);
};
_sendAnalyticsActive2 = new WeakSet();
sendAnalyticsActive_fn2 = function(chainId) {
  const useInfo = userStorage_default.getUserInfo();
  if (useInfo) {
    try {
      analyticsActive({
        chain_id: chainId != null ? chainId : __privateGet(this, _chainId2),
        identity: useInfo.uuid,
        login_type: "particle",
        action: "sign",
        wallet_address: this.selectedAddress,
        user_info: JSON.stringify(mapToUserInfo(useInfo))
      });
    } catch (error) {
    }
  }
};

// src/core/authCore.ts
var _authCore, _ethereum, _solana;
var _AuthCore = class {
  constructor() {
    __privateAdd(this, _ethereum, void 0);
    __privateAdd(this, _solana, void 0);
  }
  static getInstance() {
    if (!__privateGet(this, _authCore)) {
      __privateSet(this, _authCore, new _AuthCore());
    }
    return __privateGet(this, _authCore);
  }
  get ethereum() {
    const _ethereum2 = requireNotNullish(__privateGet(this, _ethereum), "Please init AuthCore first!");
    return _ethereum2;
  }
  get solana() {
    const _solana2 = requireNotNullish(__privateGet(this, _solana), "Please init AuthCore first!");
    return _solana2;
  }
  get version() {
    return config_default.version;
  }
  init(options) {
    check(
      options && options.projectId && options.clientKey && options.appId,
      "Init AuthCore failed, please check project config!"
    );
    encryptedStorage_default.init(options.appId);
    config_default.init(options);
    if (!__privateGet(this, _ethereum)) {
      __privateSet(this, _ethereum, new EthereumProvider());
    }
    if (!__privateGet(this, _solana)) {
      __privateSet(this, _solana, new SolanaWallet());
    }
    if (typeof window !== "undefined") {
      window.particleAuth = this;
    }
  }
  on(event, listener) {
    eventUtils_default.on(event, listener);
  }
  once(event, listener) {
    eventUtils_default.once(event, listener);
  }
  off(event, listener) {
    eventUtils_default.off(event, listener);
  }
  removeListener(event, listener) {
    eventUtils_default.removeListener(event, listener);
  }
};
var AuthCore = _AuthCore;
_authCore = new WeakMap();
_ethereum = new WeakMap();
_solana = new WeakMap();
__privateAdd(AuthCore, _authCore, void 0);
var particleAuth = AuthCore.getInstance();

// src/core/securityApi.ts
var import_sha2563 = __toESM(require("crypto-js/sha256.js"), 1);
var getLoginBindAccounts = async () => {
  const result = await pnApi_default.getLoginBindings();
  return result;
};
var checkHasBoundLoginPhoneOrEmail = async (params) => {
  const result = await pnApi_default.loginBindingsCheck(params);
  return result;
};
var bindLoginAccount = async (params) => {
  const userInfo = requireNotNullish(userStorage_default.getUserInfo(), "Please connect AuthCore first!");
  let result;
  if ("phone" in params && params.phone) {
    result = await pnApi_default.loginBindings(params);
  } else if ("email" in params && params.email) {
    result = await pnApi_default.loginBindings(params);
  } else if ("provider" in params && params.provider) {
    result = await pnApi_default.loginBindingsThirdparty(params);
  } else {
    throw new Error("invalid bind login account param");
  }
  const latestUserInfo = { ...userInfo, ...result };
  userStorage_default.setUserInfo(latestUserInfo);
  return mapToUserInfo(latestUserInfo);
};
var getBindSecurityAccounCaptcha = async (data) => {
  const result = await pnApi_default.sendSecurityAccountsCode(data);
  return result;
};
var bindSecurityAccount = async (data) => {
  const result = await pnApi_default.bindSecurityAccount(data);
  userStorage_default.updateSecurityAccount(result);
  return result;
};
var getSecurityAccountCaptcha = async (verifyCodeMethod) => {
  const result = await pnApi_default.getSecurityAccountCode(verifyCodeMethod);
  return result;
};
var getSecurityAccountToken = async (params) => {
  const result = await pnApi_default.getSecurityAccountToken(params);
  return result;
};
var hasPaymentPassword = () => {
  return userStorage_default.hasPaymentPassword();
};
function hashPassword(pwd) {
  const userInfo = userStorage_default.getUserInfo();
  if (!userInfo) {
    throw new Error("Please connect AuthCore first!");
  }
  return (0, import_sha2563.default)(userInfo.uuid + pwd).toString().toLowerCase();
}
var setPaymentPassword = async ({
  password,
  verifyCodeMethod,
  code
}) => {
  const result = await pnApi_default.setPaymentPassword({ password: hashPassword(password), verifyCodeMethod, code });
  userStorage_default.updateSecurityAccount(result);
  return result;
};
var updatePaymentPassword = async ({
  password,
  oldPassword
}) => {
  const result = await pnApi_default.updatePaymentPassword({
    password: hashPassword(password),
    oldPassword: hashPassword(oldPassword)
  });
  userStorage_default.updateSecurityAccount(result);
  return result;
};
var verifyPaymentPassword = async (password) => {
  const result = await pnApi_default.verifyPaymentPassword(hashPassword(password));
  config_default.paymentToken = result;
};
var deletePaymentPassword = async (password) => {
  const result = await pnApi_default.deletePaymentPassword(hashPassword(password));
  userStorage_default.updateSecurityAccount(result);
  return result;
};
var hasMasterPassword = () => {
  return userStorage_default.hasMasterPassword();
};
var isNeedRestoreWallet = () => {
  return hasMasterPassword() && !hasLocalKey();
};
var restoreWallet = async (masterPassword) => {
  const result = await verifyMasterPassword(masterPassword);
  if (result) {
    eventUtils_default.emit("particleWalletRestored" /* ParticleWalletRestored */);
  }
  return result;
};
var setMastersPassword = async (masterPassword) => {
  if (hasMasterPassword()) {
    check(hasLocalKey(), "Please restore wallet first!");
  }
  const result = await setupMasterPassword(masterPassword);
  return result;
};
var verifyMasterPassword = async (masterPassword) => {
  try {
    await checkMasterPassword(masterPassword);
  } catch (error) {
    if ((error == null ? void 0 : error.message) === "Master password decryption error") {
      return false;
    } else {
      throw error;
    }
  }
  return true;
};
var getSecurityAccount = () => {
  const info = requireNotNullish(userStorage_default.getSecurityAccount(), "Please connect first!");
  return info;
};
var getAuthorizationDApps = async () => {
  const result = await pnApi_default.getAuthorizations();
  return result;
};
var deleteAuthorizationDApp = async (projectAppUuid) => {
  const result = await pnApi_default.deleteAuthorization(projectAppUuid);
  return result;
};
